# IB_INSYNC Complete Reference (Deduplicated)

This documentation has been automatically deduplicated to remove redundant examples
while preserving all unique information.


## Twap

### Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter.

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 10000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'
order.algoStrategy = 'Twap'
order.algoParams = [
    TagValue('startTime', '09:30:00 EST'),
    TagValue('endTime', '16:00:00 EST'),
    TagValue('allowPastEndTime', '1')
]

# Requires contract definition before placement:
# trade = ib.placeOrder(contract, order)
```

> **Note:** Example 2 adds 'allowPastEndTime=1' parameter and demonstrates order placement. Example 1 omits these but shows basic structure. Both use same core TWAP configuration.


## Async

### Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...

```python
# Blocking interface - simple and direct
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)  # Blocks until complete
```

> **Note:** Single example, no duplicates found

### ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)   Blocks until complete


```python
# Asynchronous interface - non-blocking
import asyncio
from ib_insync import *

async def main():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking
    
asyncio.run(main())
```

> **Note:** Single example, no duplicates found

### For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package.

```python
# Jupyter notebook setup
from ib_insync import *

util.startLoop()  # Enables nested event loops
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
# Can now use blocking methods directly in notebook cells
```

> **Note:** Single example, no duplicates found

### ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.

```python
# Synchronous event handler
def onOrderStatus(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    if trade.isDone():
        print(f"Filled at: {trade.orderStatus.avgFillPrice}")

ib.orderStatusEvent += onOrderStatus

# Asynchronous event handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        print(f"New bar: {bars[-1]}")
        # Can use await inside async handlers
        await ib.qualifyContractsAsync(contract)

bars.updateEvent += onBarUpdate
```

> **Note:** Single example, no duplicates found

### Ticker-specific events provide fine-grained control over individual market data subscriptions:

```python
contract = Forex('EURUSD')
ticker = ib.reqMktData(contract)

async def onTickerUpdate(ticker):
    print(f"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}")
    
ticker.updateEvent += onTickerUpdate
```

> **Note:** Single example, no duplicates found

### Unsubscribe from events using the -= operator, and use the @event.once decorator for one-time handlers that automatically unsubscribe after firing.

```python
# Unsubscribe
ticker.updateEvent -= onTickerUpdate

# One-time handler
@ticker.updateEvent.once
def onFirstUpdate(ticker):
    print(f"First update received: {ticker.last}")
```

> **Note:** Single example, no duplicates found

### Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations.

```python
async def get_multiple_contracts():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    contracts = [
        Stock('AAPL', 'SMART', 'USD'),
        Stock('GOOGL', 'SMART', 'USD'),
        Stock('MSFT', 'SMART', 'USD')
    ]
    
    # Request all contract details concurrently
    results = await asyncio.gather(*[
        ib.reqContractDetailsAsync(c) for c in contracts
    ])
    
    return results
```

> **Note:** Single example, no duplicates found

### Use asyncio.createtask() for truly concurrent execution of independent operations:

```python
async def monitor_multiple_tickers():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    async def watch_ticker(contract):
        ticker = ib.reqMktData(contract)
        await ib.sleep(1)
        return ticker
    
    # Create tasks for concurrent execution
    tasks = [
        asyncio.create_task(watch_ticker(Forex('EURUSD'))),
        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),
        asyncio.create_task(watch_ticker(Forex('USDJPY')))
    ]
    
    tickers = await asyncio.gather(*tasks)
    return tickers
```

> **Note:** Single example, no duplicates found

### Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately.

```python
# WRONG - blocks event loop in callback
def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        ib.qualifyContracts(contract)  # Blocking!

# CORRECT - use async handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        await ib.qualifyContractsAsync(contract)
```

> **Note:** Single example, no duplicates found

### Missing tick data with waitOnUpdate(): The waitOnUpdate() method can miss rapid updates because ticks from the first update get cleared before processing. Always use event handlers for tick data colle...

```python
# WRONG - misses rapid ticks
while True:
    ib.waitOnUpdate()
    print(ticker.last)

# CORRECT - captures all updates
def onTicker(ticker):
    print(ticker.last)
    
ticker.updateEvent += onTicker
```

> **Note:** Single example, no duplicates found

### ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.

```python
# WRONG - threading with asyncio
from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor(max_workers=2)
executor.submit(ib.positions)  # Will fail!

# CORRECT - use asyncio tasks
async def fetch_multiple_contracts():
    tasks = [
        ib.qualifyContractsAsync(contract1),
        ib.qualifyContractsAsync(contract2),
        ib.qualifyContractsAsync(contract3)
    ]
    results = await asyncio.gather(*tasks)
    return results
```

> **Note:** Single example, no duplicates found

###  Code Examples
- Fetching consecutive historical data
- Async streaming ticks
- Scanner data (blocking)
- Scanner data (streaming)
- Option calculations
- Order book
- Minimum price increments
- News ...

```python
pip install ib_insync


from ib_insync import *
# util.startLoop() # uncomment this line when in a notebook
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
contract, endDateTime='', durationStr='30 D',
barSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)

# convert to pandas dataframe:
df = util.df(bars)
print(df)
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.

###  Heartbeat Monitor

```python
class HeartbeatMonitor:
    def __init__(self, ib, timeout=60):
        self.ib = ib
        self.timeout = timeout
        self.last_update = time.time()
        self.ib.updateEvent += self.on_update
        
    def on_update(self):
        """Reset timer on any update"""
        self.last_update = time.time()
    
    def check(self):
        """Check if connection is alive"""
        elapsed = time.time() - self.last_update
        
        if elapsed > self.timeout:
            logging.warning(f"No updates for {elapsed:.0f}s. Connection may be dead.")
            return False
        
        return True
    
    def run(self):
        """Run heartbeat check loop"""
        while True:
            if not self.check():
                logging.error("Heartbeat timeout. Triggering reconnect...")
                # Trigger reconnection
                break
            
            time.sleep(10)

# Usage
heartbeat = HeartbeatMonitor(ib, timeout=60)
# Run in separate thread or async task
```

> **Note:** Single example, no duplicates found

###  Connect (Async)

```python
await ib.connectAsync(
    host, port, clientId, 
    timeout, readonly, account, raiseSyncErrors
) -> None
```

> **Note:** Single example, no duplicates found

###  Loop Management

```python
ib.run()  # Run until disconnect
await ib.runAsync()  # Async version

# Condition-based iteration
for update in ib.loopUntil(timeout=60):
    if condition:
        break
```

> **Note:** Single example, no duplicates found

###  Jupyter Notebooks

```python
# At start of notebook
util.startLoop()

# Or with old notebooks
util.patchAsyncio()
```

> **Note:** Single example, no duplicates found

###  Qt Integration

```python
util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'
# Integrates asyncio with Qt event loop
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
ib = IB()
ib.RequestTimeout = 30  # 30 second timeout
ib.RaiseRequestErrors = True  # Raise exceptions

try:
    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)
except asyncio.TimeoutError:
    print("Connection timeout!")
```

> **Note:** Single example, no duplicates found

### Event loop conflicts

```python
# At start of notebook:
util.startLoop()

# If still issues:
util.patchAsyncio()

# For old notebooks:
import nest_asyncio
nest_asyncio.apply()
```

> **Note:** Single example, no duplicates found


## Connect

###  Basic Pattern

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

order = LimitOrder('BUY', 100, 175.0)
trade = ib.placeOrder(contract, order)

# Wait for fill
while not trade.isDone():
    ib.sleep(0.1)

print(f"Status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Basic Ticker (Streaming)

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Start streaming
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data
ib.sleep(2)

print(f"Bid: {ticker.bid}")
print(f"Ask: {ticker.ask}")
print(f"Last: {ticker.last}")
print(f"Volume: {ticker.volume}")
```

> **Note:** Single example, no duplicates found

### Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...

```python
# Blocking interface - simple and direct
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)  # Blocks until complete
```

> **Note:** Single example, no duplicates found

### ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)   Blocks until complete


```python
# Asynchronous interface - non-blocking
import asyncio
from ib_insync import *

async def main():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking
    
asyncio.run(main())
```

> **Note:** Single example, no duplicates found

### For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package.

```python
# Jupyter notebook setup
from ib_insync import *

util.startLoop()  # Enables nested event loops
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
# Can now use blocking methods directly in notebook cells
```

> **Note:** Single example, no duplicates found

### For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def onTicker(ticker):
    print(f"Price update: {ticker.contract.symbol} @ {ticker.last}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += onTicker

ib.run()  # Runs event loop indefinitely
```

> **Note:** Single example, no duplicates found

### Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations.

```python
async def get_multiple_contracts():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    contracts = [
        Stock('AAPL', 'SMART', 'USD'),
        Stock('GOOGL', 'SMART', 'USD'),
        Stock('MSFT', 'SMART', 'USD')
    ]
    
    # Request all contract details concurrently
    results = await asyncio.gather(*[
        ib.reqContractDetailsAsync(c) for c in contracts
    ])
    
    return results
```

> **Note:** Single example, no duplicates found

### Use asyncio.createtask() for truly concurrent execution of independent operations:

```python
async def monitor_multiple_tickers():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    async def watch_ticker(contract):
        ticker = ib.reqMktData(contract)
        await ib.sleep(1)
        return ticker
    
    # Create tasks for concurrent execution
    tasks = [
        asyncio.create_task(watch_ticker(Forex('EURUSD'))),
        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),
        asyncio.create_task(watch_ticker(Forex('USDJPY')))
    ]
    
    tickers = await asyncio.gather(*tasks)
    return tickers
```

> **Note:** Single example, no duplicates found

### Not checking connection state: Always verify connection before state access.

```python
def get_price():
    if not ib.isConnected():
        raise ConnectionError("Not connected to IB")
    ticker = ib.reqMktData(contract)
    ib.sleep(2)
    if ticker.last:
        return ticker.last
    raise ValueError("No price data available")
```

> **Note:** Single example, no duplicates found

###  Production-ready state manager

```python
from ib_insync import *
import logging

class IBDataManager:
    """Demonstrates best practices for single source of truth pattern"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self._setup_logging()
        self._setup_events()
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _setup_events(self):
        self.ib.connectedEvent += self._on_connected
        self.ib.disconnectedEvent += self._on_disconnected
        self.ib.positionEvent += self._on_position
        self.ib.updatePortfolioEvent += self._on_portfolio
    
    def connect(self):
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info("Connected to IB")
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _on_connected(self):
        self.logger.info("Connection established")
        self.ib.reqAccountSummary()
    
    def _on_disconnected(self):
        self.logger.warning("Disconnected from IB")
    
    def _on_position(self, position):
        self.logger.info(f"Position update: {position.contract.symbol}")
    
    def _on_portfolio(self, item):
        self.logger.info(f"Portfolio update: {item.contract.symbol}")
    
    def get_current_positions(self):
        """Get current positions (always fresh from single source)"""
        if not self.ib.isConnected():
            raise ConnectionError("Not connected")
        return self.ib.positions()
    
    def get_position_for_symbol(self, symbol):
        """Get position for specific symbol"""
        for pos in self.get_current_positions():
            if pos.contract.symbol == symbol:
                return pos
        return None
```

> **Note:** Single example, no duplicates found

### Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets.

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Create and qualify contract
contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Create and place market order
order = MarketOrder('BUY', 100)
trade = ib.placeOrder(contract, order)

# Monitor order status
print(f"Order status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

### The Future class provides the cleanest syntax for futures contracts:

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Recommended method
contract = Future('ES', '202506', 'CME')

# With additional parameters
contract = Future(
    symbol='ES',
    lastTradeDateOrContractMonth='202506',
    exchange='CME',
    localSymbol='ESM6',
    multiplier='50',
    currency='USD'
)
```

> **Note:** Single example, no duplicates found

### The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Subscribe to market data
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data to populate
ib.sleep(2)

# Access real-time data
print(f"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}")
```

> **Note:** Single example, no duplicates found

### Proper shutdown procedure:

```python
def shutdown():
    # Cancel all subscriptions
    for contract in active_contracts:
        ib.cancelMktData(contract)
    
    # Allow cancellations to process
    ib.sleep(1)
    
    # Disconnect
    ib.disconnect()

try:
    ib.run()
finally:
    shutdown()
```

> **Note:** Single example, no duplicates found

###  Production-ready streaming system

```python
from ib_insync import *
import logging

logging.basicConfig(level=logging.INFO)

class TradingSystem:
    def __init__(self):
        self.ib = IB()
        self.tickers = {}
        self.active_contracts = set()
        
    def connect(self):
        self.ib.connect('127.0.0.1', 7497, clientId=1)
        self.ib.errorEvent += self.onError
        self.ib.pendingTickersEvent += self.onPendingTickers
        
    def subscribe(self, symbol):
        contract = Stock(symbol, 'SMART', 'USD')
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract, '', False, False)
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
    def onPendingTickers(self, tickers):
        for ticker in tickers:
            self.process_ticker(ticker)
            
    def process_ticker(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")
        
        # Always yield control in callbacks
        self.ib.sleep(0)
        
    def onError(self, reqId, errorCode, errorString, contract):
        logging.error(f"Error {errorCode}: {errorString}")
        
    def shutdown(self):
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
        self.ib.sleep(1)
        self.ib.disconnect()
        
    def run(self):
        try:
            self.ib.run()
        except KeyboardInterrupt:
            print("Shutting down...")
        finally:
            self.shutdown()

# Usage
if __name__ == '__main__':
    system = TradingSystem()
    system.connect()
    system.subscribe('AAPL')
    system.subscribe('GOOGL')
    system.run()
```

> **Note:** Single example, no duplicates found

### When working with futures contracts in ibinsync, accurate exchange specification is critical. Here's the current correct approach:

```python
from ib_insync import *

# Connect to IB
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Correct approach for E-mini S&P 500 futures
es_contract = Future(symbol='ES', lastTradeDateOrContractMonth='202506', exchange='CME')

# Correct approach for Micro E-mini Nasdaq-100 futures
mnq_contract = Future(symbol='MNQ', lastTradeDateOrContractMonth='202506', exchange='CME')

# Correct approach for Crude Oil futures
cl_contract = Future(symbol='CL', lastTradeDateOrContractMonth='202506', exchange='NYMEX')

# Qualify the contracts
qualified_contracts = ib.qualifyContracts(es_contract, mnq_contract, cl_contract)
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

###  Code Examples
- Fetching consecutive historical data
- Async streaming ticks
- Scanner data (blocking)
- Scanner data (streaming)
- Option calculations
- Order book
- Minimum price increments
- News ...

```python
pip install ib_insync


from ib_insync import *
# util.startLoop() # uncomment this line when in a notebook
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
contract, endDateTime='', durationStr='30 D',
barSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)

# convert to pandas dataframe:
df = util.df(bars)
print(df)
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =
'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:
float = 2, appStartupTime: float = 30, ...

```python
def onConnected():
    print(ib.accountValues())

ibc = IBC(974, gateway=True, tradingMode='paper')
ib = IB()
ib.connectedEvent += onConnected
watchdog = Watchdog(ibc, ib, port=4002)
watchdog.start()
ib.run()
```

> **Note:** Single example, no duplicates found

###  Fetching consecutive historical data

```python
import datetime
from ib_insync import *
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
contract = Stock('TSLA', 'SMART', 'USD')
dt = ''
barsList = []
while True:
bars = ib.reqHistoricalData(
contract,
endDateTime=dt,
durationStr='10 D',
barSizeSetting='1 min',
whatToShow='MIDPOINT',
useRTH=True,
formatDate=1)
if not bars:
break
barsList.append(bars)
dt = bars[0].date
print(dt)
# save to CSV file
allBars = [b for bars in reversed(barsList) for b in bars]
df = util.df(allBars)
df.to_csv(contract.symbol + '.csv', index=False)
```

> **Note:** Single example, no duplicates found

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.

###  Integration with Tkinter

```python
class TkApp:
    """
    Example of integrating with Tkinter.
    """
    def __init__(self):
        self.ib = IB().connect()
        self.root = tk.Tk()
        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)
        self.entry = tk.Entry(self.root, width=50)
        self.entry.insert(0, "Stock('TSLA', 'SMART', 'USD')")
        self.entry.grid()
        self.button = tk.Button(
            self.root, text='Get details', command=self.onButtonClick)
        self.button.grid()
        self.text = tk.Text(self.root)
        self.text.grid()
        self.loop = util.getLoop()

    def onButtonClick(self):
        contract = eval(self.entry.get())
        cds = self.ib.reqContractDetails(contract)
        self.text.delete(1.0, tk.END)
        self.text.insert(tk.END, str(cds))

    def run(self):
        self._onTimeout()
        self.loop.run_forever()

    def _onTimeout(self):
        self.root.update()
        self.loop.call_later(0.03, self._onTimeout)

    def _onDeleteWindow(self):
        self.loop.stop()


app = TkApp()
app.run()
```

> **Note:** Single example, no duplicates found

###  Price-Based Condition

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Order triggers when SPY hits 450
contract = Stock('AAPL', 'SMART', 'USD')
trigger_contract = Stock('SPY', 'SMART', 'USD')

# Qualify both
contract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)

# Create price condition
condition = PriceCondition(
    condType=1,  # Price
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,  # True = above, False = below
    price=450.0
)

# Create order with condition
order = LimitOrder('BUY', 100, 175.0)
order.conditions = [condition]
order.conditionsIgnoreRth = False
order.conditionsCancelOrder = False

trade = ib.placeOrder(contract, order)
print(f"Conditional order placed: {trade.order.orderId}")
```

> **Note:** Single example, no duplicates found

###  Vertical Spread (Bull Call Spread)

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Define legs
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')

# Qualify
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

# Create combo contract
combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

# Define legs
leg1 = ComboLeg()
leg1.conId = buy_call.conId
leg1.ratio = 1
leg1.action = 'BUY'
leg1.exchange = 'SMART'

leg2 = ComboLeg()
leg2.conId = sell_call.conId
leg2.ratio = 1
leg2.action = 'SELL'
leg2.exchange = 'SMART'

combo.comboLegs = [leg1, leg2]

# Place order
order = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50
trade = ib.placeOrder(combo, order)
```

> **Note:** Single example, no duplicates found

###  Comprehensive Error Handler

```python
from ib_insync import *
import logging

class IBErrorHandler:
    def __init__(self, ib):
        self.ib = ib
        self.error_log = []
        self.ib.errorEvent += self.on_error
        
    def on_error(self, reqId, errorCode, errorString, contract):
        """Centralized error handling"""
        error_info = {
            'time': datetime.now(),
            'reqId': reqId,
            'code': errorCode,
            'message': errorString,
            'contract': contract
        }
        self.error_log.append(error_info)
        
        # Categorize and handle
        if errorCode in [502, 503, 504]:
            self.handle_connection_error(errorCode, errorString)
        elif errorCode in [200, 201, 202]:
            self.handle_order_error(errorCode, errorString, contract)
        elif errorCode == 162:
            self.handle_data_error(errorCode, errorString, contract)
        elif errorCode == 354:
            self.handle_market_data_subscription_error(errorCode, errorString)
        elif errorCode in [2104, 2106, 2158]:
            # Info messages - ignore
            pass
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def handle_connection_error(self, code, message):
        """Handle connection failures"""
        logging.critical(f"Connection error {code}: {message}")
        # Trigger reconnection
        self.schedule_reconnect()
    
    def handle_order_error(self, code, message, contract):
        """Handle order rejections"""
        logging.error(f"Order error {code}: {message} for {contract}")
        # Could retry with modified params
        # Or alert user
    
    def handle_data_error(self, code, message, contract):
        """Handle data request failures"""
        logging.warning(f"Data error {code}: {message} for {contract}")
        # Retry with different params
    
    def handle_market_data_subscription_error(self, code, message):
        """Handle market data subscription issues"""
        logging.warning(f"Market data error {code}: {message}")
        # Fall back to delayed data
        self.ib.reqMarketDataType(3)  # Delayed
    
    def schedule_reconnect(self):
        """Schedule reconnection attempt"""
        # Implementation in reconnection section
        pass

# Usage
ib = IB()
error_handler = IBErrorHandler(ib)
ib.connect('127.0.0.1', 7497, clientId=1)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Heartbeat Monitor

```python
class HeartbeatMonitor:
    def __init__(self, ib, timeout=60):
        self.ib = ib
        self.timeout = timeout
        self.last_update = time.time()
        self.ib.updateEvent += self.on_update
        
    def on_update(self):
        """Reset timer on any update"""
        self.last_update = time.time()
    
    def check(self):
        """Check if connection is alive"""
        elapsed = time.time() - self.last_update
        
        if elapsed > self.timeout:
            logging.warning(f"No updates for {elapsed:.0f}s. Connection may be dead.")
            return False
        
        return True
    
    def run(self):
        """Run heartbeat check loop"""
        while True:
            if not self.check():
                logging.error("Heartbeat timeout. Triggering reconnect...")
                # Trigger reconnection
                break
            
            time.sleep(10)

# Usage
heartbeat = HeartbeatMonitor(ib, timeout=60)
# Run in separate thread or async task
```

> **Note:** Single example, no duplicates found

###  Multi-Account Order Router

```python
class MultiAccountRouter:
    def __init__(self, host='127.0.0.1', port=7497):
        self.connections = {}
        self.host = host
        self.port = port
        
    def add_account(self, account_name, client_id):
        """Add account connection"""
        ib = IB()
        ib.connect(self.host, self.port, client_id)
        self.connections[account_name] = ib
        logging.info(f"Connected account {account_name} with clientId {client_id}")
    
    def place_order_all(self, contract, order_template, quantities):
        """
        Place orders across multiple accounts
        
        Args:
            contract: Contract to trade
            order_template: Base order
            quantities: Dict[account_name, quantity]
        """
        trades = {}
        
        for account_name, quantity in quantities.items():
            if account_name not in self.connections:
                logging.error(f"Account {account_name} not connected")
                continue
            
            ib = self.connections[account_name]
            
            # Clone order
            order = Order(**{k: v for k, v in order_template.__dict__.items()})
            order.totalQuantity = quantity
            order.account = account_name
            
            # Place order
            trade = ib.placeOrder(contract, order)
            trades[account_name] = trade
            
            logging.info(f"Placed {order.action} {quantity} {contract.symbol} for {account_name}")
        
        return trades
    
    def get_combined_portfolio(self):
        """Get combined portfolio across all accounts"""
        combined = {}
        
        for account_name, ib in self.connections.items():
            for item in ib.portfolio():
                symbol = item.contract.symbol
                
                if symbol not in combined:
                    combined[symbol] = {
                        'position': 0,
                        'market_value': 0,
                        'unrealized_pnl': 0,
                        'accounts': {}
                    }
                
                combined[symbol]['position'] += item.position
                combined[symbol]['market_value'] += item.marketValue
                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL
                combined[symbol]['accounts'][account_name] = item.position
        
        return combined
    
    def disconnect_all(self):
        """Disconnect all accounts"""
        for account_name, ib in self.connections.items():
            ib.disconnect()
            logging.info(f"Disconnected {account_name}")

# Usage
router = MultiAccountRouter()
router.add_account('Account1', client_id=1)
router.add_account('Account2', client_id=2)
router.add_account('Account3', client_id=3)

# Place order across all accounts
contract = Stock('AAPL', 'SMART', 'USD')
order_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account

quantities = {
    'Account1': 100,
    'Account2': 200,
    'Account3': 150
}

trades = router.place_order_all(contract, order_template, quantities)

# Monitor combined portfolio
combined = router.get_combined_portfolio()
for symbol, data in combined.items():
    print(f"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts")
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Minimal Example

```python
from ib_insync import *

# Jupyter notebook? Uncomment:
# util.startLoop()

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Get account info
account = ib.managedAccounts()[0]
print(f"Connected to account: {account}")

# Create contract
contract = Stock('AAPL', 'SMART', 'USD')

# Get market data
ticker = ib.reqMktData(contract)
ib.sleep(2)  # Wait for data
print(ticker.marketPrice())

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Events

```python
events = (
    'connectedEvent',       # Connection established
    'disconnectedEvent',    # Connection lost
    'updateEvent',          # Any state update
    'pendingTickersEvent',  # Ticker updates available
    'barUpdateEvent',       # Real-time bar update
    'newOrderEvent',        # New order created
    'orderModifyEvent',     # Order modified
    'cancelOrderEvent',     # Order cancel requested
    'openOrderEvent',       # Open order status
    'orderStatusEvent',     # Order status changed
    'execDetailsEvent',     # Trade execution details
    'commissionReportEvent',# Commission report
    'updatePortfolioEvent', # Portfolio updated
    'positionEvent',        # Position changed
    'accountValueEvent',    # Account value updated
    'accountSummaryEvent',  # Account summary updated
    'pnlEvent',            # PnL update
    'pnlSingleEvent',      # Single position PnL
    'scannerDataEvent',    # Scanner data received
    'tickNewsEvent',       # News tick
    'newsBulletinEvent',   # News bulletin
    'errorEvent',          # Error occurred
    'timeoutEvent'         # Request timeout
)
```

> **Note:** Single example, no duplicates found

###  Connect (Blocking)

```python
ib.connect(
    host: str = '127.0.0.1',
    port: int = 7497,           # 7497=TWS, 4001=Gateway
    clientId: int = 1,          # Unique per connection
    timeout: float = 2.0,       # Connection timeout (0=no limit)
    readonly: bool = False,     # Read-only mode
    account: str = '',          # Main account for updates
    raiseSyncErrors: bool = True # Raise sync errors
) -> None
```

> **Note:** Single example, no duplicates found

###  Connect (Async)

```python
await ib.connectAsync(
    host, port, clientId, 
    timeout, readonly, account, raiseSyncErrors
) -> None
```

> **Note:** Single example, no duplicates found

###  Disconnect

```python
ib.disconnect() -> None
```

> **Note:** Single example, no duplicates found

###  Check Connection

```python
ib.isConnected() -> bool
ib.client.isReady() -> bool  # API ready
```

> **Note:** Single example, no duplicates found

###  Loop Management

```python
ib.run()  # Run until disconnect
await ib.runAsync()  # Async version

# Condition-based iteration
for update in ib.loopUntil(timeout=60):
    if condition:
        break
```

> **Note:** Single example, no duplicates found

###  Event Handling

```python
# Events use eventkit library

# Subscribe to event
def onPendingTickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.marketPrice()}")

ib.pendingTickersEvent += onPendingTickers

# Unsubscribe
ib.pendingTickersEvent -= onPendingTickers

# One-time handler
ib.connectedEvent += lambda: print('Connected!')
```

> **Note:** Single example, no duplicates found

###  Connection Events

```python
# Connected
ib.connectedEvent += lambda: print('Connected to TWS')

# Disconnected
ib.disconnectedEvent += lambda: print('Disconnected')

# Error
ib.errorEvent += lambda reqId, errorCode, errorString, contract: \
    print(f'Error {errorCode}: {errorString}')
```

> **Note:** Single example, no duplicates found

### Warnings (informational):

```python
2104 - Market data farm connection OK
2106 - Historical data farm connection OK
2158 - Sec-def data farm connection OK
```

> **Note:** Single example, no duplicates found

### Errors:

```python
200 - No security definition found
201 - Order rejected
202 - Order cancelled
321 - Error validating request
326 - Unable to connect (check port)
354 - Requested market data not subscribed
404 - Order held
502 - Couldn't connect to TWS
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
try:
    ticker = ib.reqMktData(contract)
    # ... do work ...
finally:
    ib.cancelMktData(contract)
    ib.disconnect()
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
def on_disconnect():
    print("Disconnected! Attempting reconnect...")
    reconnect_logic()

ib.disconnectedEvent += on_disconnect
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
ib = IB()
ib.RequestTimeout = 30  # 30 second timeout
ib.RaiseRequestErrors = True  # Raise exceptions

try:
    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)
except asyncio.TimeoutError:
    print("Connection timeout!")
```

> **Note:** Single example, no duplicates found

###  Pattern: Live Ticker Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        symbol = ticker.contract.symbol
        price = ticker.marketPrice()
        volume = ticker.volume
        print(f"{symbol}: ${price:.2f} | Vol: {volume}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract, '', False, False)

# Run forever
ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Real-Time Bar Processing

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
contract = ib.qualifyContracts(contract)[0]

def on_bar_update(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        print(f"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += on_bar_update

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Historical Data Download

```python
from ib_insync import *
import pandas as pd

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Download multiple timeframes
timeframes = [
    ('1 Y', '1 day'),
    ('6 M', '1 hour'),
    ('30 D', '15 mins')
]

all_data = {}
for duration, barsize in timeframes:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime='',
        durationStr=duration,
        barSizeSetting=barsize,
        whatToShow='TRADES',
        useRTH=True
    )
    df = util.df(bars)
    all_data[f'{duration}_{barsize}'] = df
    print(f"Downloaded {len(bars)} {barsize} bars for {duration}")

# Save to files
for name, df in all_data.items():
    df.to_csv(f"{contract.symbol}_{name}.csv", index=False)

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Pattern: Portfolio Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def show_portfolio():
    print("\n=== PORTFOLIO ===")
    for item in ib.portfolio():
        symbol = item.contract.symbol
        pos = item.position
        price = item.marketPrice
        value = item.marketValue
        pnl = item.unrealizedPNL
        print(f"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}")
    
    print("\n=== ACCOUNT ===")
    values = ib.accountValues()
    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']
    for value in values:
        if value.tag in important_tags:
            print(f"{value.tag:20} | {value.value:15} {value.currency}")

def on_update(item):
    show_portfolio()

# Show initial state
show_portfolio()

# Update on changes
ib.updatePortfolioEvent += on_update

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Option Chain Analysis

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

# Get option chain
chains = ib.reqSecDefOptParams(
    underlying.symbol,
    '',
    underlying.secType,
    underlying.conId
)

print(f"Found {len(chains)} option chains")

# Get chain for specific exchange
chain = next(c for c in chains if c.exchange == 'SMART')
print(f"Trading class: {chain.tradingClass}")
print(f"Expirations: {sorted(chain.expirations)[:5]}")  # First 5
print(f"Strike range: {min(chain.strikes)} - {max(chain.strikes)}")

# Request contracts for specific expiration
expiration = sorted(chain.expirations)[0]
strikes = sorted([s for s in chain.strikes if 400 < s < 500])

contracts = [
    Option('SPY', expiration, strike, right, 'SMART')
    for strike in strikes[:5]
    for right in ['C', 'P']
]

# Qualify and get details
contracts = ib.qualifyContracts(*contracts)

# Request market data
for contract in contracts:
    ticker = ib.reqMktData(contract, '', False, False)
    ib.sleep(1)
    print(f"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}")

ib.disconnect()
```

> **Note:** Single example, no duplicates found

### Error 502: Couldn't connect to TWS

```python
# Solutions:
# 1. Check TWS/Gateway is running
# 2. Check correct port (7497=TWS, 4001=Gateway)
# 3. Enable API in TWS settings
# 4. Check firewall
# 5. Verify clientId is unique

# Test connection
import socket
sock = socket.socket()
try:
    sock.connect(('127.0.0.1', 7497))
    print("Port is open")
except:
    print("Cannot connect to port")
finally:
    sock.close()
```

> **Note:** Single example, no duplicates found

### Error 326: Unable to connect

```python
# Check API settings in TWS:
# Configuration -> API -> Settings
# - Enable ActiveX and Socket Clients
# - Socket port: 7497 (TWS) or 4001 (Gateway)
# - Trusted IPs: 127.0.0.1
# - Master API client ID: (optional)
```

> **Note:** Single example, no duplicates found

### Orders not showing

```python
# Check:
# 1. Correct clientId
# 2. "Download open orders on connection" enabled in TWS
# 3. Use ib.openOrders() not ib.reqOpenOrders()

# Sync orders
ib.reqOpenOrders()  # Legacy, can be stale
ib.openOrders()     # Better - auto-synced
```

> **Note:** Single example, no duplicates found


## Connection

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.


## Contract

### Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading.

```python
parent, takeProfit, stopLoss = BracketOrder(
    'BUY', 100, 175.0,
    takeProfitPrice=185.0,
    stopLossPrice=170.0
)

for order in (parent, takeProfit, stopLoss):
    ib.placeOrder(contract, order)
```

> **Note:** Examples show different price parameters (175/185/170 vs 150/160/145) demonstrating the pattern works with any price levels. Example 1 includes 'error' tag highlighting potential error handling considerations.

### Creates a trailing stop order that tracks price movements by percentage. Specifies SELL action, 100 shares, 2% trailing offset, and Good-Til-Canceled duration. Includes order placement example requiring a valid contract object. Suitable for percentage-based trailing stop loss strategies.

```python
order = Order()
order.action = 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'
order.trailingPercent = 2.0  # Trail by 2%
order.tif = 'GTC'

# Requires valid contract object
# trade = ib.placeOrder(contract, order)
```

> **Note:** Example 2 includes order placement with contract while Example 1 stops at order configuration. Both use identical order parameters. Actual implementation requires valid contract object for placement.

###  Conditional Order

```python
# Trigger when SPY hits 450
trigger_contract = Stock('SPY', 'SMART', 'USD')
trigger_contract = ib.qualifyContracts(trigger_contract)[0]

condition = PriceCondition(
    condType=1,
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,  # Above price
    price=450.0
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [condition]
```

> **Note:** Single example, no duplicates found

### Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter.

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 10000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'
order.algoStrategy = 'Twap'
order.algoParams = [
    TagValue('startTime', '09:30:00 EST'),
    TagValue('endTime', '16:00:00 EST'),
    TagValue('allowPastEndTime', '1')
]

# Requires contract definition before placement:
# trade = ib.placeOrder(contract, order)
```

> **Note:** Example 2 adds 'allowPastEndTime=1' parameter and demonstrates order placement. Example 1 omits these but shows basic structure. Both use same core TWAP configuration.

###  Basic Pattern

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

order = LimitOrder('BUY', 100, 175.0)
trade = ib.placeOrder(contract, order)

# Wait for fill
while not trade.isDone():
    ib.sleep(0.1)

print(f"Status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  With Validation

```python
# Check buying power first
order_copy = Order(**{k: v for k, v in order.__dict__.items()})
order_copy.whatIf = True

orderState = ib.whatIfOrder(contract, order_copy)
if orderState.commission > 0:
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.

```python
order.lmtPrice = 176.0
trade = ib.placeOrder(contract, order)
```

> **Note:** Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.

###  Single Option

```python
option = Option('SPY', '20240315', 450, 'C', 'SMART')
option = ib.qualifyContracts(option)[0]
order = LimitOrder('BUY', 10, 5.50)
trade = ib.placeOrder(option, order)
```

> **Note:** Single example, no duplicates found

### Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters.

```python
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),
    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')
]

order = LimitOrder('BUY', 10, 5.50)  # Debit spread
trade = ib.placeOrder(combo, order)
```

> **Note:** Key variations: 1) Vertical spread uses same expiration/different strikes, calendar spread uses same strike/different expirations. 2) Action ratios reverse for credit spreads (SELL then BUY). 3) Order direction ('BUY'/'SELL') depends on spread type (debit/credit). Example 2 shows calendar spread construction with reversed actions.

###  Position Entry with Protection

```python
# 1. Enter position
entry = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry)

# 2. Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    avg_price = entry_trade.orderStatus.avgFillPrice
    
    # 3. Set stop loss
    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop
    ib.placeOrder(contract, stop)
    
    # 4. Set take profit
    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit
    ib.placeOrder(contract, target)
```

> **Note:** Single example, no duplicates found

###  Scale In/Out

```python
# Scale in
for qty in [25, 25, 25, 25]:
    order = LimitOrder('BUY', qty, price)
    ib.placeOrder(contract, order)
    ib.sleep(300)  # 5 min between orders

# Scale out
total_position = 100
for pct in [0.25, 0.25, 0.25, 0.25]:
    qty = int(total_position * pct)
    order = LimitOrder('SELL', qty, price)
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Error Handling

```python
def place_order_safe(ib, contract, order):
    try:
        trade = ib.placeOrder(contract, order)
        
        # Wait with timeout
        timeout = 10
        start = time.time()
        while trade.orderStatus.status == 'PendingSubmit':
            if time.time() - start > timeout:
                ib.cancelOrder(order)
                raise TimeoutError("Order submission timeout")
            ib.sleep(0.1)
        
        return trade
    except Exception as e:
        print(f"Order failed: {e}")
        return None
```

> **Note:** Single example, no duplicates found

### ✅ ALWAYS DO THIS:

```python
# For ticks
ticker = ib.reqMktData(contract)
ticker.updateEvent += process_tick

# For bars  
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += process_bar
```

> **Note:** Single example, no duplicates found

###  Basic Ticker (Streaming)

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Start streaming
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data
ib.sleep(2)

print(f"Bid: {ticker.bid}")
print(f"Ask: {ticker.ask}")
print(f"Last: {ticker.last}")
print(f"Volume: {ticker.volume}")
```

> **Note:** Single example, no duplicates found

###  With Event Handler

```python
def on_ticker_update(ticker):
    print(f"{ticker.contract.symbol}: ${ticker.last:.2f}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_ticker_update
```

> **Note:** Single example, no duplicates found

###  Generic Ticks (Extra Data)

```python
# Request additional data
ticker = ib.reqMktData(
    contract,
    genericTickList='233,236',  # Volume, shortable shares
    snapshot=False
)

ib.sleep(2)
print(f"VWAP: {ticker.vwap}")
print(f"RT Volume: {ticker.rtVolume}")
```

> **Note:** Single example, no duplicates found

###  Generic Tick IDs

```python
100 - Option volume
101 - Option open interest  
104 - Historical volatility
106 - Implied volatility
165 - 52-week high/low
221 - Mark price
233 - Last, volume, VWAP
236 - Shortable shares
258 - Fundamental ratios
```

> **Note:** Single example, no duplicates found

###  Cancel Streaming

```python
ib.cancelMktData(contract)
```

> **Note:** Single example, no duplicates found

###  Real-Time Bars (5-Second Updates)

```python
bars = ib.reqRealTimeBars(
    contract,
    barSize=5,              # Always 5 seconds
    whatToShow='TRADES',    # TRADES, MIDPOINT, BID, ASK
    useRTH=False
)

def on_bar_update(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        print(f"{bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close} V:{bar.volume}")

bars.updateEvent += on_bar_update

# Cancel when done
ib.cancelRealTimeBars(bars)
```

> **Note:** Single example, no duplicates found

### Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.

```python
contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',          # '' = now
    durationStr='30 D',      # 30 days
    barSizeSetting='1 hour',
    whatToShow='TRADES',     # Can be MIDPOINT for FX
    useRTH=True              # Regular hours only
)

# Convert to pandas
df = util.df(bars)
print(df.head())
```

> **Note:** Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df

###  Duration Options

```python
'60 S'  - 60 seconds
'1 D'   - 1 day
'2 W'   - 2 weeks
'6 M'   - 6 months
'1 Y'   - 1 year
```

> **Note:** Single example, no duplicates found

###  Keep Historical Updated (Live)

```python
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    keepUpToDate=True  # ← Auto-update!
)

bars.updateEvent += lambda bars, hasNewBar: print(f"Updated: {hasNewBar}")
```

> **Note:** Single example, no duplicates found

###  Tick-by-Tick Data

```python
ticker = ib.reqTickByTickData(
    contract,
    tickType='AllLast',  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'
    numberOfTicks=0,
    ignoreSize=False
)

def on_tick(ticker):
    if ticker.tickByTicks:
        tick = ticker.tickByTicks[-1]
        print(f"Tick: {tick.time} {tick.price} x {tick.size}")

ticker.updateEvent += on_tick
```

> **Note:** Single example, no duplicates found

###  Market Depth (Level II)

```python
ticker = ib.reqMktDepth(
    contract,
    numRows=10,
    isSmartDepth=False
)

ib.sleep(2)

print("Bids:")
for bid in ticker.domBids:
    print(f"  {bid.price} x {bid.size}")

print("Asks:")
for ask in ticker.domAsks:
    print(f"  {ask.price} x {ask.size}")

# Cancel
ib.cancelMktDepth(contract)
```

> **Note:** Single example, no duplicates found

###  Multiple Tickers Pattern

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract)

ib.run()  # Run event loop
```

> **Note:** Single example, no duplicates found

###  Price Alert System

```python
def price_alert(ticker, target_price, above=True):
    """Alert when price crosses threshold"""
    def check_price(ticker):
        if not ticker.last or ticker.last != ticker.last:
            return
        
        if above and ticker.last >= target_price:
            print(f"ALERT: {ticker.contract.symbol} above ${target_price}")
            ticker.updateEvent -= check_price  # Unsubscribe
        elif not above and ticker.last <= target_price:
            print(f"ALERT: {ticker.contract.symbol} below ${target_price}")
            ticker.updateEvent -= check_price
    
    ticker.updateEvent += check_price

# Usage
ticker = ib.reqMktData(contract)
price_alert(ticker, 180.0, above=True)
```

> **Note:** Single example, no duplicates found

###  Moving Average Calculator

```python
class MovingAverage:
    def __init__(self, period=20):
        self.period = period
        self.prices = []
    
    def update(self, price):
        self.prices.append(price)
        if len(self.prices) > self.period:
            self.prices.pop(0)
    
    def value(self):
        return sum(self.prices) / len(self.prices) if self.prices else None

ma20 = MovingAverage(20)

def on_bar(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        ma20.update(bar.close)
        if ma20.value():
            print(f"Price: {bar.close:.2f} | MA20: {ma20.value():.2f}")

bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += on_bar
```

> **Note:** Single example, no duplicates found

###  OHLC Tracker

```python
class OHLCTracker:
    def __init__(self):
        self.open = None
        self.high = None
        self.low = None
        self.close = None
    
    def update(self, price):
        if self.open is None:
            self.open = price
        
        if self.high is None or price > self.high:
            self.high = price
        
        if self.low is None or price < self.low:
            self.low = price
        
        self.close = price
    
    def reset(self):
        self.open = self.high = self.low = self.close = None

tracker = OHLCTracker()

def on_tick(ticker):
    if ticker.last:
        tracker.update(ticker.last)
        print(f"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_tick
```

> **Note:** Single example, no duplicates found

### Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...

```python
# Blocking interface - simple and direct
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)  # Blocks until complete
```

> **Note:** Single example, no duplicates found

### ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)   Blocks until complete


```python
# Asynchronous interface - non-blocking
import asyncio
from ib_insync import *

async def main():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking
    
asyncio.run(main())
```

> **Note:** Single example, no duplicates found

### The golden rule: never use time.sleep()—always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields...

```python
# WRONG - freezes everything
import time
ticker = ib.reqMktData(contract)
time.sleep(5)  # Event loop frozen, no updates processed
print(ticker.last)  # May be empty

# CORRECT - allows message processing
ticker = ib.reqMktData(contract)
ib.sleep(5)  # Framework processes updates in background
print(ticker.last)  # Contains current data
```

> **Note:** Single example, no duplicates found

### For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def onTicker(ticker):
    print(f"Price update: {ticker.contract.symbol} @ {ticker.last}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += onTicker

ib.run()  # Runs event loop indefinitely
```

> **Note:** Single example, no duplicates found

### ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.

```python
# Synchronous event handler
def onOrderStatus(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    if trade.isDone():
        print(f"Filled at: {trade.orderStatus.avgFillPrice}")

ib.orderStatusEvent += onOrderStatus

# Asynchronous event handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        print(f"New bar: {bars[-1]}")
        # Can use await inside async handlers
        await ib.qualifyContractsAsync(contract)

bars.updateEvent += onBarUpdate
```

> **Note:** Single example, no duplicates found

### Ticker-specific events provide fine-grained control over individual market data subscriptions:

```python
contract = Forex('EURUSD')
ticker = ib.reqMktData(contract)

async def onTickerUpdate(ticker):
    print(f"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}")
    
ticker.updateEvent += onTickerUpdate
```

> **Note:** Single example, no duplicates found

### Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations.

```python
async def get_multiple_contracts():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    contracts = [
        Stock('AAPL', 'SMART', 'USD'),
        Stock('GOOGL', 'SMART', 'USD'),
        Stock('MSFT', 'SMART', 'USD')
    ]
    
    # Request all contract details concurrently
    results = await asyncio.gather(*[
        ib.reqContractDetailsAsync(c) for c in contracts
    ])
    
    return results
```

> **Note:** Single example, no duplicates found

### Use asyncio.createtask() for truly concurrent execution of independent operations:

```python
async def monitor_multiple_tickers():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    async def watch_ticker(contract):
        ticker = ib.reqMktData(contract)
        await ib.sleep(1)
        return ticker
    
    # Create tasks for concurrent execution
    tasks = [
        asyncio.create_task(watch_ticker(Forex('EURUSD'))),
        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),
        asyncio.create_task(watch_ticker(Forex('USDJPY')))
    ]
    
    tickers = await asyncio.gather(*tasks)
    return tickers
```

> **Note:** Single example, no duplicates found

### Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately.

```python
# WRONG - blocks event loop in callback
def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        ib.qualifyContracts(contract)  # Blocking!

# CORRECT - use async handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        await ib.qualifyContractsAsync(contract)
```

> **Note:** Single example, no duplicates found

### The critical pattern: never store copies of state in long-lived variables. Always call IB methods to access current state. Stored copies become stale as the Wrapper updates in the background.

```python
# CORRECT - access live state
def check_positions():
    positions = ib.positions()
    for pos in positions:
        print(f"{pos.contract.symbol}: {pos.position}")

# WRONG - storing stale copies
cached_positions = ib.positions()  # Snapshot becomes stale
# Later...
print(cached_positions)  # Likely outdated
```

> **Note:** Single example, no duplicates found

### The returned objects themselves—Ticker, Trade, Position, Portfolio—are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...

```python
# Trade object is automatically updated
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# trade.orderStatus updates automatically in background
def check_order_status():
    if trade.orderStatus.status == 'Filled':
        print("Order filled!")
    elif trade.isDone():
        print("Order completed")
```

> **Note:** Single example, no duplicates found

### Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking.

```python
def onPositionUpdate(position):
    print(f"Position: {position.contract.symbol}: {position.position}")

ib.positionEvent += onPositionUpdate

def onPortfolioUpdate(item):
    print(f"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}")

ib.updatePortfolioEvent += onPortfolioUpdate
```

> **Note:** Single example, no duplicates found

###  Patterns for accessing portfolio and positions

```python
# All portfolio items across accounts
all_portfolio = ib.portfolio()

# Portfolio for specific account
account_portfolio = ib.portfolio(account='U1234567')

# All positions
all_positions = ib.positions()

# Positions for specific account
account_positions = ib.positions(account='U1234567')

# Iterate through positions
for position in ib.positions():
    symbol = position.contract.symbol
    qty = position.position
    avg_cost = position.avgCost
    print(f"{symbol}: {qty} @ ${avg_cost}")
```

> **Note:** Single example, no duplicates found

### ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.

```python
# WRONG - threading with asyncio
from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor(max_workers=2)
executor.submit(ib.positions)  # Will fail!

# CORRECT - use asyncio tasks
async def fetch_multiple_contracts():
    tasks = [
        ib.qualifyContractsAsync(contract1),
        ib.qualifyContractsAsync(contract2),
        ib.qualifyContractsAsync(contract3)
    ]
    results = await asyncio.gather(*tasks)
    return results
```

> **Note:** Single example, no duplicates found

### Not checking connection state: Always verify connection before state access.

```python
def get_price():
    if not ib.isConnected():
        raise ConnectionError("Not connected to IB")
    ticker = ib.reqMktData(contract)
    ib.sleep(2)
    if ticker.last:
        return ticker.last
    raise ValueError("No price data available")
```

> **Note:** Single example, no duplicates found

###  Production-ready state manager

```python
from ib_insync import *
import logging

class IBDataManager:
    """Demonstrates best practices for single source of truth pattern"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self._setup_logging()
        self._setup_events()
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _setup_events(self):
        self.ib.connectedEvent += self._on_connected
        self.ib.disconnectedEvent += self._on_disconnected
        self.ib.positionEvent += self._on_position
        self.ib.updatePortfolioEvent += self._on_portfolio
    
    def connect(self):
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info("Connected to IB")
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _on_connected(self):
        self.logger.info("Connection established")
        self.ib.reqAccountSummary()
    
    def _on_disconnected(self):
        self.logger.warning("Disconnected from IB")
    
    def _on_position(self, position):
        self.logger.info(f"Position update: {position.contract.symbol}")
    
    def _on_portfolio(self, item):
        self.logger.info(f"Portfolio update: {item.contract.symbol}")
    
    def get_current_positions(self):
        """Get current positions (always fresh from single source)"""
        if not self.ib.isConnected():
            raise ConnectionError("Not connected")
        return self.ib.positions()
    
    def get_position_for_symbol(self, symbol):
        """Get position for specific symbol"""
        for pos in self.get_current_positions():
            if pos.contract.symbol == symbol:
                return pos
        return None
```

> **Note:** Single example, no duplicates found

### Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets.

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Create and qualify contract
contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Create and place market order
order = MarketOrder('BUY', 100)
trade = ib.placeOrder(contract, order)

# Monitor order status
print(f"Order status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

### Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders.

```python
def order_status_callback(trade):
    if trade.orderStatus.status == 'Filled':
        fill = trade.fills[-1]
        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '
              f'{fill.execution.shares} @ {fill.execution.avgPrice}')

trade.filledEvent += order_status_callback
```

> **Note:** Single example, no duplicates found

### Limit orders execute only at the specified price or better, providing price protection but no guarantee of execution. Set time-in-force parameters to control order lifespan.

```python
# Basic limit order
limit_order = LimitOrder('BUY', 100, 150.00)
trade = ib.placeOrder(contract, limit_order)

# Limit order with time-in-force
limit_order = LimitOrder('BUY', 100, 150.00)
limit_order.tif = 'GTD'  # Good Till Date
limit_order.goodTillDate = '20240331 23:59:59'
trade = ib.placeOrder(contract, limit_order)

# Allow outside regular trading hours
limit_order = LimitOrder('BUY', 100, 150.00)
limit_order.outsideRth = True
trade = ib.placeOrder(contract, limit_order)
```

> **Note:** Single example, no duplicates found

### Trailing stops follow favorable price movement, maintaining a specified distance from the highest price reached (for sells) or lowest price (for buys). They protect profits while allowing continued up...

```python
# Trailing stop with fixed dollar amount
trailing_order = Order()
trailing_order.action = 'SELL'
trailing_order.orderType = 'TRAIL'
trailing_order.totalQuantity = 100
trailing_order.auxPrice = 2.0  # Trail by $2
trailing_order.trailStopPrice = 150.0  # Initial trigger price

trade = ib.placeOrder(contract, trailing_order)

# Trailing stop with percentage
trailing_order = Order()
trailing_order.action = 'SELL'
trailing_order.orderType = 'TRAIL'
trailing_order.totalQuantity = 100
trailing_order.trailingPercent = 5.0  # Trail by 5%

trade = ib.placeOrder(contract, trailing_order)
```

> **Note:** Single example, no duplicates found

### Trailing stop limit orders trigger a limit order (rather than market order) when the stop is hit, providing more control but risking non-execution:

```python
trail_limit_order = Order()
trail_limit_order.orderType = 'TRAIL LIMIT'
trail_limit_order.totalQuantity = 100
trail_limit_order.action = 'SELL'
trail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop
trail_limit_order.auxPrice = 2.0  # Trail amount
trail_limit_order.trailStopPrice = 150.0

trade = ib.placeOrder(contract, trail_limit_order)
```

> **Note:** Single example, no duplicates found

### OCO orders link multiple orders such that when one executes, the others automatically cancel. Use for scenarios like placing buy orders at multiple price levels where you only want one fill.

```python
# Using the helper method (recommended)
orders = [
    LimitOrder('BUY', 100, 150.00),
    LimitOrder('BUY', 100, 149.00),
    LimitOrder('BUY', 100, 148.00)
]

oca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)

for order in oca_orders:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Manual OCO setup provides more control over individual order parameters:

```python
oca_group_name = 'MyOCAGroup_123'

order1 = LimitOrder('BUY', 100, 150.00)
order1.ocaGroup = oca_group_name
order1.ocaType = 2  # Proportional reduction with block
order1.transmit = False

order2 = LimitOrder('BUY', 100, 149.00)
order2.ocaGroup = oca_group_name
order2.ocaType = 2
order2.transmit = False

order3 = LimitOrder('BUY', 100, 148.00)
order3.ocaGroup = oca_group_name
order3.ocaType = 2
order3.transmit = True  # Last order triggers transmission

ib.placeOrder(contract, order1)
ib.placeOrder(contract, order2)
ib.placeOrder(contract, order3)
```

> **Note:** Single example, no duplicates found

### Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af...

```python
# Using the helper function (recommended)
bracket = ib.bracketOrder(
    'BUY',
    quantity=100,
    limitPrice=150.00,
    takeProfitPrice=155.00,
    stopLossPrice=145.00
)

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For market entry instead of limit entry, modify the parent order:

```python
bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)
bracket[0].orderType = 'MKT'
bracket[0].lmtPrice = 0

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Manual bracket construction for full control:

```python
parent = Order()
parent.orderId = ib.client.getReqId()
parent.action = 'BUY'
parent.orderType = 'LMT'
parent.totalQuantity = 100
parent.lmtPrice = 150.00
parent.transmit = False

takeProfit = Order()
takeProfit.orderId = parent.orderId + 1
takeProfit.action = 'SELL'
takeProfit.orderType = 'LMT'
takeProfit.totalQuantity = 100
takeProfit.lmtPrice = 155.00
takeProfit.parentId = parent.orderId
takeProfit.transmit = False

stopLoss = Order()
stopLoss.orderId = parent.orderId + 2
stopLoss.action = 'SELL'
stopLoss.orderType = 'STP'
stopLoss.auxPrice = 145.00
stopLoss.totalQuantity = 100
stopLoss.parentId = parent.orderId
stopLoss.transmit = True  # Last order triggers all

ib.placeOrder(contract, parent)
ib.placeOrder(contract, takeProfit)
ib.placeOrder(contract, stopLoss)
```

> **Note:** Single example, no duplicates found

### Scale out of positions by setting multiple take-profit levels:

```python
from typing import NamedTuple

class BracketOrderTwoTargets(NamedTuple):
    parent: Order
    takeProfit1: Order
    takeProfit2: Order
    stopLoss: Order

def bracket_two_targets(action, quantity, limit_price, 
                       tp_price1, tp_price2, sl_price, ib):
    """Create bracket with two take-profit targets"""
    
    parent = LimitOrder(action, quantity, limit_price)
    parent.orderId = ib.client.getReqId()
    parent.transmit = False
    
    # First take profit (half position)
    takeProfit1 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price1
    )
    takeProfit1.orderId = parent.orderId + 1
    takeProfit1.parentId = parent.orderId
    takeProfit1.transmit = False
    
    # Second take profit (remaining half)
    takeProfit2 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price2
    )
    takeProfit2.orderId = parent.orderId + 2
    takeProfit2.parentId = parent.orderId
    takeProfit2.transmit = False
    
    # Stop loss for full position
    stopLoss = StopOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity,
        sl_price
    )
    stopLoss.orderId = parent.orderId + 3
    stopLoss.parentId = parent.orderId
    stopLoss.transmit = True
    
    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)

# Usage
bracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)
for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:

```python
contract = Forex('GBPUSD')
ib.qualifyContracts(contract)

# Place entry order
parent_order = MarketOrder('BUY', 25000)
trade = ib.placeOrder(contract, parent_order)

# Wait for fill
ib.sleep(1)
while trade.orderStatus.status != 'Filled':
    ib.waitOnUpdate()

# Calculate levels based on actual fill price
fill_price = trade.orderStatus.avgFillPrice
stop_loss_price = fill_price - 0.0015
take_profit_price = fill_price + 0.0020

# Place child orders
stop_loss_order = StopOrder('SELL', 25000, stop_loss_price)
take_profit_order = LimitOrder('SELL', 25000, take_profit_price)

ib.placeOrder(contract, stop_loss_order)
ib.placeOrder(contract, take_profit_order)
```

> **Note:** Single example, no duplicates found

### The Future class provides the cleanest syntax for futures contracts:

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Recommended method
contract = Future('ES', '202506', 'CME')

# With additional parameters
contract = Future(
    symbol='ES',
    lastTradeDateOrContractMonth='202506',
    exchange='CME',
    localSymbol='ESM6',
    multiplier='50',
    currency='USD'
)
```

> **Note:** Single example, no duplicates found

### The generic Contract class requires more verbose setup:

```python
contract = Contract()
contract.secType = 'FUT'
contract.symbol = 'MNQ'
contract.exchange = 'CME'
contract.currency = 'USD'
contract.localSymbol = 'MNQZ5'
```

> **Note:** Single example, no duplicates found

### Using conId (contract identifier) provides the most precise identification when known:

```python
contract = Contract(conId=495512516)
```

> **Note:** Single example, no duplicates found

### Qualification sends a contract details request to IB servers, fills in missing fields (especially conId, localSymbol, multiplier, exact expiry date, tradingClass), and returns a list of successfully q...

```python
# Single contract
contract = Future('ES', '202506', 'CME')
qualified = ib.qualifyContracts(contract)

# Multiple contracts concurrently
contracts = [
    Future('ES', '202506', 'CME'),
    Future('NQ', '202506', 'CME'),
    Future('CL', '202506', 'NYMEX')
]
qualified = ib.qualifyContracts(*contracts)
```

> **Note:** Single example, no duplicates found

### The method updates the contract object in-place when successful:

```python
contract = Future('ES', '202506', 'CME')
qualified = ib.qualifyContracts(contract)

if qualified:
    contract = qualified[0]
    print(f"ConId: {contract.conId}")
    print(f"Local Symbol: {contract.localSymbol}")
    print(f"Expiry: {contract.lastTradeDateOrContractMonth}")
```

> **Note:** Single example, no duplicates found

### When multiple contracts match your specification, qualifyContracts() logs a warning with possible matches. The solution: be more specific with contract details.

```python
# Too vague - multiple matches
contract = Future('ES', exchange='CME')
ib.qualifyContracts(contract)
# Warning: Ambiguous contract, possibles are [Future('ES', '202506'), ...]

# Specific - unambiguous
contract = Future('ES', '202506', 'CME')
ib.qualifyContracts(contract)  # Success

# Or use localSymbol
contract = Future('ES', exchange='CME', localSymbol='ESM6')
ib.qualifyContracts(contract)  # Success

# Or use conId (most precise)
contract = Contract(conId=495512516)
ib.qualifyContracts(contract)  # Always unambiguous
```

> **Note:** Single example, no duplicates found

### Always validate and handle qualification failures before placing orders:

```python
def validate_futures_contract(ib, contract):
    """Validate and qualify a futures contract"""
    try:
        qualified = ib.qualifyContracts(contract)
        if not qualified:
            print(f"ERROR: Contract could not be qualified")
            return None
        
        contract = qualified[0]
        print(f"✓ Qualified: {contract.localSymbol}")
        print(f"  ConId: {contract.conId}")
        print(f"  Expiry: {contract.lastTradeDateOrContractMonth}")
        return contract
    except Exception as e:
        print(f"ERROR: {e}")
        return None

# Usage
contract = Future('ES', '202506', 'CME')
validated = validate_futures_contract(ib, contract)
if validated:
    order = MarketOrder('BUY', 1)
    trade = ib.placeOrder(validated, order)
```

> **Note:** Single example, no duplicates found

### Use reqContractDetails() to get comprehensive contract information beyond basic qualification:

```python
contract = Future('ES', '202506', 'CME')
details_list = ib.reqContractDetails(contract)

for details in details_list:
    print(f"ConId: {details.contract.conId}")
    print(f"Local Symbol: {details.contract.localSymbol}")
    print(f"Expiry: {details.contract.lastTradeDateOrContractMonth}")
    print(f"Multiplier: {details.contract.multiplier}")
    print(f"Min Tick: {details.minTick}")
    print(f"Market Name: {details.marketName}")
```

> **Note:** Single example, no duplicates found

### The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl...

```python
# Request data for expired contract
contract = Future('ES', '202012', 'CME')
contract.includeExpired = True

qualified = ib.qualifyContracts(contract)
if qualified:
    bars = ib.reqHistoricalData(
        qualified[0],
        endDateTime='',
        durationStr='1 Y',
        barSizeSetting='1 day',
        whatToShow='TRADES',
        useRTH=True
    )
    print(f"Retrieved {len(bars)} bars")
```

> **Note:** Single example, no duplicates found

### Implement automatic front month detection to handle contract rollovers:

```python
from datetime import datetime

def get_front_month_contract(ib, symbol, exchange):
    """Get the front month futures contract"""
    contract = Future(symbol, exchange=exchange)
    contract_details = ib.reqContractDetails(contract)
    
    if not contract_details:
        return None
    
    now = datetime.now()
    active_contracts = []
    
    for details in contract_details:
        expiry_str = details.contract.lastTradeDateOrContractMonth
        if len(expiry_str) == 8:
            expiry = datetime.strptime(expiry_str, '%Y%m%d')
        else:
            expiry = datetime.strptime(expiry_str, '%Y%m')
        
        if expiry > now:
            active_contracts.append((expiry, details.contract))
    
    if not active_contracts:
        return None
    
    # Sort and return front month
    active_contracts.sort(key=lambda x: x[0])
    front_month = active_contracts[0][1]
    
    qualified = ib.qualifyContracts(front_month)
    return qualified[0] if qualified else None

# Usage
es_front = get_front_month_contract(ib, 'ES', 'CME')
print(f"Front month: {es_front.localSymbol}")
```

> **Note:** Single example, no duplicates found

### Check if rollover is needed based on days to expiry:

```python
def check_rollover_needed(contract, days_before=5):
    """Check if rollover needed"""
    expiry_str = contract.lastTradeDateOrContractMonth
    if len(expiry_str) == 8:
        expiry = datetime.strptime(expiry_str, '%Y%m%d')
    else:
        expiry = datetime.strptime(expiry_str + '01', '%Y%m%d')
    
    days_to_expiry = (expiry - datetime.now()).days
    return days_to_expiry <= days_before
```

> **Note:** Single example, no duplicates found

### ContFuture provides rolled contract data for backtesting but has significant limitations:

```python
# Continuous futures (historical data only)
cont_future = ContFuture('ES', 'CME')
ib.qualifyContracts(cont_future)

bars = ib.reqHistoricalData(
    cont_future,
    endDateTime='',
    durationStr='2 Y',
    barSizeSetting='1 day',
    whatToShow='TRADES',
    useRTH=True
)
```

> **Note:** Single example, no duplicates found

### The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Subscribe to market data
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data to populate
ib.sleep(2)

# Access real-time data
print(f"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}")
```

> **Note:** Single example, no duplicates found

### The genericTickList parameter requests specific data fields using tick IDs: 100 (options volume), 101 (options open interest), 106 (implied volatility), 165 (52-week high/low), 233 (time & sales with ...

```python
# Request time & sales data
ticker = ib.reqMktData(contract, '233', False, False)
ib.sleep(2)
print(f"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}")
```

> **Note:** Single example, no duplicates found

### Provides 5-second aggregated bars, the only bar size supported by Interactive Brokers for real-time bar streaming:

```python
contract = Forex('EURUSD')

# Request 5-second bars
bars = ib.reqRealTimeBars(
    contract,
    5,              # Bar size (only 5 seconds supported)
    'MIDPOINT',     # Can be TRADES, MIDPOINT, BID, or ASK
    False           # useRTH
)

# Access bars list
print(bars[-1])  # Most recent bar
```

> **Note:** Single example, no duplicates found

### Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing.

```python
contract = Stock('TSLA', 'SMART', 'USD')

bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    formatDate=1,
    keepUpToDate=True  # Enables live updates
)
```

> **Note:** Example 1 includes formatDate=1 while Example 2 omits it. Example 2 explicitly mentions bars.updateEvent firing on changes. Both agree on core parameters. Contract creation shown in Example 1 but not Example 2.

### The most granular data stream, providing every individual tick from the exchange. Limited to 3 simultaneous subscriptions per client:

```python
contract = Forex('EURUSD')

ticker = ib.reqTickByTickData(
    contract,
    'BidAsk',  # Can be Last, AllLast, BidAsk, or MidPoint
    0,         # numberOfTicks (0 = unlimited)
    False      # ignoreSize
)

# Access tick-by-tick data
print(ticker.tickByTicks)
```

> **Note:** Single example, no duplicates found

### Order book (Level II) data showing bid and ask depth. Requires Level II market data subscription:

```python
contract = Forex('EURUSD')

ticker = ib.reqMktDepth(contract)
ib.sleep(2)

# Access order book
print("Bids:", [(d.price, d.size) for d in ticker.domBids[:5]])
print("Asks:", [(d.price, d.size) for d in ticker.domAsks[:5]])
```

> **Note:** Single example, no duplicates found

### Individual ticker events for ticker-specific logic:

```python
def onTickerUpdate(ticker):
    print(f"{ticker.contract.symbol}: Last {ticker.last}")

contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
ticker.updateEvent += onTickerUpdate

ib.run()
```

> **Note:** Single example, no duplicates found

### Global pendingTickersEvent for monitoring multiple tickers efficiently:

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

def onPendingTickers(tickers):
    """Called when any subscribed ticker has new data"""
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.last}")

ib.pendingTickersEvent += onPendingTickers
ib.run()
```

> **Note:** Single example, no duplicates found

### Bar update events for streaming bar data:

```python
def onBarUpdate(bars, hasNewBar):
    """
    bars: BarDataList containing all bars
    hasNewBar: Boolean indicating if a new bar was added
    """
    if hasNewBar:
        latest = bars[-1]
        print(f"New bar: O={latest.open}, H={latest.high}, "
              f"L={latest.low}, C={latest.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += onBarUpdate
ib.run()
```

> **Note:** Single example, no duplicates found

### Combine ibinsync with pandas for structured data handling:

```python
import pandas as pd

contracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]
ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

# Create DataFrame
df = pd.DataFrame(
    index=[c.pair() for c in contracts],
    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']
)

def onPendingTickers(tickers):
    for t in tickers:
        df.loc[t.contract.pair()] = (
            t.bidSize, t.bid, t.ask, t.askSize, 
            t.high, t.low, t.close
        )
    print(df)

ib.pendingTickersEvent += onPendingTickers
ib.sleep(30)
```

> **Note:** Single example, no duplicates found

### ibinsync automatically throttles requests to 45 requests per second, compatible with TWS/Gateway 974+. No manual intervention needed for individual requests, but spread out batch operations:

```python
for contract in large_contract_list:
    ticker = ib.reqMktData(contract)
    ib.sleep(0.02)  # Small delay between requests
```

> **Note:** Single example, no duplicates found

### Interactive Brokers limits concurrent subscriptions: typically 100 for market data lines, only 3 for tick-by-tick data.

```python
active_subscriptions = set()
MAX_SUBSCRIPTIONS = 95  # Leave margin

def subscribe_with_limit(contract):
    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:
        # Unsubscribe oldest
        oldest = active_subscriptions.pop()
        ib.cancelMktData(oldest)
    
    ticker = ib.reqMktData(contract)
    active_subscriptions.add(contract)
    return ticker
```

> **Note:** Single example, no duplicates found

### Encapsulate subscription management in a reusable class:

```python
class TickerManager:
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.contracts = {}
        
    def subscribe(self, symbol, exchange='SMART', currency='USD'):
        contract = Stock(symbol, exchange, currency)
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract)
        ticker.updateEvent += self.onUpdate
        
        self.tickers[symbol] = ticker
        self.contracts[symbol] = contract
        return ticker
    
    def unsubscribe(self, symbol):
        if symbol in self.tickers:
            self.ib.cancelMktData(self.contracts[symbol])
            del self.tickers[symbol]
            del self.contracts[symbol]
    
    def onUpdate(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")

# Usage
manager = TickerManager(ib)
manager.subscribe('AAPL')
manager.subscribe('GOOGL')
```

> **Note:** Single example, no duplicates found

### Critical: Use the same contract object for cancellation that you used for subscription. Creating a new identical contract won't work—object identity matters.

```python
# WRONG
contract1 = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract1)

contract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!
ib.cancelMktData(contract2)  # Won't work

# CORRECT
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
ib.cancelMktData(contract)  # Use same object
```

> **Note:** Single example, no duplicates found

### Cancel different data types with specific methods:

```python
ib.cancelMktData(contract)
ib.cancelRealTimeBars(bars)
ib.cancelHistoricalData(bars)
ib.cancelTickByTickData(contract, 'BidAsk')
ib.cancelMktDepth(contract)
```

> **Note:** Single example, no duplicates found

### Remove event handlers before unsubscribing to prevent memory leaks:

```python
ticker.updateEvent += handler
# Later...
ticker.updateEvent -= handler
ib.cancelMktData(contract)
```

> **Note:** Single example, no duplicates found

### Proper shutdown procedure:

```python
def shutdown():
    # Cancel all subscriptions
    for contract in active_contracts:
        ib.cancelMktData(contract)
    
    # Allow cancellations to process
    ib.sleep(1)
    
    # Disconnect
    ib.disconnect()

try:
    ib.run()
finally:
    shutdown()
```

> **Note:** Single example, no duplicates found

### Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update—process ticks in event handlers when they arrive.

```python
# WRONG - ticks cleared before checking
ticker = ib.reqMktData(contract)
ib.sleep(5)
print(ticker.ticks)  # Likely empty

# CORRECT - process in event
def onUpdate(ticker):
    for tick in ticker.ticks:
        process_tick(tick)

ticker.updateEvent += onUpdate
```

> **Note:** Single example, no duplicates found

###  Production-ready streaming system

```python
from ib_insync import *
import logging

logging.basicConfig(level=logging.INFO)

class TradingSystem:
    def __init__(self):
        self.ib = IB()
        self.tickers = {}
        self.active_contracts = set()
        
    def connect(self):
        self.ib.connect('127.0.0.1', 7497, clientId=1)
        self.ib.errorEvent += self.onError
        self.ib.pendingTickersEvent += self.onPendingTickers
        
    def subscribe(self, symbol):
        contract = Stock(symbol, 'SMART', 'USD')
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract, '', False, False)
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
    def onPendingTickers(self, tickers):
        for ticker in tickers:
            self.process_ticker(ticker)
            
    def process_ticker(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")
        
        # Always yield control in callbacks
        self.ib.sleep(0)
        
    def onError(self, reqId, errorCode, errorString, contract):
        logging.error(f"Error {errorCode}: {errorString}")
        
    def shutdown(self):
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
        self.ib.sleep(1)
        self.ib.disconnect()
        
    def run(self):
        try:
            self.ib.run()
        except KeyboardInterrupt:
            print("Shutting down...")
        finally:
            self.shutdown()

# Usage
if __name__ == '__main__':
    system = TradingSystem()
    system.connect()
    system.subscribe('AAPL')
    system.subscribe('GOOGL')
    system.run()
```

> **Note:** Single example, no duplicates found

### When working with futures contracts in ibinsync, accurate exchange specification is critical. Here's the current correct approach:

```python
from ib_insync import *

# Connect to IB
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Correct approach for E-mini S&P 500 futures
es_contract = Future(symbol='ES', lastTradeDateOrContractMonth='202506', exchange='CME')

# Correct approach for Micro E-mini Nasdaq-100 futures
mnq_contract = Future(symbol='MNQ', lastTradeDateOrContractMonth='202506', exchange='CME')

# Correct approach for Crude Oil futures
cl_contract = Future(symbol='CL', lastTradeDateOrContractMonth='202506', exchange='NYMEX')

# Qualify the contracts
qualified_contracts = ib.qualifyContracts(es_contract, mnq_contract, cl_contract)
```

> **Note:** Single example, no duplicates found

### For real-time futures trading, always fully qualify your contracts to ensure proper execution:

```python
def get_qualified_futures_contract(ib, symbol, expiry, exchange):
    """Get a fully qualified futures contract ready for trading"""
    contract = Future(symbol=symbol, 
                     lastTradeDateOrContractMonth=expiry,
                     exchange=exchange)
    
    # Request complete contract details
    qualified = ib.qualifyContracts(contract)
    
    if not qualified:
        print(f"ERROR: Could not qualify {symbol} contract")
        return None
        
    # Return the fully qualified contract
    return qualified[0]

# Example usage
es_contract = get_qualified_futures_contract(ib, 'ES', '202506', 'CME')
print(f"ConId: {es_contract.conId}, LocalSymbol: {es_contract.localSymbol}")
```

> **Note:** Single example, no duplicates found

### | Month | Code | Example |
|-------|------|---------|
| January | F | ESF6 (ES Jan 2026) |
| February | G | ESG6 (ES Feb 2026) |
| March | H | ESH6 (ES Mar 2026) |
| April | J | ESJ6 (ES Apr 2026) |
|...

```python
def get_contract_by_symbol(ib, local_symbol):
    """Get contract using local symbol (e.g., 'ESM6')"""
    # Parse the local symbol
    root = ''.join([c for c in local_symbol if c.isalpha()])
    suffix = ''.join([c for c in local_symbol if not c.isalpha()])
    
    # Extract month code and year
    month_code = suffix[0] if len(suffix) > 0 else ''
    year_code = suffix[1:] if len(suffix) > 1 else ''
    
    # Create generic contract
    contract = Contract()
    contract.secType = 'FUT'
    contract.symbol = root
    contract.exchange = get_exchange_for_symbol(root)  # Helper function
    contract.localSymbol = local_symbol
    
    # Qualify the contract
    qualified = ib.qualifyContracts(contract)
    return qualified[0] if qualified else None

def get_exchange_for_symbol(symbol):
    """Get correct exchange for common futures symbols"""
    exchanges = {
        'ES': 'CME', 'MES': 'CME', 'NQ': 'CME', 'MNQ': 'CME',
        'RTY': 'CME', 'M2K': 'CME', 'YM': 'CBOT', 'MYM': 'CBOT',
        'CL': 'NYMEX', 'GC': 'NYMEX', 'SI': 'NYMEX', 'HG': 'NYMEX',
        'ZB': 'CBOT', 'ZN': 'CBOT', 'ZF': 'CBOT', 'ZT': 'CBOT',
        '6E': 'CME', '6A': 'CME', '6B': 'CME', '6J': 'CME'
    }
    return exchanges.get(symbol, 'SMART')
```

> **Note:** Single example, no duplicates found

### For futures trading, complex order types like OCO and trailing stops require careful setup:

```python
# Trailing stop for ES futures
def place_es_trailing_stop(ib, action, quantity, trail_amount):
    """Place a trailing stop order for ES futures"""
    # Get current front month ES contract
    es = get_front_month_contract(ib, 'ES', 'CME')
    
    # Create trailing stop order
    order = Order()
    order.action = action  # 'BUY' or 'SELL'
    order.orderType = 'TRAIL'
    order.totalQuantity = quantity
    order.auxPrice = trail_amount  # Trail amount in points
    
    # Place the order
    trade = ib.placeOrder(es, order)
    return trade

# Market-Limit OCO for MNQ futures
def place_mnq_market_limit_oco(ib, action, quantity, limit_price):
    """Place a market-limit OCO order for MNQ futures"""
    # Get current front month MNQ contract
    mnq = get_front_month_contract(ib, 'MNQ', 'CME')
    
    # Create OCO orders
    market_order = MarketOrder(action, quantity)
    limit_order = LimitOrder(action, quantity, limit_price)
    
    # Set up OCO group
    oca_group = f"MNQ_OCO_{int(time.time())}"  # Unique group ID
    
    market_order.ocaGroup = oca_group
    market_order.ocaType = 2  # Proportional
    
    limit_order.ocaGroup = oca_group
    limit_order.ocaType = 2
    
    # Place orders
    trade1 = ib.placeOrder(mnq, market_order)
    trade2 = ib.placeOrder(mnq, limit_order)
    
    return [trade1, trade2]
```

> **Note:** Single example, no duplicates found

### For live futures data, proper subscription management is essential:

```python
class FuturesDataManager:
    """Manage real-time data for multiple futures contracts"""
    
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.active_contracts = set()
        
    def subscribe(self, symbol, exchange='CME'):
        """Subscribe to real-time market data for a futures contract"""
        # Get front month contract
        contract = get_front_month_contract(self.ib, symbol, exchange)
        
        if not contract:
            print(f"Error: Could not find front month contract for {symbol}")
            return None
            
        # Request market data
        ticker = self.ib.reqMktData(contract, '', False, False)
        
        # Store references
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
        return ticker
        
    def get_price(self, symbol):
        """Get current price for a subscribed symbol"""
        if symbol not in self.tickers:
            return None
            
        ticker = self.tickers[symbol]
        
        # Use last or midpoint price
        if ticker.last:
            return ticker.last
        elif ticker.bid and ticker.ask:
            return (ticker.bid + ticker.ask) / 2
        else:
            return None
    
    def get_contracts_expiring_soon(self, days_threshold=10):
        """Get list of contracts expiring soon"""
        expiring_soon = []
        now = datetime.now()
        
        for contract in self.active_contracts:
            expiry_str = contract.lastTradeDateOrContractMonth
            
            if len(expiry_str) == 8:  # YYYYMMDD format
                expiry = datetime.strptime(expiry_str, '%Y%m%d')
            else:  # YYYYMM format
                expiry = datetime.strptime(f"{expiry_str}01", '%Y%m%d')
                
            days_to_expiry = (expiry - now).days
            
            if days_to_expiry <= days_threshold:
                expiring_soon.append((contract, days_to_expiry))
                
        return expiring_soon
        
    def cleanup(self):
        """Unsubscribe from all market data"""
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
            
        self.tickers.clear()
        self.active_contracts.clear()
```

> **Note:** Single example, no duplicates found

### For continuous futures analysis, use a combination of reqHistoricalData and dynamic front-month tracking:

```python
def get_continuous_futures_data(ib, symbol, exchange, duration='1 Y', bar_size='1 day'):
    """Get historical data for continuous futures contract"""
    # Create a ContFuture for historical data
    contract = ContFuture(symbol, exchange)
    ib.qualifyContracts(contract)
    
    # Request historical data
    bars = ib.reqHistoricalData(
        contract,
        endDateTime='',
        durationStr=duration,
        barSizeSetting=bar_size,
        whatToShow='TRADES',
        useRTH=True
    )
    
    return bars

# Get front month based on volume/open interest
def get_most_liquid_contract(ib, symbol, exchange):
    """Get the most liquid contract based on volume and open interest"""
    # Get all active contracts for this symbol
    contract = Future(symbol, exchange=exchange)
    details_list = ib.reqContractDetails(contract)
    
    if not details_list:
        return None
    
    # Filter out expired contracts
    now = datetime.now()
    active_contracts = []
    
    for details in details_list:
        expiry_str = details.contract.lastTradeDateOrContractMonth
        
        if len(expiry_str) == 8:
            expiry = datetime.strptime(expiry_str, '%Y%m%d')
        else:
            expiry = datetime.strptime(f"{expiry_str}01", '%Y%m%d')
            
        if expiry > now:
            active_contracts.append(details.contract)
    
    if not active_contracts:
        return None
    
    # Get volume data for each contract
    contract_data = []
    
    for contract in active_contracts:
        ticker = ib.reqMktData(contract, '100,101', False, False)  # Request volume and OI
        ib.sleep(1)  # Allow data to populate
        
        contract_data.append({
            'contract': contract,
            'volume': ticker.volume or 0,
            'openInterest': ticker.openInterest or 0
        })
        
        # Cancel the market data request
        ib.cancelMktData(contract)
    
    # Sort by combined volume and open interest
    contract_data.sort(key=lambda x: x['volume'] + x['openInterest'], reverse=True)
    
    # Return the most liquid contract
    return contract_data[0]['contract'] if contract_data else None
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

###  Code Examples
- Fetching consecutive historical data
- Async streaming ticks
- Scanner data (blocking)
- Scanner data (streaming)
- Option calculations
- Order book
- Minimum price increments
- News ...

```python
pip install ib_insync


from ib_insync import *
# util.startLoop() # uncomment this line when in a notebook
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
contract, endDateTime='', durationStr='30 D',
barSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)

# convert to pandas dataframe:
df = util.df(bars)
print(df)
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### 
Order

```python
#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',
totalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =
1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:
str = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',
ocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,
blockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,
triggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,
goodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:
bool = False, minQty: int = 2147483647, percentOffset: float =
1.7976931348623157e+308, overridePercentageConstraints: bool = False,
trailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =
1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str
= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',
origin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:
float = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,
nbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool
= False, auctionStrategy: int = 0, startingPrice: float =
1.7976931348623157e+308, stockRefPrice: float =
1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,
stockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float
= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:
bool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int
= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =
1.7976931348623157e+308, deltaNeutralConId: int = 0,
deltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',
deltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',
deltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,
deltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,
referencePriceType: int = 2147483647, basisPoints: float =
1.7976931348623157e+308, basisPointsType: int = 2147483647,
scaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,
scalePriceIncrement: float = 1.7976931348623157e+308,
scalePriceAdjustValue: float = 1.7976931348623157e+308,
scalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =
1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:
int = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:
bool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',
account: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:
str = '', algoStrategy: str = '', algoParams:
~typing.List[~ib_insync.contract.TagValue] = <factory>,
smartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =
<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,
solicited: bool = False, modelCode: str = '', orderComboLegs:
~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,
orderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,
referenceContractId: int = 0, peggedChangeAmount: float = 0.0,
isPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float
= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:
float = 1.7976931348623157e+308, adjustedStopPrice: float =
1.7976931348623157e+308, adjustedStopLimitPrice: float =
1.7976931348623157e+308, adjustedTrailingAmount: float =
1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:
float = 1.7976931348623157e+308, conditions:
~typing.List[~ib_insync.order.OrderCondition] = <factory>,
conditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,
extOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =
<factory>, cashQty: float = 1.7976931348623157e+308,
mifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',
mifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',
dontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,

Order for trading contracts.
https://interactivebrokers.github.io/tws-api/available_orders.html
orderId: int = 0
clientId: int = 0
permId: int = 0
action: str = ''
totalQuantity: float = 0.0
orderType: str = ''
lmtPrice: float = 1.7976931348623157e+308
auxPrice: float = 1.7976931348623157e+308
tif: str = ''
activeStartTime: str = ''
activeStopTime: str = ''
ocaGroup: str = ''
ocaType: int = 0
orderRef: str = ''
transmit: bool = True
parentId: int = 0
blockOrder: bool = False
sweepToFill: bool = False
displaySize: int = 0
triggerMethod: int = 0
outsideRth: bool = False
hidden: bool = False
goodAfterTime: str = ''
goodTillDate: str = ''
rule80A: str = ''
allOrNone: bool = False
minQty: int = 2147483647
percentOffset: float = 1.7976931348623157e+308
overridePercentageConstraints: bool = False
trailStopPrice: float = 1.7976931348623157e+308
trailingPercent: float = 1.7976931348623157e+308
faGroup: str = ''
faProfile: str = ''
faMethod: str = ''
faPercentage: str = ''
designatedLocation: str = ''
openClose: str = 'O'
origin: int = 0
shortSaleSlot: int = 0
exemptCode: int = -1
discretionaryAmt: float = 0.0
eTradeOnly: bool = False
firmQuoteOnly: bool = False
nbboPriceCap: float = 1.7976931348623157e+308
optOutSmartRouting: bool = False
auctionStrategy: int = 0
startingPrice: float = 1.7976931348623157e+308
stockRefPrice: float = 1.7976931348623157e+308
delta: float = 1.7976931348623157e+308
stockRangeLower: float = 1.7976931348623157e+308
stockRangeUpper: float = 1.7976931348623157e+308
randomizePrice: bool = False
randomizeSize: bool = False
volatility: float = 1.7976931348623157e+308
volatilityType: int = 2147483647
deltaNeutralOrderType: str = ''
deltaNeutralAuxPrice: float = 1.7976931348623157e+308
deltaNeutralConId: int = 0
deltaNeutralSettlingFirm: str = ''
deltaNeutralClearingAccount: str = ''
deltaNeutralClearingIntent: str = ''
deltaNeutralOpenClose: str = ''
deltaNeutralShortSale: bool = False
deltaNeutralShortSaleSlot: int = 0
deltaNeutralDesignatedLocation: str = ''
continuousUpdate: bool = False
referencePriceType: int = 2147483647
basisPoints: float = 1.7976931348623157e+308
basisPointsType: int = 2147483647
scaleInitLevelSize: int = 2147483647
scaleSubsLevelSize: int = 2147483647
scalePriceIncrement: float = 1.7976931348623157e+308
scalePriceAdjustValue: float = 1.7976931348623157e+308
scalePriceAdjustInterval: int = 2147483647
scaleProfitOffset: float = 1.7976931348623157e+308
scaleAutoReset: bool = False
scaleInitPosition: int = 2147483647
scaleInitFillQty: int = 2147483647
scaleRandomPercent: bool = False
scaleTable: str = ''
hedgeType: str = ''
hedgeParam: str = ''
account: str = ''
settlingFirm: str = ''
clearingAccount: str = ''
clearingIntent: str = ''
algoStrategy: str = ''
algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
algoId: str = ''
whatIf: bool = False
notHeld: bool = False
solicited: bool = False
modelCode: str = ''
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
referenceContractId: int = 0
peggedChangeAmount: float = 0.0
isPeggedChangeAmountDecrease: bool = False
referenceChangeAmount: float = 0.0
referenceExchangeId: str = ''
adjustedOrderType: str = ''
triggerPrice: float = 1.7976931348623157e+308
adjustedStopPrice: float = 1.7976931348623157e+308
adjustedStopLimitPrice: float = 1.7976931348623157e+308
adjustedTrailingAmount: float = 1.7976931348623157e+308
adjustableTrailingUnit: int = 0
lmtPriceOffset: float = 1.7976931348623157e+308
conditions: List[OrderCondition]
conditionsCancelOrder: bool = False
conditionsIgnoreRth: bool = False
extOperator: str = ''
softDollarTier: SoftDollarTier
cashQty: float = 1.7976931348623157e+308
mifid2DecisionMaker: str = ''
mifid2DecisionAlgo: str = ''
mifid2ExecutionTrader: str = ''
mifid2ExecutionAlgo: str = ''
dontUseAutoPriceForHedge: bool = False
isOmsContainer: bool = False
discretionaryUpToLimitPrice: bool = False
autoCancelDate: str = ''
filledQuantity: float = 1.7976931348623157e+308
refFuturesConId: int = 0
autoCancelParent: bool = False
shareholder: str = ''
imbalanceOnly: bool = False
routeMarketableToBbo: bool = False
parentPermId: int = 0
usePriceMgmtAlgo: bool = False
duration: int = 2147483647
postToAts: int = 2147483647
advancedErrorOverride: str = ''
manualOrderTime: str = ''
minTradeQty: int = 2147483647
minCompeteSize: int = 2147483647
competeAgainstBestOffset: float = 1.7976931348623157e+308
midOffsetAtWhole: float = 1.7976931348623157e+308
midOffsetAtHalf: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)
dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =
0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,
lastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',
mktCapPrice: float = 0.0)

orderId: int = 0
status: str = ''
filled: float = 0.0
remaining: float = 0.0
avgFillPrice: float = 0.0
permId: int = 0
parentId: int = 0
lastFillPrice: float = 0.0
clientId: int = 0
whyHeld: str = ''
mktCapPrice: float = 0.0
PendingSubmit: ClassVar[str] = 'PendingSubmit'
PendingCancel: ClassVar[str] = 'PendingCancel'
PreSubmitted: ClassVar[str] = 'PreSubmitted'
Submitted: ClassVar[str] = 'Submitted'
ApiPending: ClassVar[str] = 'ApiPending'
ApiCancelled: ClassVar[str] = 'ApiCancelled'
Cancelled: ClassVar[str] = 'Cancelled'
Filled: ClassVar[str] = 'Filled'
Inactive: ClassVar[str] = 'Inactive'
DoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}
ActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',
'Submitted'}

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',
equityWithLoanBefore: str = '', initMarginChange: str = '',
maintMarginChange: str = '', equityWithLoanChange: str = '',
initMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:
str = '', commission: float = 1.7976931348623157e+308,
minCommission: float = 1.7976931348623157e+308, maxCommission:
float = 1.7976931348623157e+308, commissionCurrency: str = '',
warningText: str = '', completedTime: str = '', completedStatus: str = '')

status: str = ''
initMarginBefore: str = ''
maintMarginBefore: str = ''
equityWithLoanBefore: str = ''
initMarginChange: str = ''
maintMarginChange: str = ''
equityWithLoanChange: str = ''
initMarginAfter: str = ''
maintMarginAfter: str = ''
equityWithLoanAfter: str = ''
commission: float = 1.7976931348623157e+308
minCommission: float = 1.7976931348623157e+308
maxCommission: float = 1.7976931348623157e+308
commissionCurrency: str = ''
warningText: str = ''
completedTime: str = ''
completedStatus: str = ''
dict()

Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)

price: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:
~ib_insync.order.Order = <factory>, orderStatus:
~ib_insync.order.OrderStatus = <factory>, fills:
~typing.List[~ib_insync.objects.Fill] = <factory>, log:
~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:
str = '')
Trade keeps track of an order, its status and all its fills.
Events:
-statusEvent (trade: Trade)
-modifyEvent (trade: Trade)
-fillEvent (trade: Trade, fill: Fill)
-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)
-filledEvent (trade: Trade)
-cancelEvent (trade: Trade)
-cancelledEvent (trade: Trade)
events: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',
'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')
contract: Contract
order: Order
orderStatus: OrderStatus
fills: List[Fill]
log: List[TradeLogEntry]
advancedError: str = ''
isActive()
True if eligible for execution, false otherwise.
isDone()
True if completely filled or cancelled, false otherwise.
filled()
Number of shares filled.
remaining()
Number of shares remaining to be filled.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)
Create new instance of BracketOrder(parent, takeProfit, stopLoss)
property parent
property takeProfit
property stopLoss

#### class ib_insync.order.OrderCondition
static createClass(condType)
And()
Or()

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,
price: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =
0)
condType: int = 1
conjunction: str = 'a'
isMore: bool = True
price: float = 0.0
conId: int = 0
exch: str = ''
triggerMethod: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:
str = '')
condType: int = 3
conjunction: str = 'a'
isMore: bool = True
time: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,
percent: int = 0)
condType: int = 4
conjunction: str = 'a'
isMore: bool = True
percent: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',
exch: str = '', symbol: str = '')
condType: int = 5
conjunction: str = 'a'
secType: str = ''
exch: str = ''
symbol: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,
volume: int = 0, conId: int = 0, exch: str = '')
condType: int = 6
conjunction: str = 'a'
isMore: bool = True
volume: int = 0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =
True, changePercent: float = 0.0, conId: int = 0, exch: str
= '')
condType: int = 7
conjunction: str = 'a'
isMore: bool = True
changePercent: float = 0.0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

onDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
```

> **Note:** Single example, no duplicates found

### 
Contract

```python
Financial instrument types used by Interactive Brokers

class ib_insync.contract.Contract(secType: str = '', conId: int = 0, symbol: str = '',
lastTradeDateOrContractMonth: str = '', strike: float = 0.0, right: str =
'', multiplier: str = '', exchange: str = '', primaryExchange: str = '',
currency: str = '', localSymbol: str = '', tradingClass: str = '',
includeExpired: bool = False, secIdType: str = '', secId: str = '',
description: str = '', issuerId: str = '', comboLegsDescrip: str = '',
comboLegs: ~typing.List[~ib_insync.contract.ComboLeg] = <factory>,
deltaNeutralContract:
~typing.Optional[~ib_insync.contract.DeltaNeutralContract] = None)
Contract(**kwargs) can create any contract using keyword arguments. To simplify working with contracts,
there are also more specialized contracts that take optional positional arguments. Some examples:


Contract(conId=270639)
Stock('AMD', 'SMART', 'USD')
Stock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')
Forex('EURUSD')
CFD('IBUS30')
Future('ES', '20180921', 'CME')
Option('SPY', '20170721', 240, 'C', 'SMART')
Bond(secIdType='ISIN', secId='US03076KAA60')
Crypto('BTC', 'PAXOS', 'USD')

Parameters
-conId (int) -The unique IB contract identifier.
-symbol (str) -The contract (or its underlying) symbol.
-secType (str) -The security type:
– ’STK’ = Stock (or ETF)
– ’OPT’ = Option
– ’FUT’ = Future
– ’IND’ = Index
– ’FOP’ = Futures option
– ’CASH’ = Forex pair
– ’CFD’ = CFD
– ’BAG’ = Combo
– ’WAR’ = Warrant
– ’BOND’ = Bond
– ’CMDTY’ = Commodity
– ’NEWS’ = News
– ’FUND’ = Mutual fund
– ’CRYPTO’ = Crypto currency
-lastTradeDateOrContractMonth (str) -The contract’s last trading day or contract
month (for Options and Futures). Strings with format YYYYMM will be interpreted as
the Contract Month whereas YYYYMMDD will be interpreted as Last Trading Day.
-strike (float) -The option’s strike price.
-right (str) -Put or Call. Valid values are ‘P’, ‘PUT’, ‘C’, ‘CALL’, or ‘’ for non-options.
-multiplier (str) -he instrument’s multiplier (i.e. options, futures).
-exchange (str) -The destination exchange.
-currency (str) -The underlying’s currency.
-localSymbol (str) -The contract’s symbol within its primary exchange. For options, this
will be the OCC symbol.
-primaryExchange (str) -The contract’s primary exchange. For smart routed contracts,
used to define contract in case of ambiguity. Should be defined as native exchange of contract,
e.g. ISLAND for MSFT. For exchanges which contain a period in name, will only be part of
exchange name prior to period, i.e. ENEXT for ENEXT.BE.
-tradingClass (str) -The trading class name for this contract. Available in TWS contract
description window as well. For example, GBL Dec ‘13 future’s trading class is “FGBL”.
-includeExpired (bool) -If set to true, contract details requests and historical data queries
can be performed pertaining to expired futures contracts. Expired options or other instrument
types are not available.
-secIdType (str) -Security identifier type. Examples for Apple:
– secIdType=’ISIN’, secId=’US0378331005’
– secIdType=’CUSIP’, secId=’037833100’
-secId (str) -Security identifier.
-comboLegsDescription (str) -Description of the combo legs.
-comboLegs (List[ComboLeg]) -The legs of a combined contract definition.
-deltaNeutralContract (DeltaNeutralContract) -Delta and underlying price for
Delta-Neutral combo orders.
secType: str = ''
conId: int = 0
symbol: str = ''
lastTradeDateOrContractMonth: str = ''
strike: float = 0.0
right: str = ''
multiplier: str = ''
exchange: str = ''
primaryExchange: str = ''
currency: str = ''
localSymbol: str = ''
tradingClass: str = ''
includeExpired: bool = False
secIdType: str = ''
secId: str = ''
description: str = ''
issuerId: str = ''
comboLegsDescrip: str = ''
comboLegs: List[ComboLeg]
deltaNeutralContract: Optional[DeltaNeutralContract] = None

static create(**kwargs)
Create and a return a specialized contract based on the given secType, or a general Contract if secType is
not given.
Return type
Contract

isHashable()
See if this contract can be hashed by conId.
Note: Bag contracts always get conId=28812380, so they’re not hashable.
Return type
bool

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.contract.Stock(symbol='', exchange='', currency='', **kwargs)
Stock contract.
Parameters
-symbol (str) -Symbol name.
-exchange (str) -Destination exchange.
-currency (str) -Underlying currency.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
comboLegs: List[ComboLeg]

#### class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',
exchange='', multiplier='', currency='', **kwargs)
Option contract.
Parameters
-symbol (str) -Symbol name.
-lastTradeDateOrContractMonth (str) -The option’s last trading day or contract month.
– YYYYMM format: To specify last month
– YYYYMMDD format: To specify last trading day
-strike (float) -The option’s strike price.
-right (str) -Put or call option. Valid values are ‘P’, ‘PUT’, ‘C’ or ‘CALL’.
-exchange (str) -Destination exchange.
-multiplier (str) -The contract multiplier.
-currency (str) -Underlying currency.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
Return type
object

comboLegs: List[ComboLeg]
```

> **Note:** Single example, no duplicates found

### 
Future

```python
#### class ib_insync.contract.Future(symbol='', lastTradeDateOrContractMonth='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)

Future contract.

**Parameters:**
- **symbol** (str) - Symbol name.
- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.
  - YYYYMM format: To specify last month
  - YYYYMMDD format: To specify last trading day
- **exchange** (str) - Destination exchange.
- **localSymbol** (str) - The contract's symbol within its primary exchange.
- **multiplier** (str) - The contract multiplier.
- **currency** (str) - Underlying currency.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type: dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type: dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type: tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
Return type: object

comboLegs: List[ComboLeg]


#### class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)
Continuous future contract.
**Parameters:**
- **symbol** (str) - Symbol name.
- **exchange** (str) - Destination exchange.
- **localSymbol** (str) - The contract's symbol within its primary exchange.
- **multiplier** (str) - The contract multiplier.
- **currency** (str) - Underlying currency.
 dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type: dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type:dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type: tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
*Return type: object

comboLegs: List[ComboLeg]
```

> **Note:** Single example, no duplicates found

### Represents financial contracts for various asset types including Forex, Index, CFD, Commodity, and Crypto. Common parameters include 'symbol' (asset identifier), 'exchange' (destination exchange), and 'currency' (underlying currency). Forex contracts additionally use 'pair' as a shortcut for symbol/currency (e.g., 'EURUSD'). All contracts inherit methods to convert to dict/tuple, track non-default fields, update attributes, and manage combo legs. Forex includes a dedicated pair() method to return the currency pair name.

```python
class ib_insync.contract.Forex(pair='', exchange='IDEALPRO', symbol='', currency='', **kwargs)

Foreign exchange currency pair.

**Parameters:**
- **pair** (str) - Shortcut for specifying symbol and currency, like 'EURUSD'.
- **exchange** (str) - Destination exchange.
- **symbol** (str) - Base currency.
- **currency** (str) - Quote currency.

pair()
Short name of pair.
Return type: str

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type: dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type: dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type: tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
Return type: object

comboLegs: List[ComboLeg]
```

> **Note:** Key variations:
1. Forex uses 'pair' parameter and pair() method; others use 'symbol'.
2. Default exchange differs (Forex: 'IDEALPRO'; others: empty).
3. All other classes (Index, CFD, Commodity, Crypto) share identical structures except parameter names.

### Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds).

```python
class ib_insync.contract.ContractType(**kwargs)
    [Contract Type Description]

    dict()
        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
        Return type: dict

    nonDefaults()
        For a dataclass instance get the fields that are different from the default values and return as dict.
        Return type: dict

    tuple()
        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
        Return type: tuple

    update(*srcObjs, **kwargs)
        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
        Return type: object

    comboLegs: List[ComboLeg]
```

> **Note:** Variations occur only in contract-specific descriptions: Bond = 'Bond.', MutualFund = 'Mutual fund.', Warrant = 'Warrant option.', Bag = 'Bag contract.'. Method implementations and comboLegs attribute are identical across all contract types. Minor formatting differences exist in source docs (asterisks/spacing) but don't affect functionality.

### 
FuturesOption

```python
class ib_insync.contract.FuturesOption(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='', exchange='', multiplier='', currency='', **kwargs)

Option on a futures contract.

**Parameters:**
- **symbol** (str) - Symbol name.
- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.
  - YYYYMM format: To specify last month
  - YYYYMMDD format: To specify last trading day
- **strike** (float) - The option's strike price.
- **right** (str) - Put or call option. Valid values are 'P', 'PUT', 'C' or 'CALL'.
- **exchange** (str) - Destination exchange.
- **multiplier** (str) - The contract multiplier.
- **currency** (str) - Underlying currency.

 dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type:** dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type: dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type: tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
Return type: object

comboLegs: List[ComboLeg]
```

> **Note:** Single example, no duplicates found

### 
 TagValue

```python
class ib_insync.contract.TagValue(tag, value)

Create new instance of TagValue(tag, value)
```

> **Note:** Single example, no duplicates found

###  Fetching consecutive historical data

```python
import datetime
from ib_insync import *
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
contract = Stock('TSLA', 'SMART', 'USD')
dt = ''
barsList = []
while True:
bars = ib.reqHistoricalData(
contract,
endDateTime=dt,
durationStr='10 D',
barSizeSetting='1 min',
whatToShow='MIDPOINT',
useRTH=True,
formatDate=1)
if not bars:
break
barsList.append(bars)
dt = bars[0].date
print(dt)
# save to CSV file
allBars = [b for bars in reversed(barsList) for b in bars]
df = util.df(allBars)
df.to_csv(contract.symbol + '.csv', index=False)
```

> **Note:** Single example, no duplicates found

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.

###  Option calculations

```python
option = Option('EOE', '20171215', 490, 'P', 'FTA', multiplier=100)
calc = ib.calculateImpliedVolatility(
option, optionPrice=6.1, underPrice=525)
print(calc)
calc = ib.calculateOptionPrice(
option, volatility=0.14, underPrice=525)
print(calc)
```

> **Note:** Single example, no duplicates found

###  Minimum price increments

```python
usdjpy = Forex('USDJPY')
cd = ib.reqContractDetails(usdjpy)[0]
print(cd.marketRuleIds)
rules = [
ib.reqMarketRule(ruleId)
for ruleId in cd.marketRuleIds.split(',')]
print(rules)
```

> **Note:** Single example, no duplicates found

###  News articles

```python
newsProviders = ib.reqNewsProviders()
print(newsProviders)
codes = '+'.join(np.code for np in newsProviders)
amd = Stock('AMD', 'SMART', 'USD')
ib.qualifyContracts(amd)
headlines = ib.reqHistoricalNews(amd.conId, codes, '', '', 10)
latest = headlines[0]
print(latest)
article = ib.reqNewsArticle(latest.providerCode, latest.articleId)
print(article
```

> **Note:** Single example, no duplicates found

###  Dividends

```python
contract = Stock('INTC', 'SMART', 'USD')
ticker = ib.reqMktData(contract, '456')
ib.sleep(2)
print(ticker.dividends)
Output:
Dividends(past12Months=1.2, next12Months=1.2, nextDate=datetime.date(2019, 2, 6),␣
nextAmount=0.3)
```

> **Note:** Single example, no duplicates found

###  Fundamental ratios

```python
contract = Stock('IBM', 'SMART', 'USD')
ticker = ib.reqMktData(contract, '258')
ib.sleep(2)
print(ticker.fundamentalRatios)
```

> **Note:** Single example, no duplicates found

###  Integration with Tkinter

```python
class TkApp:
    """
    Example of integrating with Tkinter.
    """
    def __init__(self):
        self.ib = IB().connect()
        self.root = tk.Tk()
        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)
        self.entry = tk.Entry(self.root, width=50)
        self.entry.insert(0, "Stock('TSLA', 'SMART', 'USD')")
        self.entry.grid()
        self.button = tk.Button(
            self.root, text='Get details', command=self.onButtonClick)
        self.button.grid()
        self.text = tk.Text(self.root)
        self.text.grid()
        self.loop = util.getLoop()

    def onButtonClick(self):
        contract = eval(self.entry.get())
        cds = self.ib.reqContractDetails(contract)
        self.text.delete(1.0, tk.END)
        self.text.insert(tk.END, str(cds))

    def run(self):
        self._onTimeout()
        self.loop.run_forever()

    def _onTimeout(self):
        self.root.update()
        self.loop.call_later(0.03, self._onTimeout)

    def _onDeleteWindow(self):
        self.loop.stop()


app = TkApp()
app.run()
```

> **Note:** Single example, no duplicates found

###  Price-Based Condition

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Order triggers when SPY hits 450
contract = Stock('AAPL', 'SMART', 'USD')
trigger_contract = Stock('SPY', 'SMART', 'USD')

# Qualify both
contract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)

# Create price condition
condition = PriceCondition(
    condType=1,  # Price
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,  # True = above, False = below
    price=450.0
)

# Create order with condition
order = LimitOrder('BUY', 100, 175.0)
order.conditions = [condition]
order.conditionsIgnoreRth = False
order.conditionsCancelOrder = False

trade = ib.placeOrder(contract, order)
print(f"Conditional order placed: {trade.order.orderId}")
```

> **Note:** Single example, no duplicates found

###  Time-Based Condition

```python
from datetime import datetime, timedelta

# Order triggers at specific time
time_condition = TimeCondition(
    condType=3,  # Time
    isMore=True,
    time=datetime.now() + timedelta(hours=1)
)

order = MarketOrder('BUY', 100)
order.conditions = [time_condition]
trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Volume-Based Condition

```python
# Trigger when daily volume exceeds threshold
volume_condition = VolumeCondition(
    condType=4,  # Volume
    conId=contract.conId,
    exchange='SMART',
    isMore=True,
    volume=10000000  # 10M shares
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [volume_condition]
trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Multiple Conditions (AND/OR)

```python
# Order triggers when BOTH conditions met
price_cond = PriceCondition(
    condType=1,
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,
    price=450.0
)

volume_cond = VolumeCondition(
    condType=4,
    conId=contract.conId,
    exchange='SMART',
    isMore=True,
    volume=5000000
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [price_cond, volume_cond]
order.conditionsIgnoreRth = False
order.conditionsCancelOrder = False  # False = AND, True = OR

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Places advanced order types in Interactive Brokers API. Covers:
1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount
2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)
3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging
4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging
5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO
Common parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.

```python
order = Order()
order.action = 'BUY'  # or 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL
# For TRAIL: set auxPrice (fixed trail amount)
# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent
# For PEG MID/PEG BEST: no additional price fields
# For REL: set lmtPrice (offset from NBBO)
order.tif = 'GTC'  # or other time in force

trade = ib.placeOrder(contract, order)
```

> **Note:** Key variations:
- TRAIL requires auxPrice (fixed $ trail)
- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)
- PEG MID/PEG BEST require no price parameters
- REL uses lmtPrice for NBBO offset
- Action (BUY/SELL) varies by use case
- All examples use GTC time-in-force but other values are possible

###  Multiple Exits from Same Entry

```python
# Buy at market, then set multiple exit strategies
entry_order = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry_order)

# Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    # Create OCA group for exits
    oca_group = f"OCA_{int(time.time())}"
    
    # Exit 1: Take profit at +5%
    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)
    exit1.ocaGroup = oca_group
    exit1.ocaType = 1  # Cancel all on fill
    
    # Exit 2: Stop loss at -2%
    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)
    exit2.ocaGroup = oca_group
    exit2.ocaType = 1
    
    # Exit 3: Trailing stop
    exit3 = Order()
    exit3.action = 'SELL'
    exit3.totalQuantity = 100
    exit3.orderType = 'TRAIL'
    exit3.trailingPercent = 3.0
    exit3.ocaGroup = oca_group
    exit3.ocaType = 1
    
    for order in [exit1, exit2, exit3]:
        ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  VWAP (Volume-Weighted Average Price)

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 10000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'

order.algoStrategy = 'Vwap'
order.algoParams = [
    TagValue('maxPctVol', '0.1'),  # Max 10% of volume
    TagValue('startTime', '09:30:00 EST'),
    TagValue('endTime', '16:00:00 EST'),
    TagValue('allowPastEndTime', '1'),
    TagValue('noTakeLiq', '1')
]

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Adaptive (IB's Smart Routing)

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 1000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'

order.algoStrategy = 'Adaptive'
order.algoParams = [
    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient
]

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Vertical Spread (Bull Call Spread)

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Define legs
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')

# Qualify
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

# Create combo contract
combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

# Define legs
leg1 = ComboLeg()
leg1.conId = buy_call.conId
leg1.ratio = 1
leg1.action = 'BUY'
leg1.exchange = 'SMART'

leg2 = ComboLeg()
leg2.conId = sell_call.conId
leg2.ratio = 1
leg2.action = 'SELL'
leg2.exchange = 'SMART'

combo.comboLegs = [leg1, leg2]

# Place order
order = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50
trade = ib.placeOrder(combo, order)
```

> **Note:** Single example, no duplicates found

###  Iron Condor

```python
# Four-leg strategy: sell OTM call spread + sell OTM put spread
buy_call = Option('SPY', '20240315', 470, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 465, 'C', 'SMART')
buy_put = Option('SPY', '20240315', 430, 'P', 'SMART')
sell_put = Option('SPY', '20240315', 435, 'P', 'SMART')

# Qualify all
contracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)

# Create BAG
combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call
    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call
    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put
    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put
]

# Place as credit spread
order = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit
trade = ib.placeOrder(combo, order)
```

> **Note:** JSON parse failed. Raw response: {
  "canonical_code": "```python\n# Four-leg strategy: sell OTM call spread + sell OTM put spread\nb...

###  Delta Hedging Pattern

```python
# Dynamic delta hedging for options position
def calculate_position_delta(portfolio):
    """Calculate total portfolio delta"""
    total_delta = 0.0
    
    for item in portfolio:
        if item.contract.secType == 'OPT':
            # Request option computations
            ticker = ib.reqMktData(item.contract, '', False, False)
            ib.sleep(1)
            
            if ticker.modelGreeks:
                delta = ticker.modelGreeks.delta
                total_delta += delta * item.position
            
            ib.cancelMktData(item.contract)
    
    return total_delta

def hedge_delta(underlying_contract, target_delta=0.0):
    """Adjust underlying position to achieve target delta"""
    portfolio = ib.portfolio()
    current_delta = calculate_position_delta(portfolio)
    
    delta_to_hedge = current_delta - target_delta
    
    if abs(delta_to_hedge) > 0.1:  # Threshold
        # Delta of stock is 1.0
        shares_to_trade = int(delta_to_hedge * 100)  # Per contract
        
        if shares_to_trade > 0:
            order = MarketOrder('SELL', abs(shares_to_trade))
        else:
            order = MarketOrder('BUY', abs(shares_to_trade))
        
        trade = ib.placeOrder(underlying_contract, order)
        print(f"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}")
        
        return trade
    else:
        print(f"Delta within tolerance: {current_delta:.2f}")
        return None

# Run periodically
underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

while True:
    hedge_delta(underlying, target_delta=0.0)
    ib.sleep(300)  # Every 5 minutes
```

> **Note:** Single example, no duplicates found

###  Comprehensive Error Handler

```python
from ib_insync import *
import logging

class IBErrorHandler:
    def __init__(self, ib):
        self.ib = ib
        self.error_log = []
        self.ib.errorEvent += self.on_error
        
    def on_error(self, reqId, errorCode, errorString, contract):
        """Centralized error handling"""
        error_info = {
            'time': datetime.now(),
            'reqId': reqId,
            'code': errorCode,
            'message': errorString,
            'contract': contract
        }
        self.error_log.append(error_info)
        
        # Categorize and handle
        if errorCode in [502, 503, 504]:
            self.handle_connection_error(errorCode, errorString)
        elif errorCode in [200, 201, 202]:
            self.handle_order_error(errorCode, errorString, contract)
        elif errorCode == 162:
            self.handle_data_error(errorCode, errorString, contract)
        elif errorCode == 354:
            self.handle_market_data_subscription_error(errorCode, errorString)
        elif errorCode in [2104, 2106, 2158]:
            # Info messages - ignore
            pass
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def handle_connection_error(self, code, message):
        """Handle connection failures"""
        logging.critical(f"Connection error {code}: {message}")
        # Trigger reconnection
        self.schedule_reconnect()
    
    def handle_order_error(self, code, message, contract):
        """Handle order rejections"""
        logging.error(f"Order error {code}: {message} for {contract}")
        # Could retry with modified params
        # Or alert user
    
    def handle_data_error(self, code, message, contract):
        """Handle data request failures"""
        logging.warning(f"Data error {code}: {message} for {contract}")
        # Retry with different params
    
    def handle_market_data_subscription_error(self, code, message):
        """Handle market data subscription issues"""
        logging.warning(f"Market data error {code}: {message}")
        # Fall back to delayed data
        self.ib.reqMarketDataType(3)  # Delayed
    
    def schedule_reconnect(self):
        """Schedule reconnection attempt"""
        # Implementation in reconnection section
        pass

# Usage
ib = IB()
error_handler = IBErrorHandler(ib)
ib.connect('127.0.0.1', 7497, clientId=1)
```

> **Note:** Single example, no duplicates found

###  Order Validation Before Submission

```python
def validate_order(ib, contract, order):
    """Validate order before placing"""
    errors = []
    
    # 1. Check contract is qualified
    if contract.conId == 0:
        errors.append("Contract not qualified")
    
    # 2. Check buying power
    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}
    
    if order.action == 'BUY':
        # Estimate cost
        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot
        ib.sleep(1)
        
        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN
            estimated_cost = ticker.ask * order.totalQuantity
            if estimated_cost > account_values.get('BuyingPower', 0):
                errors.append(f"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}")
        
        ib.cancelMktData(contract)
    
    # 3. What-if order check
    try:
        order_copy = Order(**{k: v for k, v in order.__dict__.items()})
        order_copy.whatIf = True
        
        orderState = ib.whatIfOrder(contract, order_copy)
        
        if orderState.commission and orderState.commission > 0:
            # Valid response
            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):
                errors.append("Insufficient margin")
        else:
            errors.append("What-if order returned invalid state")
            
    except Exception as e:
        errors.append(f"What-if validation failed: {e}")
    
    # 4. Check trading hours
    details = ib.reqContractDetails(contract)
    if details:
        # Parse trading hours (simplified)
        # Would need full implementation
        pass
    
    return errors

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
order = LimitOrder('BUY', 1000, 175.0)

validation_errors = validate_order(ib, contract, order)
if validation_errors:
    print("Order validation failed:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    trade = ib.placeOrder(contract, order)
    print("Order placed successfully")
```

> **Note:** Single example, no duplicates found

###  Retry Logic with Exponential Backoff

```python
import time
from functools import wraps

def retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):
    """Decorator for retrying failed operations"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            delay = base_delay
            
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    retries += 1
                    if retries >= max_retries:
                        logging.error(f"{func.__name__} failed after {max_retries} retries: {e}")
                        raise
                    
                    logging.warning(f"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...")
                    time.sleep(delay)
                    delay = min(delay * 2, max_delay)  # Exponential backoff
            
        return wrapper
    return decorator

# Usage
@retry_with_backoff(max_retries=3, base_delay=2.0)
def place_order_with_retry(ib, contract, order):
    """Place order with automatic retry"""
    trade = ib.placeOrder(contract, order)
    
    # Wait for submission
    timeout = 10
    start = time.time()
    while trade.orderStatus.status in ['PendingSubmit', '']:
        if time.time() - start > timeout:
            raise TimeoutError("Order submission timeout")
        ib.sleep(0.1)
    
    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:
        raise Exception(f"Order cancelled: {trade.orderStatus.status}")
    
    return trade

# Usage
try:
    trade = place_order_with_retry(ib, contract, order)
    print(f"Order placed: {trade.order.orderId}")
except Exception as e:
    print(f"Order failed: {e}")
```

> **Note:** Single example, no duplicates found

###  Position Reconciliation

```python
class PositionManager:
    def __init__(self, ib):
        self.ib = ib
        self.expected_positions = {}  # conId -> quantity
        
    def record_trade(self, trade):
        """Record expected position change"""
        if trade.orderStatus.status == 'Filled':
            conId = trade.contract.conId
            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()
            
            if conId in self.expected_positions:
                self.expected_positions[conId] += qty
            else:
                self.expected_positions[conId] = qty
    
    def reconcile(self):
        """Check actual vs expected positions"""
        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}
        
        discrepancies = []
        
        # Check expected positions
        for conId, expected_qty in self.expected_positions.items():
            actual_qty = actual_positions.get(conId, 0)
            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding
                discrepancies.append({
                    'conId': conId,
                    'expected': expected_qty,
                    'actual': actual_qty,
                    'diff': actual_qty - expected_qty
                })
        
        # Check for unexpected positions
        for conId, actual_qty in actual_positions.items():
            if conId not in self.expected_positions and abs(actual_qty) > 0.01:
                discrepancies.append({
                    'conId': conId,
                    'expected': 0,
                    'actual': actual_qty,
                    'diff': actual_qty
                })
        
        if discrepancies:
            logging.warning(f"Position discrepancies found: {discrepancies}")
        
        return discrepancies
    
    def reset_tracking(self):
        """Reset to current positions"""
        self.expected_positions = {
            p.contract.conId: p.position 
            for p in self.ib.positions()
        }

# Usage
pm = PositionManager(ib)
pm.reset_tracking()

# Track trades
ib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)

# Periodic reconciliation
while True:
    discrepancies = pm.reconcile()
    if discrepancies:
        # Alert or take action
        pass
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Close All Positions

```python
def close_all_positions(ib, exclude_symbols=None):
    """Emergency position closer"""
    exclude_symbols = exclude_symbols or []
    
    positions = ib.positions()
    trades = []
    
    for position in positions:
        symbol = position.contract.symbol
        
        if symbol in exclude_symbols:
            continue
        
        qty = abs(position.position)
        action = 'SELL' if position.position > 0 else 'BUY'
        
        order = MarketOrder(action, qty)
        trade = ib.placeOrder(position.contract, order)
        trades.append(trade)
        
        print(f"Closing {action} {qty} {symbol}")
    
    # Wait for all to fill
    timeout = 30
    start = time.time()
    
    while any(not t.isDone() for t in trades):
        if time.time() - start > timeout:
            logging.error("Timeout waiting for position closures")
            break
        ib.sleep(0.5)
    
    return trades

# Usage - emergency exit
if emergency_condition:
    close_all_positions(ib)
```

> **Note:** Single example, no duplicates found

###  Position Size Calculator

```python
def calculate_position_size(
    ib,
    contract,
    risk_per_trade_pct=0.02,  # 2% risk
    stop_loss_pct=0.05         # 5% stop
):
    """Calculate position size based on risk"""
    
    # Get account value
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    # Calculate dollar risk
    dollar_risk = net_liq * risk_per_trade_pct
    
    # Get current price
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if not ticker.last or ticker.last != ticker.last:  # NaN check
        logging.error("Unable to get price for position sizing")
        return 0
    
    price = ticker.last
    ib.cancelMktData(contract)
    
    # Calculate shares
    # dollar_risk = shares * price * stop_loss_pct
    shares = dollar_risk / (price * stop_loss_pct)
    
    # Round to nearest tradeable lot
    if contract.secType == 'OPT':
        shares = int(shares / 100) * 100  # Options in contracts (100 shares)
    else:
        shares = int(shares)
    
    print(f"Position size for {contract.symbol}: {shares} shares")
    print(f"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})")
    
    return shares

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

shares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)

if shares > 0:
    order = LimitOrder('BUY', shares, 175.0)
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Max Position Concentration

```python
def check_position_concentration(ib, max_position_pct=0.20):
    """Ensure no single position exceeds % of portfolio"""
    
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    violations = []
    
    for item in ib.portfolio():
        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0
        
        if position_pct > max_position_pct:
            violations.append({
                'symbol': item.contract.symbol,
                'value': item.marketValue,
                'pct': position_pct,
                'limit': max_position_pct
            })
    
    if violations:
        logging.warning(f"Position concentration violations: {violations}")
    
    return violations

# Check before placing order
def place_order_with_concentration_check(ib, contract, order, max_pct=0.20):
    """Place order only if it doesn't violate concentration"""
    
    # Estimate new position value
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if ticker.ask:
        estimated_value = ticker.ask * order.totalQuantity
        
        account_values = {v.tag: float(v.value) for v in ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        # Get current position
        current_position = next(
            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),
            0
        )
        
        new_position_value = abs(current_position + estimated_value)
        new_pct = new_position_value / net_liq if net_liq > 0 else 0
        
        if new_pct > max_pct:
            logging.error(f"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%")
            ib.cancelMktData(contract)
            return None
    
    ib.cancelMktData(contract)
    return ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Correlation-Based Risk

```python
import numpy as np
import pandas as pd

def calculate_portfolio_correlation_risk(ib, lookback_days=30):
    """Calculate portfolio correlation matrix"""
    
    portfolio = ib.portfolio()
    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']
    
    # Get historical data for all positions
    price_data = {}
    
    for symbol in symbols:
        contract = Stock(symbol, 'SMART', 'USD')
        contract = ib.qualifyContracts(contract)[0]
        
        bars = ib.reqHistoricalData(
            contract,
            endDateTime='',
            durationStr=f'{lookback_days} D',
            barSizeSetting='1 day',
            whatToShow='TRADES',
            useRTH=True
        )
        
        if bars:
            price_data[symbol] = [bar.close for bar in bars]
    
    # Create DataFrame
    df = pd.DataFrame(price_data)
    
    # Calculate returns
    returns = df.pct_change().dropna()
    
    # Correlation matrix
    corr_matrix = returns.corr()
    
    # Identify highly correlated pairs
    high_corr_threshold = 0.7
    high_corr_pairs = []
    
    for i in range(len(corr_matrix.columns)):
        for j in range(i+1, len(corr_matrix.columns)):
            corr = corr_matrix.iloc[i, j]
            if abs(corr) > high_corr_threshold:
                high_corr_pairs.append({
                    'symbol1': corr_matrix.columns[i],
                    'symbol2': corr_matrix.columns[j],
                    'correlation': corr
                })
    
    if high_corr_pairs:
        logging.warning(f"High correlation detected: {high_corr_pairs}")
    
    return corr_matrix, high_corr_pairs

# Usage
corr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)
print("Portfolio Correlation Matrix:")
print(corr_matrix)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Target Allocation Rebalancer

```python
class PortfolioRebalancer:
    def __init__(self, ib):
        self.ib = ib
        
    def rebalance_to_target(self, target_allocations, tolerance=0.05):
        """
        Rebalance portfolio to target allocations
        
        Args:
            target_allocations: Dict[symbol: str, target_pct: float]
                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}
            tolerance: Rebalance threshold (0.05 = 5%)
        """
        
        # Validate target allocations
        total = sum(target_allocations.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Target allocations must sum to 1.0, got {total}")
        
        # Get current portfolio
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}
        
        # Calculate current allocations
        current_allocations = {
            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)
            for symbol, item in portfolio.items()
        }
        
        # Determine needed trades
        trades_needed = []
        
        for symbol, target_pct in target_allocations.items():
            current_pct = current_allocations.get(symbol, 0)
            diff = target_pct - current_pct
            
            if abs(diff) > tolerance:
                target_value = net_liq * target_pct
                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0
                value_change = target_value - current_value
                
                # Get current price
                contract = Stock(symbol, 'SMART', 'USD')
                contract = self.ib.qualifyContracts(contract)[0]
                
                ticker = self.ib.reqMktData(contract, '', True, False)
                self.ib.sleep(1)
                
                if ticker.last and ticker.last == ticker.last:
                    price = ticker.last
                    shares_change = int(value_change / price)
                    
                    if shares_change != 0:
                        trades_needed.append({
                            'symbol': symbol,
                            'contract': contract,
                            'current_pct': current_pct,
                            'target_pct': target_pct,
                            'shares': shares_change,
                            'action': 'BUY' if shares_change > 0 else 'SELL'
                        })
                
                self.ib.cancelMktData(contract)
        
        # Execute trades
        if not trades_needed:
            logging.info("Portfolio within tolerance. No rebalancing needed.")
            return []
        
        logging.info(f"Rebalancing {len(trades_needed)} positions...")
        placed_trades = []
        
        for trade_info in trades_needed:
            logging.info(f"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} "
                        f"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)")
            
            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))
            trade = self.ib.placeOrder(trade_info['contract'], order)
            placed_trades.append(trade)
        
        return placed_trades

# Usage
target = {
    'AAPL': 0.30,
    'GOOGL': 0.30,
    'MSFT': 0.40
}

rebalancer = PortfolioRebalancer(ib)
trades = rebalancer.rebalance_to_target(target, tolerance=0.03)

# Monitor fills
for trade in trades:
    while not trade.isDone():
        ib.sleep(1)
    print(f"{trade.contract.symbol}: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Dollar-Cost Averaging

```python
class DCAScheduler:
    def __init__(self, ib):
        self.ib = ib
        self.schedules = []
        
    def add_schedule(self, symbol, amount_per_period, frequency_days):
        """
        Add DCA schedule
        
        Args:
            symbol: Stock symbol
            amount_per_period: Dollar amount to invest
            frequency_days: Days between purchases
        """
        self.schedules.append({
            'symbol': symbol,
            'amount': amount_per_period,
            'frequency': frequency_days,
            'last_purchase': None
        })
    
    def check_and_execute(self):
        """Check if any DCA purchases are due"""
        from datetime import datetime, timedelta
        
        now = datetime.now()
        
        for schedule in self.schedules:
            last = schedule['last_purchase']
            
            # Check if purchase is due
            if last is None or (now - last).days >= schedule['frequency']:
                self.execute_dca(schedule)
                schedule['last_purchase'] = now
    
    def execute_dca(self, schedule):
        """Execute DCA purchase"""
        symbol = schedule['symbol']
        amount = schedule['amount']
        
        # Create contract
        contract = Stock(symbol, 'SMART', 'USD')
        contract = self.ib.qualifyContracts(contract)[0]
        
        # Get current price
        ticker = self.ib.reqMktData(contract, '', True, False)
        self.ib.sleep(1)
        
        if ticker.last and ticker.last == ticker.last:
            price = ticker.last
            shares = int(amount / price)
            
            if shares > 0:
                logging.info(f"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})")
                order = MarketOrder('BUY', shares)
                trade = self.ib.placeOrder(contract, order)
                return trade
        
        self.ib.cancelMktData(contract)
        return None

# Usage
dca = DCAScheduler(ib)
dca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days
dca.add_schedule('VTI', 500, 14)   # $500 every 14 days

# Run daily check
while True:
    dca.check_and_execute()
    ib.sleep(86400)  # Check daily
```

> **Note:** Single example, no duplicates found

###  Tick-by-Tick with Filtering

```python
class TickFilter:
    def __init__(self, ib, contract, min_size=100):
        self.ib = ib
        self.contract = contract
        self.min_size = min_size
        self.large_trades = []
        
    def start(self):
        """Start tick-by-tick subscription with filtering"""
        self.ticker = self.ib.reqTickByTickData(
            self.contract,
            'AllLast',  # All trades
            0,
            False
        )
        self.ticker.updateEvent += self.on_tick
    
    def on_tick(self, ticker):
        """Filter and process ticks"""
        if not ticker.tickByTicks:
            return
        
        latest_tick = ticker.tickByTicks[-1]
        
        # Filter by size
        if latest_tick.size >= self.min_size:
            self.large_trades.append({
                'time': latest_tick.time,
                'price': latest_tick.price,
                'size': latest_tick.size
            })
            
            logging.info(f"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}")
    
    def stop(self):
        """Stop subscription"""
        self.ib.cancelTickByTickData(self.contract)
    
    def get_stats(self):
        """Get statistics on large trades"""
        if not self.large_trades:
            return None
        
        total_volume = sum(t['size'] for t in self.large_trades)
        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume
        
        return {
            'num_trades': len(self.large_trades),
            'total_volume': total_volume,
            'vwap': avg_price
        }

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

filter = TickFilter(ib, contract, min_size=1000)
filter.start()

# Run for period
ib.sleep(3600)  # 1 hour

filter.stop()
stats = filter.get_stats()
print(f"Large trades: {stats}")
```

> **Note:** Single example, no duplicates found

###  Volume Profile Builder

```python
class VolumeProfile:
    def __init__(self, ib, contract, num_bins=20):
        self.ib = ib
        self.contract = contract
        self.num_bins = num_bins
        self.profile = {}
        
    def build_from_historical(self, days=1):
        """Build volume profile from historical data"""
        bars = self.ib.reqHistoricalData(
            self.contract,
            endDateTime='',
            durationStr=f'{days} D',
            barSizeSetting='5 mins',
            whatToShow='TRADES',
            useRTH=True
        )
        
        if not bars:
            return None
        
        # Get price range
        prices = [bar.close for bar in bars]
        min_price = min(prices)
        max_price = max(prices)
        
        # Create bins
        bin_size = (max_price - min_price) / self.num_bins
        
        # Accumulate volume in bins
        for bar in bars:
            bin_idx = int((bar.close - min_price) / bin_size)
            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max
            
            bin_price = min_price + (bin_idx * bin_size)
            
            if bin_price not in self.profile:
                self.profile[bin_price] = 0
            
            self.profile[bin_price] += bar.volume
        
        return self.profile
    
    def get_poc(self):
        """Get Point of Control (price with highest volume)"""
        if not self.profile:
            return None
        
        return max(self.profile.items(), key=lambda x: x[1])
    
    def get_value_area(self, percent=0.70):
        """Get value area (prices containing X% of volume)"""
        if not self.profile:
            return None
        
        total_volume = sum(self.profile.values())
        target_volume = total_volume * percent
        
        # Sort by volume
        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)
        
        accumulated_volume = 0
        value_area_prices = []
        
        for price, volume in sorted_profile:
            accumulated_volume += volume
            value_area_prices.append(price)
            
            if accumulated_volume >= target_volume:
                break
        
        return min(value_area_prices), max(value_area_prices)

# Usage
contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

vp = VolumeProfile(ib, contract, num_bins=30)
profile = vp.build_from_historical(days=5)

poc_price, poc_volume = vp.get_poc()
print(f"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume")

va_low, va_high = vp.get_value_area(percent=0.70)
print(f"Value Area: ${va_low:.2f} - ${va_high:.2f}")
```

> **Note:** Single example, no duplicates found

###  Multi-Account Order Router

```python
class MultiAccountRouter:
    def __init__(self, host='127.0.0.1', port=7497):
        self.connections = {}
        self.host = host
        self.port = port
        
    def add_account(self, account_name, client_id):
        """Add account connection"""
        ib = IB()
        ib.connect(self.host, self.port, client_id)
        self.connections[account_name] = ib
        logging.info(f"Connected account {account_name} with clientId {client_id}")
    
    def place_order_all(self, contract, order_template, quantities):
        """
        Place orders across multiple accounts
        
        Args:
            contract: Contract to trade
            order_template: Base order
            quantities: Dict[account_name, quantity]
        """
        trades = {}
        
        for account_name, quantity in quantities.items():
            if account_name not in self.connections:
                logging.error(f"Account {account_name} not connected")
                continue
            
            ib = self.connections[account_name]
            
            # Clone order
            order = Order(**{k: v for k, v in order_template.__dict__.items()})
            order.totalQuantity = quantity
            order.account = account_name
            
            # Place order
            trade = ib.placeOrder(contract, order)
            trades[account_name] = trade
            
            logging.info(f"Placed {order.action} {quantity} {contract.symbol} for {account_name}")
        
        return trades
    
    def get_combined_portfolio(self):
        """Get combined portfolio across all accounts"""
        combined = {}
        
        for account_name, ib in self.connections.items():
            for item in ib.portfolio():
                symbol = item.contract.symbol
                
                if symbol not in combined:
                    combined[symbol] = {
                        'position': 0,
                        'market_value': 0,
                        'unrealized_pnl': 0,
                        'accounts': {}
                    }
                
                combined[symbol]['position'] += item.position
                combined[symbol]['market_value'] += item.marketValue
                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL
                combined[symbol]['accounts'][account_name] = item.position
        
        return combined
    
    def disconnect_all(self):
        """Disconnect all accounts"""
        for account_name, ib in self.connections.items():
            ib.disconnect()
            logging.info(f"Disconnected {account_name}")

# Usage
router = MultiAccountRouter()
router.add_account('Account1', client_id=1)
router.add_account('Account2', client_id=2)
router.add_account('Account3', client_id=3)

# Place order across all accounts
contract = Stock('AAPL', 'SMART', 'USD')
order_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account

quantities = {
    'Account1': 100,
    'Account2': 200,
    'Account3': 150
}

trades = router.place_order_all(contract, order_template, quantities)

# Monitor combined portfolio
combined = router.get_combined_portfolio()
for symbol, data in combined.items():
    print(f"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts")
```

> **Note:** Single example, no duplicates found

###  Batch Contract Qualification

```python
def qualify_contracts_batch(ib, contracts, batch_size=50):
    """Qualify contracts in batches to avoid rate limits"""
    qualified = []
    
    for i in range(0, len(contracts), batch_size):
        batch = contracts[i:i+batch_size]
        
        try:
            qualified_batch = ib.qualifyContracts(*batch)
            qualified.extend(qualified_batch)
        except Exception as e:
            logging.error(f"Batch qualification failed: {e}")
        
        # Respect rate limits
        ib.sleep(1)
    
    return qualified
```

> **Note:** Single example, no duplicates found

###  Request Queue Manager

```python
from collections import deque
import threading

class RequestQueue:
    def __init__(self, ib, max_per_second=40):
        self.ib = ib
        self.queue = deque()
        self.max_per_second = max_per_second
        self.running = False
        
    def add(self, func, *args, **kwargs):
        """Add request to queue"""
        self.queue.append((func, args, kwargs))
    
    def start(self):
        """Start processing queue"""
        self.running = True
        thread = threading.Thread(target=self._process)
        thread.daemon = True
        thread.start()
    
    def _process(self):
        """Process queue with rate limiting"""
        delay = 1.0 / self.max_per_second
        
        while self.running:
            if self.queue:
                func, args, kwargs = self.queue.popleft()
                
                try:
                    func(*args, **kwargs)
                except Exception as e:
                    logging.error(f"Request failed: {e}")
                
                time.sleep(delay)
            else:
                time.sleep(0.1)
    
    def stop(self):
        """Stop processing"""
        self.running = False

# Usage
queue = RequestQueue(ib, max_per_second=40)
queue.start()

# Queue many requests
for contract in large_contract_list:
    queue.add(ib.reqMktData, contract, '', False, False)
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Minimal Example

```python
from ib_insync import *

# Jupyter notebook? Uncomment:
# util.startLoop()

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Get account info
account = ib.managedAccounts()[0]
print(f"Connected to account: {account}")

# Create contract
contract = Stock('AAPL', 'SMART', 'USD')

# Get market data
ticker = ib.reqMktData(contract)
ib.sleep(2)  # Wait for data
print(ticker.marketPrice())

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Base Contract

```python
@dataclass
class Contract:
    conId: int = 0              # Unique IB contract ID
    symbol: str = ''            # Ticker symbol
    secType: str = ''           # Security type
    lastTradeDateOrContractMonth: str = ''
    strike: float = 0.0
    right: str = ''             # 'C' or 'P' for options
    multiplier: str = ''
    exchange: str = ''
    primaryExchange: str = ''
    currency: str = ''
    localSymbol: str = ''
    tradingClass: str = ''
    includeExpired: bool = False
    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC
    secId: str = ''
    description: str = ''
    issuerId: str = ''
    comboLegsDescrip: str = ''
    comboLegs: List = None      # For combo orders
    deltaNeutralContract: DeltaNeutralContract = None
```

> **Note:** Single example, no duplicates found

###  Stock

```python
Stock(
    symbol: str,
    exchange: str = 'SMART',
    currency: str = 'USD',
    primaryExchange: str = ''
)

# Examples
Stock('AAPL', 'SMART', 'USD')
Stock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')
Stock('BMW', 'SMART', 'EUR', primaryExchange='IBIS')
```

> **Note:** Single example, no duplicates found

###  Future

```python
Future(
    symbol: str = '',
    lastTradeDateOrContractMonth: str = '',
    exchange: str = '',
    multiplier: str = '',
    currency: str = ''
)

# Examples
Future('ES', '20240920', 'GLOBEX')  # E-mini S&P
Future('CL', '202412', 'NYMEX')     # Crude Oil
```

> **Note:** Single example, no duplicates found

###  Option

```python
Option(
    symbol: str = '',
    lastTradeDateOrContractMonth: str = '',
    strike: float = 0.0,
    right: str = '',            # 'C' or 'P'
    exchange: str = '',
    multiplier: str = '',
    currency: str = ''
)

# Examples
Option('SPY', '20240920', 450, 'C', 'SMART')  # Call
Option('AAPL', '20240315', 180, 'P', 'SMART') # Put
```

> **Note:** Single example, no duplicates found

###  Contract by conId

```python
Contract(conId=270639)  # Direct lookup by IB contract ID
```

> **Note:** Single example, no duplicates found

###  Qualify Contracts

```python
# Resolve ambiguous contracts
contracts = ib.qualifyContracts(contract)
# Returns list of fully qualified contracts

# Example
stock = Stock('AAPL', 'SMART', 'USD')
qualified = ib.qualifyContracts(stock)[0]
print(qualified.conId)  # IB contract ID
```

> **Note:** Single example, no duplicates found

###  Contract Details

```python
details = ib.reqContractDetails(contract)
# Returns List[ContractDetails]

# ContractDetails fields:
# .contract - Fully qualified contract
# .marketName
# .minTick
# .priceMagnifier
# .orderTypes
# .validExchanges
# .underConId
# .longName
# .contractMonth
# .industry
# .category
# .subcategory
# .timeZoneId
# .tradingHours
# .liquidHours
# And many more...
```

> **Note:** Single example, no duplicates found

###  Match Symbols

```python
descriptions = ib.reqMatchingSymbols('app')
# Returns List[ContractDescription]
# Fuzzy search for symbols
```

> **Note:** Single example, no duplicates found

###  Base Order

```python
@dataclass
class Order:
    orderId: int = 0
    clientId: int = 0
    permId: int = 0
    action: str = ''            # 'BUY' or 'SELL'
    totalQuantity: float = 0.0
    orderType: str = ''         # See order types below
    lmtPrice: float = 0.0
    auxPrice: float = 0.0       # Stop price
    tif: str = 'DAY'            # Time in force
    
    # Advanced fields
    ocaGroup: str = ''          # One-Cancels-All group
    account: str = ''
    openClose: str = 'O'        # 'O'=open, 'C'=close
    origin: int = 0             # 0=customer
    orderRef: str = ''
    transmit: bool = True       # Auto-transmit
    parentId: int = 0           # For bracket orders
    blockOrder: bool = False
    sweepToFill: bool = False
    displaySize: int = 0
    triggerMethod: int = 0
    outsideRth: bool = False    # Outside regular hours
    hidden: bool = False
    
    # Order combos
    goodAfterTime: str = ''
    goodTillDate: str = ''
    rule80A: str = ''
    allOrNone: bool = False
    minQty: int = None
    percentOffset: float = None
    overridePercentageConstraints: bool = False
    trailStopPrice: float = None
    trailingPercent: float = None
    
    # Financial advisors
    faGroup: str = ''
    faProfile: str = ''
    faMethod: str = ''
    faPercentage: str = ''
    
    # Institutional
    designatedLocation: str = ''
    exemptCode: int = -1
    
    # Smart routing
    discretionaryAmt: float = 0.0
    eTradeOnly: bool = False
    firmQuoteOnly: bool = False
    nbboPriceCap: float = None
    optOutSmartRouting: bool = False
    
    # Pegged orders
    stockRefPrice: float = None
    delta: float = None
    
    # Volatility orders
    volatility: float = None
    volatilityType: int = None
    deltaNeutralOrderType: str = ''
    deltaNeutralAuxPrice: float = None
    deltaNeutralConId: int = 0
    deltaNeutralShortSale: bool = False
    deltaNeutralShortSaleSlot: int = 0
    deltaNeutralDesignatedLocation: str = ''
    continuousUpdate: bool = False
    referencePriceType: int = None
    
    # Conditions
    conditions: List = None
    conditionsIgnoreRth: bool = False
    conditionsCancelOrder: bool = False
    
    # Algo orders
    algoStrategy: str = ''
    algoParams: List = None
    
    # What-if
    whatIf: bool = False
    
    # Misc
    notHeld: bool = False
    solicited: bool = False
    randomizeSize: bool = False
    randomizePrice: bool = False
    
    # Pegged to benchmark
    referenceContractId: int = 0
    peggedChangeAmount: float = 0.0
    isPeggedChangeAmountDecrease: bool = False
    referenceChangeAmount: float = 0.0
    referenceExchangeId: str = ''
    adjustedOrderType: str = ''
    
    # Misc2
    modelCode: str = ''
    extOperator: str = ''
    cashQty: float = None
    mifid2DecisionMaker: str = ''
    mifid2DecisionAlgo: str = ''
    mifid2ExecutionTrader: str = ''
    mifid2ExecutionAlgo: str = ''
    dontUseAutoPriceForHedge: bool = False
    
    # Manual times (for audit)
    manualOrderTime: str = ''
    manualOrderCancelTime: str = ''
    
    # Post to ATS
    usePriceMgmtAlgo: bool = None
```

> **Note:** Single example, no duplicates found

###  Place Order

```python
trade = ib.placeOrder(contract: Contract, order: Order) -> Trade
# Returns Trade object (live-updated)

# Example
contract = Stock('AAPL', 'SMART', 'USD')
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# Trade object updated in real-time:
# - trade.orderStatus
# - trade.fills
# - trade.log
```

> **Note:** Single example, no duplicates found

###  Trade Object

```python
@dataclass
class Trade:
    contract: Contract = None
    order: Order = None
    orderStatus: OrderStatus = None
    fills: List[Fill] = []
    log: List[TradeLogEntry] = []
    
    # Methods
    def isActive(self) -> bool
    def isDone(self) -> bool
    def filled(self) -> float
    def remaining(self) -> float
```

> **Note:** Single example, no duplicates found

### The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis.

```python
orderState = ib.whatIfOrder(contract, order)
# Test order without placing
# Returns OrderState with commission/margin impact

# OrderState fields:
# .initMarginBefore
# .maintMarginBefore
# .equityWithLoanBefore
# .initMarginAfter
# .maintMarginAfter
# .equityWithLoanAfter
# .commission
# .minCommission
# .maxCommission
# .commissionCurrency
```

> **Note:** Example 1 focuses on field structure while Example 2 emphasizes debugging order rejections. Both agree on core usage but Example 2 adds error context and debugging practices.

###  Request Market Data (Streaming)

```python
ticker = ib.reqMktData(
    contract: Contract,
    genericTickList: str = '',
    snapshot: bool = False,
    regulatorySnapshot: bool = False,
    mktDataOptions: List = None
) -> Ticker

# Ticker auto-updates in real-time
```

> **Note:** Single example, no duplicates found

### Generic Tick List IDs:

```python
100 - putVolume, callVolume (options)
101 - putOpenInterest, callOpenInterest (options)
104 - histVolatility (options)
105 - avOptionVolume (options)
106 - impliedVolatility (options)
162 - indexFuturePremium
165 - low13week, high13week, low26week, high26week,
      low52week, high52week, avVolume
221 - markPrice
225 - auctionVolume, auctionPrice, auctionImbalance
233 - last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 - shortableShares
258 - fundamentalRatios
```

> **Note:** Single example, no duplicates found

### Example:

```python
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract, genericTickList='233,236')
ib.sleep(2)
print(f"Last: {ticker.last}")
print(f"Bid: {ticker.bid}")
print(f"Ask: {ticker.ask}")
print(f"Volume: {ticker.volume}")
```

> **Note:** Single example, no duplicates found

### Cancels real-time market data subscriptions. Use cancelMktData to stop receiving market data (e.g., last price, bid/ask) for a specific contract. Use cancelMktDepth to stop receiving market depth (order book level 2) data for a specific contract. Both require the original Contract object used for subscription.

```python
ib.cancelMktData(contract: Contract) -> None
ib.cancelMktDepth(contract: Contract) -> None
```

> **Note:** cancelMktData stops standard market data streams while cancelMktDepth stops level 2 market depth data. They are separate methods for different subscription types but both require the same Contract parameter.

###  Ticker Object

```python
@dataclass
class Ticker:
    contract: Contract = None
    time: datetime = None
    
    # Bid/Ask
    bid: float = nan
    bidSize: float = nan
    bidExchange: str = ''
    ask: float = nan
    askSize: float = nan
    askExchange: str = ''
    
    # Last trade
    last: float = nan
    lastSize: float = nan
    lastExchange: str = ''
    
    # Volume
    volume: float = nan
    volumeRate: float = nan
    
    # Prices
    open: float = nan
    high: float = nan
    low: float = nan
    close: float = nan
    vwap: float = nan
    
    # Options
    putVolume: float = nan
    callVolume: float = nan
    putOpenInterest: float = nan
    callOpenInterest: float = nan
    avOptionVolume: float = nan
    impliedVolatility: float = nan
    histVolatility: float = nan
    
    # Greeks (options)
    delta: float = nan
    gamma: float = nan
    theta: float = nan
    vega: float = nan
    
    # Market depth
    domBids: List = []
    domAsks: List = []
    domTicks: List = []
    
    # Ticks
    ticks: List = []
    tickByTicks: List = []
    
    # Halted
    halted: float = nan
    
    # Real-time
    rtVolume: float = nan
    rtTime: datetime = None
    rtHistVolativity: float = nan
    rtTradeVolume: float = nan
    
    # Methods
    def marketPrice(self) -> float
    def hasBidAsk(self) -> bool
    def midpoint(self) -> float
```

> **Note:** Single example, no duplicates found

###  Market Depth (Level II)

```python
ticker = ib.reqMktDepth(
    contract: Contract,
    numRows: int = 5,
    isSmartDepth: bool = False,
    mktDepthOptions: List = None
) -> Ticker

# Ticker.domBids and Ticker.domAsks auto-update
```

> **Note:** Single example, no duplicates found

###  Tick-by-Tick Data

```python
ticker = ib.reqTickByTickData(
    contract: Contract,
    tickType: str,  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'
    numberOfTicks: int = 0,
    ignoreSize: bool = False
) -> Ticker

# Ticker.tickByTicks auto-updates
```

> **Note:** Single example, no duplicates found

###  Request Historical Data

```python
bars = ib.reqHistoricalData(
    contract: Contract,
    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'
    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'
    barSizeSetting: str = '1 hour',
    whatToShow: str = 'TRADES', # See below
    useRTH: bool = True,        # Regular trading hours only
    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch
    keepUpToDate: bool = False, # Auto-update
    chartOptions: List = None,
    timeout: float = 60
) -> BarDataList

# Returns BarDataList (auto-synced if keepUpToDate=True)
```

> **Note:** Single example, no duplicates found

### What to Show:

```python
'TRADES'           - Actual trades
'MIDPOINT'         - Bid/ask midpoint
'BID'              - Bid prices
'ASK'              - Ask prices
'BID_ASK'          - Bid/ask pairs
'HISTORICAL_VOLATILITY'
'OPTION_IMPLIED_VOLATILITY'
'REBATE_RATE'
'FEE_RATE'
'YIELD_BID'
'YIELD_ASK'
'YIELD_BID_ASK'
'YIELD_LAST'
```

> **Note:** Single example, no duplicates found

###  Historical Ticks

```python
ticks = ib.reqHistoricalTicks(
    contract: Contract,
    startDateTime: str,
    endDateTime: str,
    numberOfTicks: int = 1000,
    whatToShow: str = 'TRADES',  # 'TRADES', 'BID_ASK', 'MIDPOINT'
    useRth: bool = True,
    ignoreSize: bool = False,
    miscOptions: List = None
) -> List

# Returns list of HistoricalTick objects
```

> **Note:** Single example, no duplicates found

###  Head Timestamp

```python
headTimestamp = ib.reqHeadTimeStamp(
    contract: Contract,
    whatToShow: str = 'TRADES',
    useRTH: bool = True,
    formatDate: int = 1
) -> str

# Earliest available data timestamp
```

> **Note:** Single example, no duplicates found

###  Historical Schedule

```python
schedule = ib.reqHistoricalSchedule(
    contract: Contract,
    numDays: int = 1,
    endDateTime: str = '',
    useRTH: bool = True
) -> List[HistoricalSchedule]

# Trading schedule for contract
```

> **Note:** Single example, no duplicates found

###  Real-Time Bars

```python
bars = ib.reqRealTimeBars(
    contract: Contract,
    barSize: int = 5,           # Only 5 supported
    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK
    useRTH: bool = False,
    realTimeBarsOptions: List = None
) -> RealTimeBarList

# Returns RealTimeBarList (auto-updating)
# bars.updateEvent fires on new bar
```

> **Note:** Single example, no duplicates found

### Common Tags:

```python
NetLiquidation      - Total account value
TotalCashValue      - Cash balance
SettledCash         - Settled cash
AccruedCash         - Accrued cash
BuyingPower         - Buying power
EquityWithLoanValue - Stock value + cash
GrossPositionValue  - Total position value
RegTEquity          - RegT equity
RegTMargin          - RegT margin
SMA                 - Special Memo Account
InitMarginReq       - Initial margin
MaintMarginReq      - Maintenance margin
AvailableFunds      - Available funds
ExcessLiquidity     - Excess liquidity
```

> **Note:** Single example, no duplicates found

###  Portfolio

```python
portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]

# PortfolioItem fields:
# .contract
# .position        - Quantity
# .marketPrice     - Current price
# .marketValue     - Position value
# .averageCost     - Avg cost basis
# .unrealizedPNL   - Unrealized P&L
# .realizedPNL     - Realized P&L
# .account
```

> **Note:** Single example, no duplicates found

###  Positions

```python
positions = ib.positions(account: str = '') -> List[Position]

# Position fields:
# .account
# .contract
# .position       - Quantity
# .avgCost        - Average cost
```

> **Note:** Single example, no duplicates found

###  Event Handling

```python
# Events use eventkit library

# Subscribe to event
def onPendingTickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.marketPrice()}")

ib.pendingTickersEvent += onPendingTickers

# Unsubscribe
ib.pendingTickersEvent -= onPendingTickers

# One-time handler
ib.connectedEvent += lambda: print('Connected!')
```

> **Note:** Single example, no duplicates found

###  Connection Events

```python
# Connected
ib.connectedEvent += lambda: print('Connected to TWS')

# Disconnected
ib.disconnectedEvent += lambda: print('Disconnected')

# Error
ib.errorEvent += lambda reqId, errorCode, errorString, contract: \
    print(f'Error {errorCode}: {errorString}')
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Use streaming:

```python
# For tick data
ticker = ib.reqMktData(contract, '233')  # Last, volume, vwap
ticker.updateEvent += lambda ticker: process_tick(ticker)

# For bar data
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)
```

> **Note:** Single example, no duplicates found

### ❌ BAD - Ambiguous:

```python
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Qualified:

```python
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
ticker = ib.reqMktData(contract)
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
def on_error(reqId, errorCode, errorString, contract):
    if errorCode == 200:
        print(f"Contract not found: {contract}")
    elif errorCode == 321:
        print(f"Validation error: {errorString}")
    # Handle other errors...

ib.errorEvent += on_error
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
try:
    ticker = ib.reqMktData(contract)
    # ... do work ...
finally:
    ib.cancelMktData(contract)
    ib.disconnect()
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Built-in throttling:

```python
# ib-insync handles throttling automatically
for contract in large_list:
    ib.reqMktData(contract)
# No manual delays needed
```

> **Note:** Single example, no duplicates found

###  Pattern: Live Ticker Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        symbol = ticker.contract.symbol
        price = ticker.marketPrice()
        volume = ticker.volume
        print(f"{symbol}: ${price:.2f} | Vol: {volume}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract, '', False, False)

# Run forever
ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Real-Time Bar Processing

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
contract = ib.qualifyContracts(contract)[0]

def on_bar_update(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        print(f"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += on_bar_update

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Historical Data Download

```python
from ib_insync import *
import pandas as pd

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Download multiple timeframes
timeframes = [
    ('1 Y', '1 day'),
    ('6 M', '1 hour'),
    ('30 D', '15 mins')
]

all_data = {}
for duration, barsize in timeframes:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime='',
        durationStr=duration,
        barSizeSetting=barsize,
        whatToShow='TRADES',
        useRTH=True
    )
    df = util.df(bars)
    all_data[f'{duration}_{barsize}'] = df
    print(f"Downloaded {len(bars)} {barsize} bars for {duration}")

# Save to files
for name, df in all_data.items():
    df.to_csv(f"{contract.symbol}_{name}.csv", index=False)

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Pattern: Portfolio Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def show_portfolio():
    print("\n=== PORTFOLIO ===")
    for item in ib.portfolio():
        symbol = item.contract.symbol
        pos = item.position
        price = item.marketPrice
        value = item.marketValue
        pnl = item.unrealizedPNL
        print(f"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}")
    
    print("\n=== ACCOUNT ===")
    values = ib.accountValues()
    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']
    for value in values:
        if value.tag in important_tags:
            print(f"{value.tag:20} | {value.value:15} {value.currency}")

def on_update(item):
    show_portfolio()

# Show initial state
show_portfolio()

# Update on changes
ib.updatePortfolioEvent += on_update

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Option Chain Analysis

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

# Get option chain
chains = ib.reqSecDefOptParams(
    underlying.symbol,
    '',
    underlying.secType,
    underlying.conId
)

print(f"Found {len(chains)} option chains")

# Get chain for specific exchange
chain = next(c for c in chains if c.exchange == 'SMART')
print(f"Trading class: {chain.tradingClass}")
print(f"Expirations: {sorted(chain.expirations)[:5]}")  # First 5
print(f"Strike range: {min(chain.strikes)} - {max(chain.strikes)}")

# Request contracts for specific expiration
expiration = sorted(chain.expirations)[0]
strikes = sorted([s for s in chain.strikes if 400 < s < 500])

contracts = [
    Option('SPY', expiration, strike, right, 'SMART')
    for strike in strikes[:5]
    for right in ['C', 'P']
]

# Qualify and get details
contracts = ib.qualifyContracts(*contracts)

# Request market data
for contract in contracts:
    ticker = ib.reqMktData(contract, '', False, False)
    ib.sleep(1)
    print(f"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}")

ib.disconnect()
```

> **Note:** Single example, no duplicates found

### Error 326: Unable to connect

```python
# Check API settings in TWS:
# Configuration -> API -> Settings
# - Enable ActiveX and Socket Clients
# - Socket port: 7497 (TWS) or 4001 (Gateway)
# - Trusted IPs: 127.0.0.1
# - Master API client ID: (optional)
```

> **Note:** Single example, no duplicates found

### Error 162: Historical Market Data Service error

```python
# Common causes:
# 1. Requesting too much data
# 2. Invalid date range
# 3. Contract not found
# 4. No data available for period

# Solution: Break into chunks
dt = ''
all_bars = []
while True:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime=dt,
        durationStr='30 D',
        barSizeSetting='1 hour',
        whatToShow='TRADES',
        useRTH=True
    )
    if not bars:
        break
    all_bars.extend(bars)
    dt = bars[0].date
    ib.sleep(1)  # Respect rate limits
```

> **Note:** Single example, no duplicates found

### Ticker accumulation

```python
# Cancel unused tickers
for contract in old_contracts:
    ib.cancelMktData(contract)

# Clear refs
del ticker
```

> **Note:** Single example, no duplicates found


## Data

### Demonstrates incorrect pattern of repeatedly polling historical data in a blocking loop. This approach violates API best practices by 1) Using historical requests instead of real-time streaming 2) Blocking the event loop with sleep() which prevents processing of messages and events. Use real-time market data subscriptions instead of polling historical endpoints.

```python
while True:
    bars = ib.reqHistoricalData(...)  # DON'T POLL!
    time.sleep(5)  # Also wrong - blocks event loop!
```

> **Note:** Example 2 adds emphasis on event loop blocking consequence. Both agree on core anti-pattern of polling historical data. Combined comments show both polling and blocking issues.

### ✅ ALWAYS DO THIS:

```python
# For ticks
ticker = ib.reqMktData(contract)
ticker.updateEvent += process_tick

# For bars  
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += process_bar
```

> **Note:** Single example, no duplicates found

###  Basic Ticker (Streaming)

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Start streaming
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data
ib.sleep(2)

print(f"Bid: {ticker.bid}")
print(f"Ask: {ticker.ask}")
print(f"Last: {ticker.last}")
print(f"Volume: {ticker.volume}")
```

> **Note:** Single example, no duplicates found

###  With Event Handler

```python
def on_ticker_update(ticker):
    print(f"{ticker.contract.symbol}: ${ticker.last:.2f}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_ticker_update
```

> **Note:** Single example, no duplicates found

###  Generic Ticks (Extra Data)

```python
# Request additional data
ticker = ib.reqMktData(
    contract,
    genericTickList='233,236',  # Volume, shortable shares
    snapshot=False
)

ib.sleep(2)
print(f"VWAP: {ticker.vwap}")
print(f"RT Volume: {ticker.rtVolume}")
```

> **Note:** Single example, no duplicates found

### Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.

```python
contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',          # '' = now
    durationStr='30 D',      # 30 days
    barSizeSetting='1 hour',
    whatToShow='TRADES',     # Can be MIDPOINT for FX
    useRTH=True              # Regular hours only
)

# Convert to pandas
df = util.df(bars)
print(df.head())
```

> **Note:** Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df

###  Keep Historical Updated (Live)

```python
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    keepUpToDate=True  # ← Auto-update!
)

bars.updateEvent += lambda bars, hasNewBar: print(f"Updated: {hasNewBar}")
```

> **Note:** Single example, no duplicates found

###  Multiple Tickers Pattern

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract)

ib.run()  # Run event loop
```

> **Note:** Single example, no duplicates found

###  Price Alert System

```python
def price_alert(ticker, target_price, above=True):
    """Alert when price crosses threshold"""
    def check_price(ticker):
        if not ticker.last or ticker.last != ticker.last:
            return
        
        if above and ticker.last >= target_price:
            print(f"ALERT: {ticker.contract.symbol} above ${target_price}")
            ticker.updateEvent -= check_price  # Unsubscribe
        elif not above and ticker.last <= target_price:
            print(f"ALERT: {ticker.contract.symbol} below ${target_price}")
            ticker.updateEvent -= check_price
    
    ticker.updateEvent += check_price

# Usage
ticker = ib.reqMktData(contract)
price_alert(ticker, 180.0, above=True)
```

> **Note:** Single example, no duplicates found

###  OHLC Tracker

```python
class OHLCTracker:
    def __init__(self):
        self.open = None
        self.high = None
        self.low = None
        self.close = None
    
    def update(self, price):
        if self.open is None:
            self.open = price
        
        if self.high is None or price > self.high:
            self.high = price
        
        if self.low is None or price < self.low:
            self.low = price
        
        self.close = price
    
    def reset(self):
        self.open = self.high = self.low = self.close = None

tracker = OHLCTracker()

def on_tick(ticker):
    if ticker.last:
        tracker.update(ticker.last)
        print(f"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_tick
```

> **Note:** Single example, no duplicates found

### Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...

```python
# Blocking interface - simple and direct
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)  # Blocks until complete
```

> **Note:** Single example, no duplicates found

### ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
bars = ib.reqHistoricalData(contract, ...)   Blocks until complete


```python
# Asynchronous interface - non-blocking
import asyncio
from ib_insync import *

async def main():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking
    
asyncio.run(main())
```

> **Note:** Single example, no duplicates found

### The golden rule: never use time.sleep()—always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields...

```python
# WRONG - freezes everything
import time
ticker = ib.reqMktData(contract)
time.sleep(5)  # Event loop frozen, no updates processed
print(ticker.last)  # May be empty

# CORRECT - allows message processing
ticker = ib.reqMktData(contract)
ib.sleep(5)  # Framework processes updates in background
print(ticker.last)  # Contains current data
```

> **Note:** Single example, no duplicates found

### For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def onTicker(ticker):
    print(f"Price update: {ticker.contract.symbol} @ {ticker.last}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += onTicker

ib.run()  # Runs event loop indefinitely
```

> **Note:** Single example, no duplicates found

### Ticker-specific events provide fine-grained control over individual market data subscriptions:

```python
contract = Forex('EURUSD')
ticker = ib.reqMktData(contract)

async def onTickerUpdate(ticker):
    print(f"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}")
    
ticker.updateEvent += onTickerUpdate
```

> **Note:** Single example, no duplicates found

### Use asyncio.createtask() for truly concurrent execution of independent operations:

```python
async def monitor_multiple_tickers():
    ib = IB()
    await ib.connectAsync('127.0.0.1', 7497, clientId=1)
    
    async def watch_ticker(contract):
        ticker = ib.reqMktData(contract)
        await ib.sleep(1)
        return ticker
    
    # Create tasks for concurrent execution
    tasks = [
        asyncio.create_task(watch_ticker(Forex('EURUSD'))),
        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),
        asyncio.create_task(watch_ticker(Forex('USDJPY')))
    ]
    
    tickers = await asyncio.gather(*tasks)
    return tickers
```

> **Note:** Single example, no duplicates found

### The returned objects themselves—Ticker, Trade, Position, Portfolio—are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...

```python
# Trade object is automatically updated
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# trade.orderStatus updates automatically in background
def check_order_status():
    if trade.orderStatus.status == 'Filled':
        print("Order filled!")
    elif trade.isDone():
        print("Order completed")
```

> **Note:** Single example, no duplicates found

### Not checking connection state: Always verify connection before state access.

```python
def get_price():
    if not ib.isConnected():
        raise ConnectionError("Not connected to IB")
    ticker = ib.reqMktData(contract)
    ib.sleep(2)
    if ticker.last:
        return ticker.last
    raise ValueError("No price data available")
```

> **Note:** Single example, no duplicates found

### The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl...

```python
# Request data for expired contract
contract = Future('ES', '202012', 'CME')
contract.includeExpired = True

qualified = ib.qualifyContracts(contract)
if qualified:
    bars = ib.reqHistoricalData(
        qualified[0],
        endDateTime='',
        durationStr='1 Y',
        barSizeSetting='1 day',
        whatToShow='TRADES',
        useRTH=True
    )
    print(f"Retrieved {len(bars)} bars")
```

> **Note:** Single example, no duplicates found

### ContFuture provides rolled contract data for backtesting but has significant limitations:

```python
# Continuous futures (historical data only)
cont_future = ContFuture('ES', 'CME')
ib.qualifyContracts(cont_future)

bars = ib.reqHistoricalData(
    cont_future,
    endDateTime='',
    durationStr='2 Y',
    barSizeSetting='1 day',
    whatToShow='TRADES',
    useRTH=True
)
```

> **Note:** Single example, no duplicates found

### The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Subscribe to market data
ticker = ib.reqMktData(contract, '', False, False)

# Wait for data to populate
ib.sleep(2)

# Access real-time data
print(f"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}")
```

> **Note:** Single example, no duplicates found

### The genericTickList parameter requests specific data fields using tick IDs: 100 (options volume), 101 (options open interest), 106 (implied volatility), 165 (52-week high/low), 233 (time & sales with ...

```python
# Request time & sales data
ticker = ib.reqMktData(contract, '233', False, False)
ib.sleep(2)
print(f"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}")
```

> **Note:** Single example, no duplicates found

### Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing.

```python
contract = Stock('TSLA', 'SMART', 'USD')

bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    formatDate=1,
    keepUpToDate=True  # Enables live updates
)
```

> **Note:** Example 1 includes formatDate=1 while Example 2 omits it. Example 2 explicitly mentions bars.updateEvent firing on changes. Both agree on core parameters. Contract creation shown in Example 1 but not Example 2.

### Individual ticker events for ticker-specific logic:

```python
def onTickerUpdate(ticker):
    print(f"{ticker.contract.symbol}: Last {ticker.last}")

contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
ticker.updateEvent += onTickerUpdate

ib.run()
```

> **Note:** Single example, no duplicates found

### Global pendingTickersEvent for monitoring multiple tickers efficiently:

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

def onPendingTickers(tickers):
    """Called when any subscribed ticker has new data"""
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.last}")

ib.pendingTickersEvent += onPendingTickers
ib.run()
```

> **Note:** Single example, no duplicates found

### Bar update events for streaming bar data:

```python
def onBarUpdate(bars, hasNewBar):
    """
    bars: BarDataList containing all bars
    hasNewBar: Boolean indicating if a new bar was added
    """
    if hasNewBar:
        latest = bars[-1]
        print(f"New bar: O={latest.open}, H={latest.high}, "
              f"L={latest.low}, C={latest.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += onBarUpdate
ib.run()
```

> **Note:** Single example, no duplicates found

### Combine ibinsync with pandas for structured data handling:

```python
import pandas as pd

contracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]
ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

# Create DataFrame
df = pd.DataFrame(
    index=[c.pair() for c in contracts],
    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']
)

def onPendingTickers(tickers):
    for t in tickers:
        df.loc[t.contract.pair()] = (
            t.bidSize, t.bid, t.ask, t.askSize, 
            t.high, t.low, t.close
        )
    print(df)

ib.pendingTickersEvent += onPendingTickers
ib.sleep(30)
```

> **Note:** Single example, no duplicates found

### ibinsync automatically throttles requests to 45 requests per second, compatible with TWS/Gateway 974+. No manual intervention needed for individual requests, but spread out batch operations:

```python
for contract in large_contract_list:
    ticker = ib.reqMktData(contract)
    ib.sleep(0.02)  # Small delay between requests
```

> **Note:** Single example, no duplicates found

### Interactive Brokers limits concurrent subscriptions: typically 100 for market data lines, only 3 for tick-by-tick data.

```python
active_subscriptions = set()
MAX_SUBSCRIPTIONS = 95  # Leave margin

def subscribe_with_limit(contract):
    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:
        # Unsubscribe oldest
        oldest = active_subscriptions.pop()
        ib.cancelMktData(oldest)
    
    ticker = ib.reqMktData(contract)
    active_subscriptions.add(contract)
    return ticker
```

> **Note:** Single example, no duplicates found

### Encapsulate subscription management in a reusable class:

```python
class TickerManager:
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.contracts = {}
        
    def subscribe(self, symbol, exchange='SMART', currency='USD'):
        contract = Stock(symbol, exchange, currency)
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract)
        ticker.updateEvent += self.onUpdate
        
        self.tickers[symbol] = ticker
        self.contracts[symbol] = contract
        return ticker
    
    def unsubscribe(self, symbol):
        if symbol in self.tickers:
            self.ib.cancelMktData(self.contracts[symbol])
            del self.tickers[symbol]
            del self.contracts[symbol]
    
    def onUpdate(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")

# Usage
manager = TickerManager(ib)
manager.subscribe('AAPL')
manager.subscribe('GOOGL')
```

> **Note:** Single example, no duplicates found

### Critical: Use the same contract object for cancellation that you used for subscription. Creating a new identical contract won't work—object identity matters.

```python
# WRONG
contract1 = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract1)

contract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!
ib.cancelMktData(contract2)  # Won't work

# CORRECT
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
ib.cancelMktData(contract)  # Use same object
```

> **Note:** Single example, no duplicates found

### Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update—process ticks in event handlers when they arrive.

```python
# WRONG - ticks cleared before checking
ticker = ib.reqMktData(contract)
ib.sleep(5)
print(ticker.ticks)  # Likely empty

# CORRECT - process in event
def onUpdate(ticker):
    for tick in ticker.ticks:
        process_tick(tick)

ticker.updateEvent += onUpdate
```

> **Note:** Single example, no duplicates found

###  Production-ready streaming system

```python
from ib_insync import *
import logging

logging.basicConfig(level=logging.INFO)

class TradingSystem:
    def __init__(self):
        self.ib = IB()
        self.tickers = {}
        self.active_contracts = set()
        
    def connect(self):
        self.ib.connect('127.0.0.1', 7497, clientId=1)
        self.ib.errorEvent += self.onError
        self.ib.pendingTickersEvent += self.onPendingTickers
        
    def subscribe(self, symbol):
        contract = Stock(symbol, 'SMART', 'USD')
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract, '', False, False)
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
    def onPendingTickers(self, tickers):
        for ticker in tickers:
            self.process_ticker(ticker)
            
    def process_ticker(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")
        
        # Always yield control in callbacks
        self.ib.sleep(0)
        
    def onError(self, reqId, errorCode, errorString, contract):
        logging.error(f"Error {errorCode}: {errorString}")
        
    def shutdown(self):
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
        self.ib.sleep(1)
        self.ib.disconnect()
        
    def run(self):
        try:
            self.ib.run()
        except KeyboardInterrupt:
            print("Shutting down...")
        finally:
            self.shutdown()

# Usage
if __name__ == '__main__':
    system = TradingSystem()
    system.connect()
    system.subscribe('AAPL')
    system.subscribe('GOOGL')
    system.run()
```

> **Note:** Single example, no duplicates found

### For live futures data, proper subscription management is essential:

```python
class FuturesDataManager:
    """Manage real-time data for multiple futures contracts"""
    
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.active_contracts = set()
        
    def subscribe(self, symbol, exchange='CME'):
        """Subscribe to real-time market data for a futures contract"""
        # Get front month contract
        contract = get_front_month_contract(self.ib, symbol, exchange)
        
        if not contract:
            print(f"Error: Could not find front month contract for {symbol}")
            return None
            
        # Request market data
        ticker = self.ib.reqMktData(contract, '', False, False)
        
        # Store references
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
        return ticker
        
    def get_price(self, symbol):
        """Get current price for a subscribed symbol"""
        if symbol not in self.tickers:
            return None
            
        ticker = self.tickers[symbol]
        
        # Use last or midpoint price
        if ticker.last:
            return ticker.last
        elif ticker.bid and ticker.ask:
            return (ticker.bid + ticker.ask) / 2
        else:
            return None
    
    def get_contracts_expiring_soon(self, days_threshold=10):
        """Get list of contracts expiring soon"""
        expiring_soon = []
        now = datetime.now()
        
        for contract in self.active_contracts:
            expiry_str = contract.lastTradeDateOrContractMonth
            
            if len(expiry_str) == 8:  # YYYYMMDD format
                expiry = datetime.strptime(expiry_str, '%Y%m%d')
            else:  # YYYYMM format
                expiry = datetime.strptime(f"{expiry_str}01", '%Y%m%d')
                
            days_to_expiry = (expiry - now).days
            
            if days_to_expiry <= days_threshold:
                expiring_soon.append((contract, days_to_expiry))
                
        return expiring_soon
        
    def cleanup(self):
        """Unsubscribe from all market data"""
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
            
        self.tickers.clear()
        self.active_contracts.clear()
```

> **Note:** Single example, no duplicates found

### For continuous futures analysis, use a combination of reqHistoricalData and dynamic front-month tracking:

```python
def get_continuous_futures_data(ib, symbol, exchange, duration='1 Y', bar_size='1 day'):
    """Get historical data for continuous futures contract"""
    # Create a ContFuture for historical data
    contract = ContFuture(symbol, exchange)
    ib.qualifyContracts(contract)
    
    # Request historical data
    bars = ib.reqHistoricalData(
        contract,
        endDateTime='',
        durationStr=duration,
        barSizeSetting=bar_size,
        whatToShow='TRADES',
        useRTH=True
    )
    
    return bars

# Get front month based on volume/open interest
def get_most_liquid_contract(ib, symbol, exchange):
    """Get the most liquid contract based on volume and open interest"""
    # Get all active contracts for this symbol
    contract = Future(symbol, exchange=exchange)
    details_list = ib.reqContractDetails(contract)
    
    if not details_list:
        return None
    
    # Filter out expired contracts
    now = datetime.now()
    active_contracts = []
    
    for details in details_list:
        expiry_str = details.contract.lastTradeDateOrContractMonth
        
        if len(expiry_str) == 8:
            expiry = datetime.strptime(expiry_str, '%Y%m%d')
        else:
            expiry = datetime.strptime(f"{expiry_str}01", '%Y%m%d')
            
        if expiry > now:
            active_contracts.append(details.contract)
    
    if not active_contracts:
        return None
    
    # Get volume data for each contract
    contract_data = []
    
    for contract in active_contracts:
        ticker = ib.reqMktData(contract, '100,101', False, False)  # Request volume and OI
        ib.sleep(1)  # Allow data to populate
        
        contract_data.append({
            'contract': contract,
            'volume': ticker.volume or 0,
            'openInterest': ticker.openInterest or 0
        })
        
        # Cancel the market data request
        ib.cancelMktData(contract)
    
    # Sort by combined volume and open interest
    contract_data.sort(key=lambda x: x['volume'] + x['openInterest'], reverse=True)
    
    # Return the most liquid contract
    return contract_data[0]['contract'] if contract_data else None
```

> **Note:** Single example, no duplicates found

###  Code Examples
- Fetching consecutive historical data
- Async streaming ticks
- Scanner data (blocking)
- Scanner data (streaming)
- Option calculations
- Order book
- Minimum price increments
- News ...

```python
pip install ib_insync


from ib_insync import *
# util.startLoop() # uncomment this line when in a notebook
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
contract, endDateTime='', durationStr='30 D',
barSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)

# convert to pandas dataframe:
df = util.df(bars)
print(df)
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

###  Fetching consecutive historical data

```python
import datetime
from ib_insync import *
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
contract = Stock('TSLA', 'SMART', 'USD')
dt = ''
barsList = []
while True:
bars = ib.reqHistoricalData(
contract,
endDateTime=dt,
durationStr='10 D',
barSizeSetting='1 min',
whatToShow='MIDPOINT',
useRTH=True,
formatDate=1)
if not bars:
break
barsList.append(bars)
dt = bars[0].date
print(dt)
# save to CSV file
allBars = [b for bars in reversed(barsList) for b in bars]
df = util.df(allBars)
df.to_csv(contract.symbol + '.csv', index=False)
```

> **Note:** Single example, no duplicates found

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.

###  Dividends

```python
contract = Stock('INTC', 'SMART', 'USD')
ticker = ib.reqMktData(contract, '456')
ib.sleep(2)
print(ticker.dividends)
Output:
Dividends(past12Months=1.2, next12Months=1.2, nextDate=datetime.date(2019, 2, 6),␣
nextAmount=0.3)
```

> **Note:** Single example, no duplicates found

###  Fundamental ratios

```python
contract = Stock('IBM', 'SMART', 'USD')
ticker = ib.reqMktData(contract, '258')
ib.sleep(2)
print(ticker.fundamentalRatios)
```

> **Note:** Single example, no duplicates found

###  Delta Hedging Pattern

```python
# Dynamic delta hedging for options position
def calculate_position_delta(portfolio):
    """Calculate total portfolio delta"""
    total_delta = 0.0
    
    for item in portfolio:
        if item.contract.secType == 'OPT':
            # Request option computations
            ticker = ib.reqMktData(item.contract, '', False, False)
            ib.sleep(1)
            
            if ticker.modelGreeks:
                delta = ticker.modelGreeks.delta
                total_delta += delta * item.position
            
            ib.cancelMktData(item.contract)
    
    return total_delta

def hedge_delta(underlying_contract, target_delta=0.0):
    """Adjust underlying position to achieve target delta"""
    portfolio = ib.portfolio()
    current_delta = calculate_position_delta(portfolio)
    
    delta_to_hedge = current_delta - target_delta
    
    if abs(delta_to_hedge) > 0.1:  # Threshold
        # Delta of stock is 1.0
        shares_to_trade = int(delta_to_hedge * 100)  # Per contract
        
        if shares_to_trade > 0:
            order = MarketOrder('SELL', abs(shares_to_trade))
        else:
            order = MarketOrder('BUY', abs(shares_to_trade))
        
        trade = ib.placeOrder(underlying_contract, order)
        print(f"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}")
        
        return trade
    else:
        print(f"Delta within tolerance: {current_delta:.2f}")
        return None

# Run periodically
underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

while True:
    hedge_delta(underlying, target_delta=0.0)
    ib.sleep(300)  # Every 5 minutes
```

> **Note:** Single example, no duplicates found

###  Order Validation Before Submission

```python
def validate_order(ib, contract, order):
    """Validate order before placing"""
    errors = []
    
    # 1. Check contract is qualified
    if contract.conId == 0:
        errors.append("Contract not qualified")
    
    # 2. Check buying power
    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}
    
    if order.action == 'BUY':
        # Estimate cost
        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot
        ib.sleep(1)
        
        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN
            estimated_cost = ticker.ask * order.totalQuantity
            if estimated_cost > account_values.get('BuyingPower', 0):
                errors.append(f"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}")
        
        ib.cancelMktData(contract)
    
    # 3. What-if order check
    try:
        order_copy = Order(**{k: v for k, v in order.__dict__.items()})
        order_copy.whatIf = True
        
        orderState = ib.whatIfOrder(contract, order_copy)
        
        if orderState.commission and orderState.commission > 0:
            # Valid response
            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):
                errors.append("Insufficient margin")
        else:
            errors.append("What-if order returned invalid state")
            
    except Exception as e:
        errors.append(f"What-if validation failed: {e}")
    
    # 4. Check trading hours
    details = ib.reqContractDetails(contract)
    if details:
        # Parse trading hours (simplified)
        # Would need full implementation
        pass
    
    return errors

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
order = LimitOrder('BUY', 1000, 175.0)

validation_errors = validate_order(ib, contract, order)
if validation_errors:
    print("Order validation failed:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    trade = ib.placeOrder(contract, order)
    print("Order placed successfully")
```

> **Note:** Single example, no duplicates found

###  Position Size Calculator

```python
def calculate_position_size(
    ib,
    contract,
    risk_per_trade_pct=0.02,  # 2% risk
    stop_loss_pct=0.05         # 5% stop
):
    """Calculate position size based on risk"""
    
    # Get account value
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    # Calculate dollar risk
    dollar_risk = net_liq * risk_per_trade_pct
    
    # Get current price
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if not ticker.last or ticker.last != ticker.last:  # NaN check
        logging.error("Unable to get price for position sizing")
        return 0
    
    price = ticker.last
    ib.cancelMktData(contract)
    
    # Calculate shares
    # dollar_risk = shares * price * stop_loss_pct
    shares = dollar_risk / (price * stop_loss_pct)
    
    # Round to nearest tradeable lot
    if contract.secType == 'OPT':
        shares = int(shares / 100) * 100  # Options in contracts (100 shares)
    else:
        shares = int(shares)
    
    print(f"Position size for {contract.symbol}: {shares} shares")
    print(f"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})")
    
    return shares

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

shares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)

if shares > 0:
    order = LimitOrder('BUY', shares, 175.0)
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Max Position Concentration

```python
def check_position_concentration(ib, max_position_pct=0.20):
    """Ensure no single position exceeds % of portfolio"""
    
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    violations = []
    
    for item in ib.portfolio():
        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0
        
        if position_pct > max_position_pct:
            violations.append({
                'symbol': item.contract.symbol,
                'value': item.marketValue,
                'pct': position_pct,
                'limit': max_position_pct
            })
    
    if violations:
        logging.warning(f"Position concentration violations: {violations}")
    
    return violations

# Check before placing order
def place_order_with_concentration_check(ib, contract, order, max_pct=0.20):
    """Place order only if it doesn't violate concentration"""
    
    # Estimate new position value
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if ticker.ask:
        estimated_value = ticker.ask * order.totalQuantity
        
        account_values = {v.tag: float(v.value) for v in ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        # Get current position
        current_position = next(
            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),
            0
        )
        
        new_position_value = abs(current_position + estimated_value)
        new_pct = new_position_value / net_liq if net_liq > 0 else 0
        
        if new_pct > max_pct:
            logging.error(f"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%")
            ib.cancelMktData(contract)
            return None
    
    ib.cancelMktData(contract)
    return ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Correlation-Based Risk

```python
import numpy as np
import pandas as pd

def calculate_portfolio_correlation_risk(ib, lookback_days=30):
    """Calculate portfolio correlation matrix"""
    
    portfolio = ib.portfolio()
    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']
    
    # Get historical data for all positions
    price_data = {}
    
    for symbol in symbols:
        contract = Stock(symbol, 'SMART', 'USD')
        contract = ib.qualifyContracts(contract)[0]
        
        bars = ib.reqHistoricalData(
            contract,
            endDateTime='',
            durationStr=f'{lookback_days} D',
            barSizeSetting='1 day',
            whatToShow='TRADES',
            useRTH=True
        )
        
        if bars:
            price_data[symbol] = [bar.close for bar in bars]
    
    # Create DataFrame
    df = pd.DataFrame(price_data)
    
    # Calculate returns
    returns = df.pct_change().dropna()
    
    # Correlation matrix
    corr_matrix = returns.corr()
    
    # Identify highly correlated pairs
    high_corr_threshold = 0.7
    high_corr_pairs = []
    
    for i in range(len(corr_matrix.columns)):
        for j in range(i+1, len(corr_matrix.columns)):
            corr = corr_matrix.iloc[i, j]
            if abs(corr) > high_corr_threshold:
                high_corr_pairs.append({
                    'symbol1': corr_matrix.columns[i],
                    'symbol2': corr_matrix.columns[j],
                    'correlation': corr
                })
    
    if high_corr_pairs:
        logging.warning(f"High correlation detected: {high_corr_pairs}")
    
    return corr_matrix, high_corr_pairs

# Usage
corr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)
print("Portfolio Correlation Matrix:")
print(corr_matrix)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Target Allocation Rebalancer

```python
class PortfolioRebalancer:
    def __init__(self, ib):
        self.ib = ib
        
    def rebalance_to_target(self, target_allocations, tolerance=0.05):
        """
        Rebalance portfolio to target allocations
        
        Args:
            target_allocations: Dict[symbol: str, target_pct: float]
                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}
            tolerance: Rebalance threshold (0.05 = 5%)
        """
        
        # Validate target allocations
        total = sum(target_allocations.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Target allocations must sum to 1.0, got {total}")
        
        # Get current portfolio
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}
        
        # Calculate current allocations
        current_allocations = {
            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)
            for symbol, item in portfolio.items()
        }
        
        # Determine needed trades
        trades_needed = []
        
        for symbol, target_pct in target_allocations.items():
            current_pct = current_allocations.get(symbol, 0)
            diff = target_pct - current_pct
            
            if abs(diff) > tolerance:
                target_value = net_liq * target_pct
                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0
                value_change = target_value - current_value
                
                # Get current price
                contract = Stock(symbol, 'SMART', 'USD')
                contract = self.ib.qualifyContracts(contract)[0]
                
                ticker = self.ib.reqMktData(contract, '', True, False)
                self.ib.sleep(1)
                
                if ticker.last and ticker.last == ticker.last:
                    price = ticker.last
                    shares_change = int(value_change / price)
                    
                    if shares_change != 0:
                        trades_needed.append({
                            'symbol': symbol,
                            'contract': contract,
                            'current_pct': current_pct,
                            'target_pct': target_pct,
                            'shares': shares_change,
                            'action': 'BUY' if shares_change > 0 else 'SELL'
                        })
                
                self.ib.cancelMktData(contract)
        
        # Execute trades
        if not trades_needed:
            logging.info("Portfolio within tolerance. No rebalancing needed.")
            return []
        
        logging.info(f"Rebalancing {len(trades_needed)} positions...")
        placed_trades = []
        
        for trade_info in trades_needed:
            logging.info(f"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} "
                        f"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)")
            
            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))
            trade = self.ib.placeOrder(trade_info['contract'], order)
            placed_trades.append(trade)
        
        return placed_trades

# Usage
target = {
    'AAPL': 0.30,
    'GOOGL': 0.30,
    'MSFT': 0.40
}

rebalancer = PortfolioRebalancer(ib)
trades = rebalancer.rebalance_to_target(target, tolerance=0.03)

# Monitor fills
for trade in trades:
    while not trade.isDone():
        ib.sleep(1)
    print(f"{trade.contract.symbol}: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Dollar-Cost Averaging

```python
class DCAScheduler:
    def __init__(self, ib):
        self.ib = ib
        self.schedules = []
        
    def add_schedule(self, symbol, amount_per_period, frequency_days):
        """
        Add DCA schedule
        
        Args:
            symbol: Stock symbol
            amount_per_period: Dollar amount to invest
            frequency_days: Days between purchases
        """
        self.schedules.append({
            'symbol': symbol,
            'amount': amount_per_period,
            'frequency': frequency_days,
            'last_purchase': None
        })
    
    def check_and_execute(self):
        """Check if any DCA purchases are due"""
        from datetime import datetime, timedelta
        
        now = datetime.now()
        
        for schedule in self.schedules:
            last = schedule['last_purchase']
            
            # Check if purchase is due
            if last is None or (now - last).days >= schedule['frequency']:
                self.execute_dca(schedule)
                schedule['last_purchase'] = now
    
    def execute_dca(self, schedule):
        """Execute DCA purchase"""
        symbol = schedule['symbol']
        amount = schedule['amount']
        
        # Create contract
        contract = Stock(symbol, 'SMART', 'USD')
        contract = self.ib.qualifyContracts(contract)[0]
        
        # Get current price
        ticker = self.ib.reqMktData(contract, '', True, False)
        self.ib.sleep(1)
        
        if ticker.last and ticker.last == ticker.last:
            price = ticker.last
            shares = int(amount / price)
            
            if shares > 0:
                logging.info(f"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})")
                order = MarketOrder('BUY', shares)
                trade = self.ib.placeOrder(contract, order)
                return trade
        
        self.ib.cancelMktData(contract)
        return None

# Usage
dca = DCAScheduler(ib)
dca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days
dca.add_schedule('VTI', 500, 14)   # $500 every 14 days

# Run daily check
while True:
    dca.check_and_execute()
    ib.sleep(86400)  # Check daily
```

> **Note:** Single example, no duplicates found

###  Volume Profile Builder

```python
class VolumeProfile:
    def __init__(self, ib, contract, num_bins=20):
        self.ib = ib
        self.contract = contract
        self.num_bins = num_bins
        self.profile = {}
        
    def build_from_historical(self, days=1):
        """Build volume profile from historical data"""
        bars = self.ib.reqHistoricalData(
            self.contract,
            endDateTime='',
            durationStr=f'{days} D',
            barSizeSetting='5 mins',
            whatToShow='TRADES',
            useRTH=True
        )
        
        if not bars:
            return None
        
        # Get price range
        prices = [bar.close for bar in bars]
        min_price = min(prices)
        max_price = max(prices)
        
        # Create bins
        bin_size = (max_price - min_price) / self.num_bins
        
        # Accumulate volume in bins
        for bar in bars:
            bin_idx = int((bar.close - min_price) / bin_size)
            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max
            
            bin_price = min_price + (bin_idx * bin_size)
            
            if bin_price not in self.profile:
                self.profile[bin_price] = 0
            
            self.profile[bin_price] += bar.volume
        
        return self.profile
    
    def get_poc(self):
        """Get Point of Control (price with highest volume)"""
        if not self.profile:
            return None
        
        return max(self.profile.items(), key=lambda x: x[1])
    
    def get_value_area(self, percent=0.70):
        """Get value area (prices containing X% of volume)"""
        if not self.profile:
            return None
        
        total_volume = sum(self.profile.values())
        target_volume = total_volume * percent
        
        # Sort by volume
        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)
        
        accumulated_volume = 0
        value_area_prices = []
        
        for price, volume in sorted_profile:
            accumulated_volume += volume
            value_area_prices.append(price)
            
            if accumulated_volume >= target_volume:
                break
        
        return min(value_area_prices), max(value_area_prices)

# Usage
contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

vp = VolumeProfile(ib, contract, num_bins=30)
profile = vp.build_from_historical(days=5)

poc_price, poc_volume = vp.get_poc()
print(f"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume")

va_low, va_high = vp.get_value_area(percent=0.70)
print(f"Value Area: ${va_low:.2f} - ${va_high:.2f}")
```

> **Note:** Single example, no duplicates found

###  Request Queue Manager

```python
from collections import deque
import threading

class RequestQueue:
    def __init__(self, ib, max_per_second=40):
        self.ib = ib
        self.queue = deque()
        self.max_per_second = max_per_second
        self.running = False
        
    def add(self, func, *args, **kwargs):
        """Add request to queue"""
        self.queue.append((func, args, kwargs))
    
    def start(self):
        """Start processing queue"""
        self.running = True
        thread = threading.Thread(target=self._process)
        thread.daemon = True
        thread.start()
    
    def _process(self):
        """Process queue with rate limiting"""
        delay = 1.0 / self.max_per_second
        
        while self.running:
            if self.queue:
                func, args, kwargs = self.queue.popleft()
                
                try:
                    func(*args, **kwargs)
                except Exception as e:
                    logging.error(f"Request failed: {e}")
                
                time.sleep(delay)
            else:
                time.sleep(0.1)
    
    def stop(self):
        """Stop processing"""
        self.running = False

# Usage
queue = RequestQueue(ib, max_per_second=40)
queue.start()

# Queue many requests
for contract in large_contract_list:
    queue.add(ib.reqMktData, contract, '', False, False)
```

> **Note:** Single example, no duplicates found

###  Minimal Example

```python
from ib_insync import *

# Jupyter notebook? Uncomment:
# util.startLoop()

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Get account info
account = ib.managedAccounts()[0]
print(f"Connected to account: {account}")

# Create contract
contract = Stock('AAPL', 'SMART', 'USD')

# Get market data
ticker = ib.reqMktData(contract)
ib.sleep(2)  # Wait for data
print(ticker.marketPrice())

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Request Market Data (Streaming)

```python
ticker = ib.reqMktData(
    contract: Contract,
    genericTickList: str = '',
    snapshot: bool = False,
    regulatorySnapshot: bool = False,
    mktDataOptions: List = None
) -> Ticker

# Ticker auto-updates in real-time
```

> **Note:** Single example, no duplicates found

### Example:

```python
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract, genericTickList='233,236')
ib.sleep(2)
print(f"Last: {ticker.last}")
print(f"Bid: {ticker.bid}")
print(f"Ask: {ticker.ask}")
print(f"Volume: {ticker.volume}")
```

> **Note:** Single example, no duplicates found

###  Request Historical Data

```python
bars = ib.reqHistoricalData(
    contract: Contract,
    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'
    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'
    barSizeSetting: str = '1 hour',
    whatToShow: str = 'TRADES', # See below
    useRTH: bool = True,        # Regular trading hours only
    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch
    keepUpToDate: bool = False, # Auto-update
    chartOptions: List = None,
    timeout: float = 60
) -> BarDataList

# Returns BarDataList (auto-synced if keepUpToDate=True)
```

> **Note:** Single example, no duplicates found

### Duration Strings:

```python
S = Seconds (max 60)
D = Days (max 365)
W = Weeks (max 52)
M = Months (max 12)
Y = Years (max 1)
```

> **Note:** Single example, no duplicates found

### Bar Sizes:

```python
'1 secs', '5 secs', '10 secs', '15 secs', '30 secs',
'1 min', '2 mins', '3 mins', '5 mins', '10 mins', '15 mins', '20 mins', '30 mins',
'1 hour', '2 hours', '3 hours', '4 hours', '8 hours',
'1 day', '1 week', '1 month'
```

> **Note:** Single example, no duplicates found

### What to Show:

```python
'TRADES'           - Actual trades
'MIDPOINT'         - Bid/ask midpoint
'BID'              - Bid prices
'ASK'              - Ask prices
'BID_ASK'          - Bid/ask pairs
'HISTORICAL_VOLATILITY'
'OPTION_IMPLIED_VOLATILITY'
'REBATE_RATE'
'FEE_RATE'
'YIELD_BID'
'YIELD_ASK'
'YIELD_BID_ASK'
'YIELD_LAST'
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Use streaming:

```python
# For tick data
ticker = ib.reqMktData(contract, '233')  # Last, volume, vwap
ticker.updateEvent += lambda ticker: process_tick(ticker)

# For bar data
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)
```

> **Note:** Single example, no duplicates found

### ❌ BAD - Ambiguous:

```python
contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Qualified:

```python
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
ticker = ib.reqMktData(contract)
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
try:
    ticker = ib.reqMktData(contract)
    # ... do work ...
finally:
    ib.cancelMktData(contract)
    ib.disconnect()
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Built-in throttling:

```python
# ib-insync handles throttling automatically
for contract in large_list:
    ib.reqMktData(contract)
# No manual delays needed
```

> **Note:** Single example, no duplicates found

###  Pattern: Live Ticker Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        symbol = ticker.contract.symbol
        price = ticker.marketPrice()
        volume = ticker.volume
        print(f"{symbol}: ${price:.2f} | Vol: {volume}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract, '', False, False)

# Run forever
ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Historical Data Download

```python
from ib_insync import *
import pandas as pd

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Download multiple timeframes
timeframes = [
    ('1 Y', '1 day'),
    ('6 M', '1 hour'),
    ('30 D', '15 mins')
]

all_data = {}
for duration, barsize in timeframes:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime='',
        durationStr=duration,
        barSizeSetting=barsize,
        whatToShow='TRADES',
        useRTH=True
    )
    df = util.df(bars)
    all_data[f'{duration}_{barsize}'] = df
    print(f"Downloaded {len(bars)} {barsize} bars for {duration}")

# Save to files
for name, df in all_data.items():
    df.to_csv(f"{contract.symbol}_{name}.csv", index=False)

ib.disconnect()
```

> **Note:** Single example, no duplicates found

###  Pattern: Option Chain Analysis

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

# Get option chain
chains = ib.reqSecDefOptParams(
    underlying.symbol,
    '',
    underlying.secType,
    underlying.conId
)

print(f"Found {len(chains)} option chains")

# Get chain for specific exchange
chain = next(c for c in chains if c.exchange == 'SMART')
print(f"Trading class: {chain.tradingClass}")
print(f"Expirations: {sorted(chain.expirations)[:5]}")  # First 5
print(f"Strike range: {min(chain.strikes)} - {max(chain.strikes)}")

# Request contracts for specific expiration
expiration = sorted(chain.expirations)[0]
strikes = sorted([s for s in chain.strikes if 400 < s < 500])

contracts = [
    Option('SPY', expiration, strike, right, 'SMART')
    for strike in strikes[:5]
    for right in ['C', 'P']
]

# Qualify and get details
contracts = ib.qualifyContracts(*contracts)

# Request market data
for contract in contracts:
    ticker = ib.reqMktData(contract, '', False, False)
    ib.sleep(1)
    print(f"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}")

ib.disconnect()
```

> **Note:** Single example, no duplicates found

### Error 162: Historical Market Data Service error

```python
# Common causes:
# 1. Requesting too much data
# 2. Invalid date range
# 3. Contract not found
# 4. No data available for period

# Solution: Break into chunks
dt = ''
all_bars = []
while True:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime=dt,
        durationStr='30 D',
        barSizeSetting='1 hour',
        whatToShow='TRADES',
        useRTH=True
    )
    if not bars:
        break
    all_bars.extend(bars)
    dt = bars[0].date
    ib.sleep(1)  # Respect rate limits
```

> **Note:** Single example, no duplicates found


## Dataclass

### Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds).

```python
class ib_insync.contract.ContractType(**kwargs)
    [Contract Type Description]

    dict()
        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
        Return type: dict

    nonDefaults()
        For a dataclass instance get the fields that are different from the default values and return as dict.
        Return type: dict

    tuple()
        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
        Return type: tuple

    update(*srcObjs, **kwargs)
        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
        Return type: object

    comboLegs: List[ComboLeg]
```

> **Note:** Variations occur only in contract-specific descriptions: Bond = 'Bond.', MutualFund = 'Mutual fund.', Warrant = 'Warrant option.', Bag = 'Bag contract.'. Method implementations and comboLegs attribute are identical across all contract types. Minor formatting differences exist in source docs (asterisks/spacing) but don't affect functionality.


## Delayed Data

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.


## Error

### Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading.

```python
parent, takeProfit, stopLoss = BracketOrder(
    'BUY', 100, 175.0,
    takeProfitPrice=185.0,
    stopLossPrice=170.0
)

for order in (parent, takeProfit, stopLoss):
    ib.placeOrder(contract, order)
```

> **Note:** Examples show different price parameters (175/185/170 vs 150/160/145) demonstrating the pattern works with any price levels. Example 1 includes 'error' tag highlighting potential error handling considerations.

###  Position Entry with Protection

```python
# 1. Enter position
entry = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry)

# 2. Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    avg_price = entry_trade.orderStatus.avgFillPrice
    
    # 3. Set stop loss
    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop
    ib.placeOrder(contract, stop)
    
    # 4. Set take profit
    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit
    ib.placeOrder(contract, target)
```

> **Note:** Single example, no duplicates found

###  Error Handling

```python
def place_order_safe(ib, contract, order):
    try:
        trade = ib.placeOrder(contract, order)
        
        # Wait with timeout
        timeout = 10
        start = time.time()
        while trade.orderStatus.status == 'PendingSubmit':
            if time.time() - start > timeout:
                ib.cancelOrder(order)
                raise TimeoutError("Order submission timeout")
            ib.sleep(0.1)
        
        return trade
    except Exception as e:
        print(f"Order failed: {e}")
        return None
```

> **Note:** Single example, no duplicates found

### Not checking connection state: Always verify connection before state access.

```python
def get_price():
    if not ib.isConnected():
        raise ConnectionError("Not connected to IB")
    ticker = ib.reqMktData(contract)
    ib.sleep(2)
    if ticker.last:
        return ticker.last
    raise ValueError("No price data available")
```

> **Note:** Single example, no duplicates found

###  Production-ready state manager

```python
from ib_insync import *
import logging

class IBDataManager:
    """Demonstrates best practices for single source of truth pattern"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self._setup_logging()
        self._setup_events()
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _setup_events(self):
        self.ib.connectedEvent += self._on_connected
        self.ib.disconnectedEvent += self._on_disconnected
        self.ib.positionEvent += self._on_position
        self.ib.updatePortfolioEvent += self._on_portfolio
    
    def connect(self):
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info("Connected to IB")
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _on_connected(self):
        self.logger.info("Connection established")
        self.ib.reqAccountSummary()
    
    def _on_disconnected(self):
        self.logger.warning("Disconnected from IB")
    
    def _on_position(self, position):
        self.logger.info(f"Position update: {position.contract.symbol}")
    
    def _on_portfolio(self, item):
        self.logger.info(f"Portfolio update: {item.contract.symbol}")
    
    def get_current_positions(self):
        """Get current positions (always fresh from single source)"""
        if not self.ib.isConnected():
            raise ConnectionError("Not connected")
        return self.ib.positions()
    
    def get_position_for_symbol(self, symbol):
        """Get position for specific symbol"""
        for pos in self.get_current_positions():
            if pos.contract.symbol == symbol:
                return pos
        return None
```

> **Note:** Single example, no duplicates found

### Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af...

```python
# Using the helper function (recommended)
bracket = ib.bracketOrder(
    'BUY',
    quantity=100,
    limitPrice=150.00,
    takeProfitPrice=155.00,
    stopLossPrice=145.00
)

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For market entry instead of limit entry, modify the parent order:

```python
bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)
bracket[0].orderType = 'MKT'
bracket[0].lmtPrice = 0

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:

```python
contract = Forex('GBPUSD')
ib.qualifyContracts(contract)

# Place entry order
parent_order = MarketOrder('BUY', 25000)
trade = ib.placeOrder(contract, parent_order)

# Wait for fill
ib.sleep(1)
while trade.orderStatus.status != 'Filled':
    ib.waitOnUpdate()

# Calculate levels based on actual fill price
fill_price = trade.orderStatus.avgFillPrice
stop_loss_price = fill_price - 0.0015
take_profit_price = fill_price + 0.0020

# Place child orders
stop_loss_order = StopOrder('SELL', 25000, stop_loss_price)
take_profit_order = LimitOrder('SELL', 25000, take_profit_price)

ib.placeOrder(contract, stop_loss_order)
ib.placeOrder(contract, take_profit_order)
```

> **Note:** Single example, no duplicates found

### Always validate and handle qualification failures before placing orders:

```python
def validate_futures_contract(ib, contract):
    """Validate and qualify a futures contract"""
    try:
        qualified = ib.qualifyContracts(contract)
        if not qualified:
            print(f"ERROR: Contract could not be qualified")
            return None
        
        contract = qualified[0]
        print(f"✓ Qualified: {contract.localSymbol}")
        print(f"  ConId: {contract.conId}")
        print(f"  Expiry: {contract.lastTradeDateOrContractMonth}")
        return contract
    except Exception as e:
        print(f"ERROR: {e}")
        return None

# Usage
contract = Future('ES', '202506', 'CME')
validated = validate_futures_contract(ib, contract)
if validated:
    order = MarketOrder('BUY', 1)
    trade = ib.placeOrder(validated, order)
```

> **Note:** Single example, no duplicates found

### Proper shutdown procedure:

```python
def shutdown():
    # Cancel all subscriptions
    for contract in active_contracts:
        ib.cancelMktData(contract)
    
    # Allow cancellations to process
    ib.sleep(1)
    
    # Disconnect
    ib.disconnect()

try:
    ib.run()
finally:
    shutdown()
```

> **Note:** Single example, no duplicates found

###  Production-ready streaming system

```python
from ib_insync import *
import logging

logging.basicConfig(level=logging.INFO)

class TradingSystem:
    def __init__(self):
        self.ib = IB()
        self.tickers = {}
        self.active_contracts = set()
        
    def connect(self):
        self.ib.connect('127.0.0.1', 7497, clientId=1)
        self.ib.errorEvent += self.onError
        self.ib.pendingTickersEvent += self.onPendingTickers
        
    def subscribe(self, symbol):
        contract = Stock(symbol, 'SMART', 'USD')
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract, '', False, False)
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
    def onPendingTickers(self, tickers):
        for ticker in tickers:
            self.process_ticker(ticker)
            
    def process_ticker(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")
        
        # Always yield control in callbacks
        self.ib.sleep(0)
        
    def onError(self, reqId, errorCode, errorString, contract):
        logging.error(f"Error {errorCode}: {errorString}")
        
    def shutdown(self):
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
        self.ib.sleep(1)
        self.ib.disconnect()
        
    def run(self):
        try:
            self.ib.run()
        except KeyboardInterrupt:
            print("Shutting down...")
        finally:
            self.shutdown()

# Usage
if __name__ == '__main__':
    system = TradingSystem()
    system.connect()
    system.subscribe('AAPL')
    system.subscribe('GOOGL')
    system.run()
```

> **Note:** Single example, no duplicates found

### For real-time futures trading, always fully qualify your contracts to ensure proper execution:

```python
def get_qualified_futures_contract(ib, symbol, expiry, exchange):
    """Get a fully qualified futures contract ready for trading"""
    contract = Future(symbol=symbol, 
                     lastTradeDateOrContractMonth=expiry,
                     exchange=exchange)
    
    # Request complete contract details
    qualified = ib.qualifyContracts(contract)
    
    if not qualified:
        print(f"ERROR: Could not qualify {symbol} contract")
        return None
        
    # Return the fully qualified contract
    return qualified[0]

# Example usage
es_contract = get_qualified_futures_contract(ib, 'ES', '202506', 'CME')
print(f"ConId: {es_contract.conId}, LocalSymbol: {es_contract.localSymbol}")
```

> **Note:** Single example, no duplicates found

### For live futures data, proper subscription management is essential:

```python
class FuturesDataManager:
    """Manage real-time data for multiple futures contracts"""
    
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.active_contracts = set()
        
    def subscribe(self, symbol, exchange='CME'):
        """Subscribe to real-time market data for a futures contract"""
        # Get front month contract
        contract = get_front_month_contract(self.ib, symbol, exchange)
        
        if not contract:
            print(f"Error: Could not find front month contract for {symbol}")
            return None
            
        # Request market data
        ticker = self.ib.reqMktData(contract, '', False, False)
        
        # Store references
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
        return ticker
        
    def get_price(self, symbol):
        """Get current price for a subscribed symbol"""
        if symbol not in self.tickers:
            return None
            
        ticker = self.tickers[symbol]
        
        # Use last or midpoint price
        if ticker.last:
            return ticker.last
        elif ticker.bid and ticker.ask:
            return (ticker.bid + ticker.ask) / 2
        else:
            return None
    
    def get_contracts_expiring_soon(self, days_threshold=10):
        """Get list of contracts expiring soon"""
        expiring_soon = []
        now = datetime.now()
        
        for contract in self.active_contracts:
            expiry_str = contract.lastTradeDateOrContractMonth
            
            if len(expiry_str) == 8:  # YYYYMMDD format
                expiry = datetime.strptime(expiry_str, '%Y%m%d')
            else:  # YYYYMM format
                expiry = datetime.strptime(f"{expiry_str}01", '%Y%m%d')
                
            days_to_expiry = (expiry - now).days
            
            if days_to_expiry <= days_threshold:
                expiring_soon.append((contract, days_to_expiry))
                
        return expiring_soon
        
    def cleanup(self):
        """Unsubscribe from all market data"""
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
            
        self.tickers.clear()
        self.active_contracts.clear()
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### 
Order

```python
#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',
totalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =
1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:
str = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',
ocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,
blockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,
triggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,
goodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:
bool = False, minQty: int = 2147483647, percentOffset: float =
1.7976931348623157e+308, overridePercentageConstraints: bool = False,
trailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =
1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str
= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',
origin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:
float = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,
nbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool
= False, auctionStrategy: int = 0, startingPrice: float =
1.7976931348623157e+308, stockRefPrice: float =
1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,
stockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float
= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:
bool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int
= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =
1.7976931348623157e+308, deltaNeutralConId: int = 0,
deltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',
deltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',
deltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,
deltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,
referencePriceType: int = 2147483647, basisPoints: float =
1.7976931348623157e+308, basisPointsType: int = 2147483647,
scaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,
scalePriceIncrement: float = 1.7976931348623157e+308,
scalePriceAdjustValue: float = 1.7976931348623157e+308,
scalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =
1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:
int = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:
bool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',
account: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:
str = '', algoStrategy: str = '', algoParams:
~typing.List[~ib_insync.contract.TagValue] = <factory>,
smartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =
<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,
solicited: bool = False, modelCode: str = '', orderComboLegs:
~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,
orderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,
referenceContractId: int = 0, peggedChangeAmount: float = 0.0,
isPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float
= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:
float = 1.7976931348623157e+308, adjustedStopPrice: float =
1.7976931348623157e+308, adjustedStopLimitPrice: float =
1.7976931348623157e+308, adjustedTrailingAmount: float =
1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:
float = 1.7976931348623157e+308, conditions:
~typing.List[~ib_insync.order.OrderCondition] = <factory>,
conditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,
extOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =
<factory>, cashQty: float = 1.7976931348623157e+308,
mifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',
mifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',
dontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,

Order for trading contracts.
https://interactivebrokers.github.io/tws-api/available_orders.html
orderId: int = 0
clientId: int = 0
permId: int = 0
action: str = ''
totalQuantity: float = 0.0
orderType: str = ''
lmtPrice: float = 1.7976931348623157e+308
auxPrice: float = 1.7976931348623157e+308
tif: str = ''
activeStartTime: str = ''
activeStopTime: str = ''
ocaGroup: str = ''
ocaType: int = 0
orderRef: str = ''
transmit: bool = True
parentId: int = 0
blockOrder: bool = False
sweepToFill: bool = False
displaySize: int = 0
triggerMethod: int = 0
outsideRth: bool = False
hidden: bool = False
goodAfterTime: str = ''
goodTillDate: str = ''
rule80A: str = ''
allOrNone: bool = False
minQty: int = 2147483647
percentOffset: float = 1.7976931348623157e+308
overridePercentageConstraints: bool = False
trailStopPrice: float = 1.7976931348623157e+308
trailingPercent: float = 1.7976931348623157e+308
faGroup: str = ''
faProfile: str = ''
faMethod: str = ''
faPercentage: str = ''
designatedLocation: str = ''
openClose: str = 'O'
origin: int = 0
shortSaleSlot: int = 0
exemptCode: int = -1
discretionaryAmt: float = 0.0
eTradeOnly: bool = False
firmQuoteOnly: bool = False
nbboPriceCap: float = 1.7976931348623157e+308
optOutSmartRouting: bool = False
auctionStrategy: int = 0
startingPrice: float = 1.7976931348623157e+308
stockRefPrice: float = 1.7976931348623157e+308
delta: float = 1.7976931348623157e+308
stockRangeLower: float = 1.7976931348623157e+308
stockRangeUpper: float = 1.7976931348623157e+308
randomizePrice: bool = False
randomizeSize: bool = False
volatility: float = 1.7976931348623157e+308
volatilityType: int = 2147483647
deltaNeutralOrderType: str = ''
deltaNeutralAuxPrice: float = 1.7976931348623157e+308
deltaNeutralConId: int = 0
deltaNeutralSettlingFirm: str = ''
deltaNeutralClearingAccount: str = ''
deltaNeutralClearingIntent: str = ''
deltaNeutralOpenClose: str = ''
deltaNeutralShortSale: bool = False
deltaNeutralShortSaleSlot: int = 0
deltaNeutralDesignatedLocation: str = ''
continuousUpdate: bool = False
referencePriceType: int = 2147483647
basisPoints: float = 1.7976931348623157e+308
basisPointsType: int = 2147483647
scaleInitLevelSize: int = 2147483647
scaleSubsLevelSize: int = 2147483647
scalePriceIncrement: float = 1.7976931348623157e+308
scalePriceAdjustValue: float = 1.7976931348623157e+308
scalePriceAdjustInterval: int = 2147483647
scaleProfitOffset: float = 1.7976931348623157e+308
scaleAutoReset: bool = False
scaleInitPosition: int = 2147483647
scaleInitFillQty: int = 2147483647
scaleRandomPercent: bool = False
scaleTable: str = ''
hedgeType: str = ''
hedgeParam: str = ''
account: str = ''
settlingFirm: str = ''
clearingAccount: str = ''
clearingIntent: str = ''
algoStrategy: str = ''
algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
algoId: str = ''
whatIf: bool = False
notHeld: bool = False
solicited: bool = False
modelCode: str = ''
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
referenceContractId: int = 0
peggedChangeAmount: float = 0.0
isPeggedChangeAmountDecrease: bool = False
referenceChangeAmount: float = 0.0
referenceExchangeId: str = ''
adjustedOrderType: str = ''
triggerPrice: float = 1.7976931348623157e+308
adjustedStopPrice: float = 1.7976931348623157e+308
adjustedStopLimitPrice: float = 1.7976931348623157e+308
adjustedTrailingAmount: float = 1.7976931348623157e+308
adjustableTrailingUnit: int = 0
lmtPriceOffset: float = 1.7976931348623157e+308
conditions: List[OrderCondition]
conditionsCancelOrder: bool = False
conditionsIgnoreRth: bool = False
extOperator: str = ''
softDollarTier: SoftDollarTier
cashQty: float = 1.7976931348623157e+308
mifid2DecisionMaker: str = ''
mifid2DecisionAlgo: str = ''
mifid2ExecutionTrader: str = ''
mifid2ExecutionAlgo: str = ''
dontUseAutoPriceForHedge: bool = False
isOmsContainer: bool = False
discretionaryUpToLimitPrice: bool = False
autoCancelDate: str = ''
filledQuantity: float = 1.7976931348623157e+308
refFuturesConId: int = 0
autoCancelParent: bool = False
shareholder: str = ''
imbalanceOnly: bool = False
routeMarketableToBbo: bool = False
parentPermId: int = 0
usePriceMgmtAlgo: bool = False
duration: int = 2147483647
postToAts: int = 2147483647
advancedErrorOverride: str = ''
manualOrderTime: str = ''
minTradeQty: int = 2147483647
minCompeteSize: int = 2147483647
competeAgainstBestOffset: float = 1.7976931348623157e+308
midOffsetAtWhole: float = 1.7976931348623157e+308
midOffsetAtHalf: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)
dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =
0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,
lastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',
mktCapPrice: float = 0.0)

orderId: int = 0
status: str = ''
filled: float = 0.0
remaining: float = 0.0
avgFillPrice: float = 0.0
permId: int = 0
parentId: int = 0
lastFillPrice: float = 0.0
clientId: int = 0
whyHeld: str = ''
mktCapPrice: float = 0.0
PendingSubmit: ClassVar[str] = 'PendingSubmit'
PendingCancel: ClassVar[str] = 'PendingCancel'
PreSubmitted: ClassVar[str] = 'PreSubmitted'
Submitted: ClassVar[str] = 'Submitted'
ApiPending: ClassVar[str] = 'ApiPending'
ApiCancelled: ClassVar[str] = 'ApiCancelled'
Cancelled: ClassVar[str] = 'Cancelled'
Filled: ClassVar[str] = 'Filled'
Inactive: ClassVar[str] = 'Inactive'
DoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}
ActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',
'Submitted'}

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',
equityWithLoanBefore: str = '', initMarginChange: str = '',
maintMarginChange: str = '', equityWithLoanChange: str = '',
initMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:
str = '', commission: float = 1.7976931348623157e+308,
minCommission: float = 1.7976931348623157e+308, maxCommission:
float = 1.7976931348623157e+308, commissionCurrency: str = '',
warningText: str = '', completedTime: str = '', completedStatus: str = '')

status: str = ''
initMarginBefore: str = ''
maintMarginBefore: str = ''
equityWithLoanBefore: str = ''
initMarginChange: str = ''
maintMarginChange: str = ''
equityWithLoanChange: str = ''
initMarginAfter: str = ''
maintMarginAfter: str = ''
equityWithLoanAfter: str = ''
commission: float = 1.7976931348623157e+308
minCommission: float = 1.7976931348623157e+308
maxCommission: float = 1.7976931348623157e+308
commissionCurrency: str = ''
warningText: str = ''
completedTime: str = ''
completedStatus: str = ''
dict()

Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)

price: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:
~ib_insync.order.Order = <factory>, orderStatus:
~ib_insync.order.OrderStatus = <factory>, fills:
~typing.List[~ib_insync.objects.Fill] = <factory>, log:
~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:
str = '')
Trade keeps track of an order, its status and all its fills.
Events:
-statusEvent (trade: Trade)
-modifyEvent (trade: Trade)
-fillEvent (trade: Trade, fill: Fill)
-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)
-filledEvent (trade: Trade)
-cancelEvent (trade: Trade)
-cancelledEvent (trade: Trade)
events: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',
'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')
contract: Contract
order: Order
orderStatus: OrderStatus
fills: List[Fill]
log: List[TradeLogEntry]
advancedError: str = ''
isActive()
True if eligible for execution, false otherwise.
isDone()
True if completely filled or cancelled, false otherwise.
filled()
Number of shares filled.
remaining()
Number of shares remaining to be filled.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)
Create new instance of BracketOrder(parent, takeProfit, stopLoss)
property parent
property takeProfit
property stopLoss

#### class ib_insync.order.OrderCondition
static createClass(condType)
And()
Or()

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,
price: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =
0)
condType: int = 1
conjunction: str = 'a'
isMore: bool = True
price: float = 0.0
conId: int = 0
exch: str = ''
triggerMethod: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:
str = '')
condType: int = 3
conjunction: str = 'a'
isMore: bool = True
time: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,
percent: int = 0)
condType: int = 4
conjunction: str = 'a'
isMore: bool = True
percent: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',
exch: str = '', symbol: str = '')
condType: int = 5
conjunction: str = 'a'
secType: str = ''
exch: str = ''
symbol: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,
volume: int = 0, conId: int = 0, exch: str = '')
condType: int = 6
conjunction: str = 'a'
isMore: bool = True
volume: int = 0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =
True, changePercent: float = 0.0, conId: int = 0, exch: str
= '')
condType: int = 7
conjunction: str = 'a'
isMore: bool = True
changePercent: float = 0.0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

onDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
```

> **Note:** Single example, no duplicates found

###  Integration with Tkinter

```python
class TkApp:
    """
    Example of integrating with Tkinter.
    """
    def __init__(self):
        self.ib = IB().connect()
        self.root = tk.Tk()
        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)
        self.entry = tk.Entry(self.root, width=50)
        self.entry.insert(0, "Stock('TSLA', 'SMART', 'USD')")
        self.entry.grid()
        self.button = tk.Button(
            self.root, text='Get details', command=self.onButtonClick)
        self.button.grid()
        self.text = tk.Text(self.root)
        self.text.grid()
        self.loop = util.getLoop()

    def onButtonClick(self):
        contract = eval(self.entry.get())
        cds = self.ib.reqContractDetails(contract)
        self.text.delete(1.0, tk.END)
        self.text.insert(tk.END, str(cds))

    def run(self):
        self._onTimeout()
        self.loop.run_forever()

    def _onTimeout(self):
        self.root.update()
        self.loop.call_later(0.03, self._onTimeout)

    def _onDeleteWindow(self):
        self.loop.stop()


app = TkApp()
app.run()
```

> **Note:** Single example, no duplicates found

###  Multiple Exits from Same Entry

```python
# Buy at market, then set multiple exit strategies
entry_order = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry_order)

# Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    # Create OCA group for exits
    oca_group = f"OCA_{int(time.time())}"
    
    # Exit 1: Take profit at +5%
    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)
    exit1.ocaGroup = oca_group
    exit1.ocaType = 1  # Cancel all on fill
    
    # Exit 2: Stop loss at -2%
    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)
    exit2.ocaGroup = oca_group
    exit2.ocaType = 1
    
    # Exit 3: Trailing stop
    exit3 = Order()
    exit3.action = 'SELL'
    exit3.totalQuantity = 100
    exit3.orderType = 'TRAIL'
    exit3.trailingPercent = 3.0
    exit3.ocaGroup = oca_group
    exit3.ocaType = 1
    
    for order in [exit1, exit2, exit3]:
        ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Comprehensive Error Handler

```python
from ib_insync import *
import logging

class IBErrorHandler:
    def __init__(self, ib):
        self.ib = ib
        self.error_log = []
        self.ib.errorEvent += self.on_error
        
    def on_error(self, reqId, errorCode, errorString, contract):
        """Centralized error handling"""
        error_info = {
            'time': datetime.now(),
            'reqId': reqId,
            'code': errorCode,
            'message': errorString,
            'contract': contract
        }
        self.error_log.append(error_info)
        
        # Categorize and handle
        if errorCode in [502, 503, 504]:
            self.handle_connection_error(errorCode, errorString)
        elif errorCode in [200, 201, 202]:
            self.handle_order_error(errorCode, errorString, contract)
        elif errorCode == 162:
            self.handle_data_error(errorCode, errorString, contract)
        elif errorCode == 354:
            self.handle_market_data_subscription_error(errorCode, errorString)
        elif errorCode in [2104, 2106, 2158]:
            # Info messages - ignore
            pass
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def handle_connection_error(self, code, message):
        """Handle connection failures"""
        logging.critical(f"Connection error {code}: {message}")
        # Trigger reconnection
        self.schedule_reconnect()
    
    def handle_order_error(self, code, message, contract):
        """Handle order rejections"""
        logging.error(f"Order error {code}: {message} for {contract}")
        # Could retry with modified params
        # Or alert user
    
    def handle_data_error(self, code, message, contract):
        """Handle data request failures"""
        logging.warning(f"Data error {code}: {message} for {contract}")
        # Retry with different params
    
    def handle_market_data_subscription_error(self, code, message):
        """Handle market data subscription issues"""
        logging.warning(f"Market data error {code}: {message}")
        # Fall back to delayed data
        self.ib.reqMarketDataType(3)  # Delayed
    
    def schedule_reconnect(self):
        """Schedule reconnection attempt"""
        # Implementation in reconnection section
        pass

# Usage
ib = IB()
error_handler = IBErrorHandler(ib)
ib.connect('127.0.0.1', 7497, clientId=1)
```

> **Note:** Single example, no duplicates found

###  Order Validation Before Submission

```python
def validate_order(ib, contract, order):
    """Validate order before placing"""
    errors = []
    
    # 1. Check contract is qualified
    if contract.conId == 0:
        errors.append("Contract not qualified")
    
    # 2. Check buying power
    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}
    
    if order.action == 'BUY':
        # Estimate cost
        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot
        ib.sleep(1)
        
        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN
            estimated_cost = ticker.ask * order.totalQuantity
            if estimated_cost > account_values.get('BuyingPower', 0):
                errors.append(f"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}")
        
        ib.cancelMktData(contract)
    
    # 3. What-if order check
    try:
        order_copy = Order(**{k: v for k, v in order.__dict__.items()})
        order_copy.whatIf = True
        
        orderState = ib.whatIfOrder(contract, order_copy)
        
        if orderState.commission and orderState.commission > 0:
            # Valid response
            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):
                errors.append("Insufficient margin")
        else:
            errors.append("What-if order returned invalid state")
            
    except Exception as e:
        errors.append(f"What-if validation failed: {e}")
    
    # 4. Check trading hours
    details = ib.reqContractDetails(contract)
    if details:
        # Parse trading hours (simplified)
        # Would need full implementation
        pass
    
    return errors

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
order = LimitOrder('BUY', 1000, 175.0)

validation_errors = validate_order(ib, contract, order)
if validation_errors:
    print("Order validation failed:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    trade = ib.placeOrder(contract, order)
    print("Order placed successfully")
```

> **Note:** Single example, no duplicates found

###  Retry Logic with Exponential Backoff

```python
import time
from functools import wraps

def retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):
    """Decorator for retrying failed operations"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            delay = base_delay
            
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    retries += 1
                    if retries >= max_retries:
                        logging.error(f"{func.__name__} failed after {max_retries} retries: {e}")
                        raise
                    
                    logging.warning(f"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...")
                    time.sleep(delay)
                    delay = min(delay * 2, max_delay)  # Exponential backoff
            
        return wrapper
    return decorator

# Usage
@retry_with_backoff(max_retries=3, base_delay=2.0)
def place_order_with_retry(ib, contract, order):
    """Place order with automatic retry"""
    trade = ib.placeOrder(contract, order)
    
    # Wait for submission
    timeout = 10
    start = time.time()
    while trade.orderStatus.status in ['PendingSubmit', '']:
        if time.time() - start > timeout:
            raise TimeoutError("Order submission timeout")
        ib.sleep(0.1)
    
    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:
        raise Exception(f"Order cancelled: {trade.orderStatus.status}")
    
    return trade

# Usage
try:
    trade = place_order_with_retry(ib, contract, order)
    print(f"Order placed: {trade.order.orderId}")
except Exception as e:
    print(f"Order failed: {e}")
```

> **Note:** Single example, no duplicates found

###  Close All Positions

```python
def close_all_positions(ib, exclude_symbols=None):
    """Emergency position closer"""
    exclude_symbols = exclude_symbols or []
    
    positions = ib.positions()
    trades = []
    
    for position in positions:
        symbol = position.contract.symbol
        
        if symbol in exclude_symbols:
            continue
        
        qty = abs(position.position)
        action = 'SELL' if position.position > 0 else 'BUY'
        
        order = MarketOrder(action, qty)
        trade = ib.placeOrder(position.contract, order)
        trades.append(trade)
        
        print(f"Closing {action} {qty} {symbol}")
    
    # Wait for all to fill
    timeout = 30
    start = time.time()
    
    while any(not t.isDone() for t in trades):
        if time.time() - start > timeout:
            logging.error("Timeout waiting for position closures")
            break
        ib.sleep(0.5)
    
    return trades

# Usage - emergency exit
if emergency_condition:
    close_all_positions(ib)
```

> **Note:** Single example, no duplicates found

###  Position Size Calculator

```python
def calculate_position_size(
    ib,
    contract,
    risk_per_trade_pct=0.02,  # 2% risk
    stop_loss_pct=0.05         # 5% stop
):
    """Calculate position size based on risk"""
    
    # Get account value
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    # Calculate dollar risk
    dollar_risk = net_liq * risk_per_trade_pct
    
    # Get current price
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if not ticker.last or ticker.last != ticker.last:  # NaN check
        logging.error("Unable to get price for position sizing")
        return 0
    
    price = ticker.last
    ib.cancelMktData(contract)
    
    # Calculate shares
    # dollar_risk = shares * price * stop_loss_pct
    shares = dollar_risk / (price * stop_loss_pct)
    
    # Round to nearest tradeable lot
    if contract.secType == 'OPT':
        shares = int(shares / 100) * 100  # Options in contracts (100 shares)
    else:
        shares = int(shares)
    
    print(f"Position size for {contract.symbol}: {shares} shares")
    print(f"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})")
    
    return shares

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

shares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)

if shares > 0:
    order = LimitOrder('BUY', shares, 175.0)
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Max Position Concentration

```python
def check_position_concentration(ib, max_position_pct=0.20):
    """Ensure no single position exceeds % of portfolio"""
    
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    violations = []
    
    for item in ib.portfolio():
        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0
        
        if position_pct > max_position_pct:
            violations.append({
                'symbol': item.contract.symbol,
                'value': item.marketValue,
                'pct': position_pct,
                'limit': max_position_pct
            })
    
    if violations:
        logging.warning(f"Position concentration violations: {violations}")
    
    return violations

# Check before placing order
def place_order_with_concentration_check(ib, contract, order, max_pct=0.20):
    """Place order only if it doesn't violate concentration"""
    
    # Estimate new position value
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if ticker.ask:
        estimated_value = ticker.ask * order.totalQuantity
        
        account_values = {v.tag: float(v.value) for v in ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        # Get current position
        current_position = next(
            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),
            0
        )
        
        new_position_value = abs(current_position + estimated_value)
        new_pct = new_position_value / net_liq if net_liq > 0 else 0
        
        if new_pct > max_pct:
            logging.error(f"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%")
            ib.cancelMktData(contract)
            return None
    
    ib.cancelMktData(contract)
    return ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Heartbeat Monitor

```python
class HeartbeatMonitor:
    def __init__(self, ib, timeout=60):
        self.ib = ib
        self.timeout = timeout
        self.last_update = time.time()
        self.ib.updateEvent += self.on_update
        
    def on_update(self):
        """Reset timer on any update"""
        self.last_update = time.time()
    
    def check(self):
        """Check if connection is alive"""
        elapsed = time.time() - self.last_update
        
        if elapsed > self.timeout:
            logging.warning(f"No updates for {elapsed:.0f}s. Connection may be dead.")
            return False
        
        return True
    
    def run(self):
        """Run heartbeat check loop"""
        while True:
            if not self.check():
                logging.error("Heartbeat timeout. Triggering reconnect...")
                # Trigger reconnection
                break
            
            time.sleep(10)

# Usage
heartbeat = HeartbeatMonitor(ib, timeout=60)
# Run in separate thread or async task
```

> **Note:** Single example, no duplicates found

###  Target Allocation Rebalancer

```python
class PortfolioRebalancer:
    def __init__(self, ib):
        self.ib = ib
        
    def rebalance_to_target(self, target_allocations, tolerance=0.05):
        """
        Rebalance portfolio to target allocations
        
        Args:
            target_allocations: Dict[symbol: str, target_pct: float]
                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}
            tolerance: Rebalance threshold (0.05 = 5%)
        """
        
        # Validate target allocations
        total = sum(target_allocations.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Target allocations must sum to 1.0, got {total}")
        
        # Get current portfolio
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}
        
        # Calculate current allocations
        current_allocations = {
            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)
            for symbol, item in portfolio.items()
        }
        
        # Determine needed trades
        trades_needed = []
        
        for symbol, target_pct in target_allocations.items():
            current_pct = current_allocations.get(symbol, 0)
            diff = target_pct - current_pct
            
            if abs(diff) > tolerance:
                target_value = net_liq * target_pct
                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0
                value_change = target_value - current_value
                
                # Get current price
                contract = Stock(symbol, 'SMART', 'USD')
                contract = self.ib.qualifyContracts(contract)[0]
                
                ticker = self.ib.reqMktData(contract, '', True, False)
                self.ib.sleep(1)
                
                if ticker.last and ticker.last == ticker.last:
                    price = ticker.last
                    shares_change = int(value_change / price)
                    
                    if shares_change != 0:
                        trades_needed.append({
                            'symbol': symbol,
                            'contract': contract,
                            'current_pct': current_pct,
                            'target_pct': target_pct,
                            'shares': shares_change,
                            'action': 'BUY' if shares_change > 0 else 'SELL'
                        })
                
                self.ib.cancelMktData(contract)
        
        # Execute trades
        if not trades_needed:
            logging.info("Portfolio within tolerance. No rebalancing needed.")
            return []
        
        logging.info(f"Rebalancing {len(trades_needed)} positions...")
        placed_trades = []
        
        for trade_info in trades_needed:
            logging.info(f"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} "
                        f"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)")
            
            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))
            trade = self.ib.placeOrder(trade_info['contract'], order)
            placed_trades.append(trade)
        
        return placed_trades

# Usage
target = {
    'AAPL': 0.30,
    'GOOGL': 0.30,
    'MSFT': 0.40
}

rebalancer = PortfolioRebalancer(ib)
trades = rebalancer.rebalance_to_target(target, tolerance=0.03)

# Monitor fills
for trade in trades:
    while not trade.isDone():
        ib.sleep(1)
    print(f"{trade.contract.symbol}: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Multi-Account Order Router

```python
class MultiAccountRouter:
    def __init__(self, host='127.0.0.1', port=7497):
        self.connections = {}
        self.host = host
        self.port = port
        
    def add_account(self, account_name, client_id):
        """Add account connection"""
        ib = IB()
        ib.connect(self.host, self.port, client_id)
        self.connections[account_name] = ib
        logging.info(f"Connected account {account_name} with clientId {client_id}")
    
    def place_order_all(self, contract, order_template, quantities):
        """
        Place orders across multiple accounts
        
        Args:
            contract: Contract to trade
            order_template: Base order
            quantities: Dict[account_name, quantity]
        """
        trades = {}
        
        for account_name, quantity in quantities.items():
            if account_name not in self.connections:
                logging.error(f"Account {account_name} not connected")
                continue
            
            ib = self.connections[account_name]
            
            # Clone order
            order = Order(**{k: v for k, v in order_template.__dict__.items()})
            order.totalQuantity = quantity
            order.account = account_name
            
            # Place order
            trade = ib.placeOrder(contract, order)
            trades[account_name] = trade
            
            logging.info(f"Placed {order.action} {quantity} {contract.symbol} for {account_name}")
        
        return trades
    
    def get_combined_portfolio(self):
        """Get combined portfolio across all accounts"""
        combined = {}
        
        for account_name, ib in self.connections.items():
            for item in ib.portfolio():
                symbol = item.contract.symbol
                
                if symbol not in combined:
                    combined[symbol] = {
                        'position': 0,
                        'market_value': 0,
                        'unrealized_pnl': 0,
                        'accounts': {}
                    }
                
                combined[symbol]['position'] += item.position
                combined[symbol]['market_value'] += item.marketValue
                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL
                combined[symbol]['accounts'][account_name] = item.position
        
        return combined
    
    def disconnect_all(self):
        """Disconnect all accounts"""
        for account_name, ib in self.connections.items():
            ib.disconnect()
            logging.info(f"Disconnected {account_name}")

# Usage
router = MultiAccountRouter()
router.add_account('Account1', client_id=1)
router.add_account('Account2', client_id=2)
router.add_account('Account3', client_id=3)

# Place order across all accounts
contract = Stock('AAPL', 'SMART', 'USD')
order_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account

quantities = {
    'Account1': 100,
    'Account2': 200,
    'Account3': 150
}

trades = router.place_order_all(contract, order_template, quantities)

# Monitor combined portfolio
combined = router.get_combined_portfolio()
for symbol, data in combined.items():
    print(f"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts")
```

> **Note:** Single example, no duplicates found

###  Batch Contract Qualification

```python
def qualify_contracts_batch(ib, contracts, batch_size=50):
    """Qualify contracts in batches to avoid rate limits"""
    qualified = []
    
    for i in range(0, len(contracts), batch_size):
        batch = contracts[i:i+batch_size]
        
        try:
            qualified_batch = ib.qualifyContracts(*batch)
            qualified.extend(qualified_batch)
        except Exception as e:
            logging.error(f"Batch qualification failed: {e}")
        
        # Respect rate limits
        ib.sleep(1)
    
    return qualified
```

> **Note:** Single example, no duplicates found

###  Request Queue Manager

```python
from collections import deque
import threading

class RequestQueue:
    def __init__(self, ib, max_per_second=40):
        self.ib = ib
        self.queue = deque()
        self.max_per_second = max_per_second
        self.running = False
        
    def add(self, func, *args, **kwargs):
        """Add request to queue"""
        self.queue.append((func, args, kwargs))
    
    def start(self):
        """Start processing queue"""
        self.running = True
        thread = threading.Thread(target=self._process)
        thread.daemon = True
        thread.start()
    
    def _process(self):
        """Process queue with rate limiting"""
        delay = 1.0 / self.max_per_second
        
        while self.running:
            if self.queue:
                func, args, kwargs = self.queue.popleft()
                
                try:
                    func(*args, **kwargs)
                except Exception as e:
                    logging.error(f"Request failed: {e}")
                
                time.sleep(delay)
            else:
                time.sleep(0.1)
    
    def stop(self):
        """Stop processing"""
        self.running = False

# Usage
queue = RequestQueue(ib, max_per_second=40)
queue.start()

# Queue many requests
for contract in large_contract_list:
    queue.add(ib.reqMktData, contract, '', False, False)
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Class Attributes

```python
RequestTimeout: float = 0        # Request timeout (0 = infinite)
RaiseRequestErrors: bool = False # Raise errors vs silent fail
MaxSyncedSubAccounts: int = 50   # Max sub-accounts to sync
```

> **Note:** Single example, no duplicates found

###  Events

```python
events = (
    'connectedEvent',       # Connection established
    'disconnectedEvent',    # Connection lost
    'updateEvent',          # Any state update
    'pendingTickersEvent',  # Ticker updates available
    'barUpdateEvent',       # Real-time bar update
    'newOrderEvent',        # New order created
    'orderModifyEvent',     # Order modified
    'cancelOrderEvent',     # Order cancel requested
    'openOrderEvent',       # Open order status
    'orderStatusEvent',     # Order status changed
    'execDetailsEvent',     # Trade execution details
    'commissionReportEvent',# Commission report
    'updatePortfolioEvent', # Portfolio updated
    'positionEvent',        # Position changed
    'accountValueEvent',    # Account value updated
    'accountSummaryEvent',  # Account summary updated
    'pnlEvent',            # PnL update
    'pnlSingleEvent',      # Single position PnL
    'scannerDataEvent',    # Scanner data received
    'tickNewsEvent',       # News tick
    'newsBulletinEvent',   # News bulletin
    'errorEvent',          # Error occurred
    'timeoutEvent'         # Request timeout
)
```

> **Note:** Single example, no duplicates found

###  Connect (Blocking)

```python
ib.connect(
    host: str = '127.0.0.1',
    port: int = 7497,           # 7497=TWS, 4001=Gateway
    clientId: int = 1,          # Unique per connection
    timeout: float = 2.0,       # Connection timeout (0=no limit)
    readonly: bool = False,     # Read-only mode
    account: str = '',          # Main account for updates
    raiseSyncErrors: bool = True # Raise sync errors
) -> None
```

> **Note:** Single example, no duplicates found

###  Connect (Async)

```python
await ib.connectAsync(
    host, port, clientId, 
    timeout, readonly, account, raiseSyncErrors
) -> None
```

> **Note:** Single example, no duplicates found

###  Contract Details

```python
details = ib.reqContractDetails(contract)
# Returns List[ContractDetails]

# ContractDetails fields:
# .contract - Fully qualified contract
# .marketName
# .minTick
# .priceMagnifier
# .orderTypes
# .validExchanges
# .underConId
# .longName
# .contractMonth
# .industry
# .category
# .subcategory
# .timeZoneId
# .tradingHours
# .liquidHours
# And many more...
```

> **Note:** Single example, no duplicates found

###  Trade Object

```python
@dataclass
class Trade:
    contract: Contract = None
    order: Order = None
    orderStatus: OrderStatus = None
    fills: List[Fill] = []
    log: List[TradeLogEntry] = []
    
    # Methods
    def isActive(self) -> bool
    def isDone(self) -> bool
    def filled(self) -> float
    def remaining(self) -> float
```

> **Note:** Single example, no duplicates found

### The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis.

```python
orderState = ib.whatIfOrder(contract, order)
# Test order without placing
# Returns OrderState with commission/margin impact

# OrderState fields:
# .initMarginBefore
# .maintMarginBefore
# .equityWithLoanBefore
# .initMarginAfter
# .maintMarginAfter
# .equityWithLoanAfter
# .commission
# .minCommission
# .maxCommission
# .commissionCurrency
```

> **Note:** Example 1 focuses on field structure while Example 2 emphasizes debugging order rejections. Both agree on core usage but Example 2 adds error context and debugging practices.

###  Connection Events

```python
# Connected
ib.connectedEvent += lambda: print('Connected to TWS')

# Disconnected
ib.disconnectedEvent += lambda: print('Disconnected')

# Error
ib.errorEvent += lambda reqId, errorCode, errorString, contract: \
    print(f'Error {errorCode}: {errorString}')
```

> **Note:** Single example, no duplicates found

### Warnings (informational):

```python
2104 - Market data farm connection OK
2106 - Historical data farm connection OK
2158 - Sec-def data farm connection OK
```

> **Note:** Single example, no duplicates found

### Errors:

```python
200 - No security definition found
201 - Order rejected
202 - Order cancelled
321 - Error validating request
326 - Unable to connect (check port)
354 - Requested market data not subscribed
404 - Order held
502 - Couldn't connect to TWS
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
def on_error(reqId, errorCode, errorString, contract):
    if errorCode == 200:
        print(f"Contract not found: {contract}")
    elif errorCode == 321:
        print(f"Validation error: {errorString}")
    # Handle other errors...

ib.errorEvent += on_error
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
try:
    ticker = ib.reqMktData(contract)
    # ... do work ...
finally:
    ib.cancelMktData(contract)
    ib.disconnect()
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
ib = IB()
ib.RequestTimeout = 30  # 30 second timeout
ib.RaiseRequestErrors = True  # Raise exceptions

try:
    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)
except asyncio.TimeoutError:
    print("Connection timeout!")
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

### Error 502: Couldn't connect to TWS

```python
# Solutions:
# 1. Check TWS/Gateway is running
# 2. Check correct port (7497=TWS, 4001=Gateway)
# 3. Enable API in TWS settings
# 4. Check firewall
# 5. Verify clientId is unique

# Test connection
import socket
sock = socket.socket()
try:
    sock.connect(('127.0.0.1', 7497))
    print("Port is open")
except:
    print("Cannot connect to port")
finally:
    sock.close()
```

> **Note:** Single example, no duplicates found

### Error 326: Unable to connect

```python
# Check API settings in TWS:
# Configuration -> API -> Settings
# - Enable ActiveX and Socket Clients
# - Socket port: 7497 (TWS) or 4001 (Gateway)
# - Trusted IPs: 127.0.0.1
# - Master API client ID: (optional)
```

> **Note:** Single example, no duplicates found

### Error 162: Historical Market Data Service error

```python
# Common causes:
# 1. Requesting too much data
# 2. Invalid date range
# 3. Contract not found
# 4. No data available for period

# Solution: Break into chunks
dt = ''
all_bars = []
while True:
    bars = ib.reqHistoricalData(
        contract,
        endDateTime=dt,
        durationStr='30 D',
        barSizeSetting='1 hour',
        whatToShow='TRADES',
        useRTH=True
    )
    if not bars:
        break
    all_bars.extend(bars)
    dt = bars[0].date
    ib.sleep(1)  # Respect rate limits
```

> **Note:** Single example, no duplicates found


## Error Handling

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.


## Event

###  Monitor Status

```python
def on_order_status(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")

ib.orderStatusEvent += on_order_status
```

> **Note:** Single example, no duplicates found

### Demonstrates incorrect pattern of repeatedly polling historical data in a blocking loop. This approach violates API best practices by 1) Using historical requests instead of real-time streaming 2) Blocking the event loop with sleep() which prevents processing of messages and events. Use real-time market data subscriptions instead of polling historical endpoints.

```python
while True:
    bars = ib.reqHistoricalData(...)  # DON'T POLL!
    time.sleep(5)  # Also wrong - blocks event loop!
```

> **Note:** Example 2 adds emphasis on event loop blocking consequence. Both agree on core anti-pattern of polling historical data. Combined comments show both polling and blocking issues.

### ✅ ALWAYS DO THIS:

```python
# For ticks
ticker = ib.reqMktData(contract)
ticker.updateEvent += process_tick

# For bars  
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += process_bar
```

> **Note:** Single example, no duplicates found

###  With Event Handler

```python
def on_ticker_update(ticker):
    print(f"{ticker.contract.symbol}: ${ticker.last:.2f}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_ticker_update
```

> **Note:** Single example, no duplicates found

###  Real-Time Bars (5-Second Updates)

```python
bars = ib.reqRealTimeBars(
    contract,
    barSize=5,              # Always 5 seconds
    whatToShow='TRADES',    # TRADES, MIDPOINT, BID, ASK
    useRTH=False
)

def on_bar_update(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        print(f"{bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close} V:{bar.volume}")

bars.updateEvent += on_bar_update

# Cancel when done
ib.cancelRealTimeBars(bars)
```

> **Note:** Single example, no duplicates found

###  Keep Historical Updated (Live)

```python
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    keepUpToDate=True  # ← Auto-update!
)

bars.updateEvent += lambda bars, hasNewBar: print(f"Updated: {hasNewBar}")
```

> **Note:** Single example, no duplicates found

###  Tick-by-Tick Data

```python
ticker = ib.reqTickByTickData(
    contract,
    tickType='AllLast',  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'
    numberOfTicks=0,
    ignoreSize=False
)

def on_tick(ticker):
    if ticker.tickByTicks:
        tick = ticker.tickByTicks[-1]
        print(f"Tick: {tick.time} {tick.price} x {tick.size}")

ticker.updateEvent += on_tick
```

> **Note:** Single example, no duplicates found

###  Multiple Tickers Pattern

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract)

ib.run()  # Run event loop
```

> **Note:** Single example, no duplicates found

###  Price Alert System

```python
def price_alert(ticker, target_price, above=True):
    """Alert when price crosses threshold"""
    def check_price(ticker):
        if not ticker.last or ticker.last != ticker.last:
            return
        
        if above and ticker.last >= target_price:
            print(f"ALERT: {ticker.contract.symbol} above ${target_price}")
            ticker.updateEvent -= check_price  # Unsubscribe
        elif not above and ticker.last <= target_price:
            print(f"ALERT: {ticker.contract.symbol} below ${target_price}")
            ticker.updateEvent -= check_price
    
    ticker.updateEvent += check_price

# Usage
ticker = ib.reqMktData(contract)
price_alert(ticker, 180.0, above=True)
```

> **Note:** Single example, no duplicates found

###  Moving Average Calculator

```python
class MovingAverage:
    def __init__(self, period=20):
        self.period = period
        self.prices = []
    
    def update(self, price):
        self.prices.append(price)
        if len(self.prices) > self.period:
            self.prices.pop(0)
    
    def value(self):
        return sum(self.prices) / len(self.prices) if self.prices else None

ma20 = MovingAverage(20)

def on_bar(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        ma20.update(bar.close)
        if ma20.value():
            print(f"Price: {bar.close:.2f} | MA20: {ma20.value():.2f}")

bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += on_bar
```

> **Note:** Single example, no duplicates found

###  OHLC Tracker

```python
class OHLCTracker:
    def __init__(self):
        self.open = None
        self.high = None
        self.low = None
        self.close = None
    
    def update(self, price):
        if self.open is None:
            self.open = price
        
        if self.high is None or price > self.high:
            self.high = price
        
        if self.low is None or price < self.low:
            self.low = price
        
        self.close = price
    
    def reset(self):
        self.open = self.high = self.low = self.close = None

tracker = OHLCTracker()

def on_tick(ticker):
    if ticker.last:
        tracker.update(ticker.last)
        print(f"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += on_tick
```

> **Note:** Single example, no duplicates found

### The golden rule: never use time.sleep()—always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields...

```python
# WRONG - freezes everything
import time
ticker = ib.reqMktData(contract)
time.sleep(5)  # Event loop frozen, no updates processed
print(ticker.last)  # May be empty

# CORRECT - allows message processing
ticker = ib.reqMktData(contract)
ib.sleep(5)  # Framework processes updates in background
print(ticker.last)  # Contains current data
```

> **Note:** Single example, no duplicates found

### For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package.

```python
# Jupyter notebook setup
from ib_insync import *

util.startLoop()  # Enables nested event loops
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)
# Can now use blocking methods directly in notebook cells
```

> **Note:** Single example, no duplicates found

### For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def onTicker(ticker):
    print(f"Price update: {ticker.contract.symbol} @ {ticker.last}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += onTicker

ib.run()  # Runs event loop indefinitely
```

> **Note:** Single example, no duplicates found

### ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.

```python
# Synchronous event handler
def onOrderStatus(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    if trade.isDone():
        print(f"Filled at: {trade.orderStatus.avgFillPrice}")

ib.orderStatusEvent += onOrderStatus

# Asynchronous event handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        print(f"New bar: {bars[-1]}")
        # Can use await inside async handlers
        await ib.qualifyContractsAsync(contract)

bars.updateEvent += onBarUpdate
```

> **Note:** Single example, no duplicates found

### Ticker-specific events provide fine-grained control over individual market data subscriptions:

```python
contract = Forex('EURUSD')
ticker = ib.reqMktData(contract)

async def onTickerUpdate(ticker):
    print(f"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}")
    
ticker.updateEvent += onTickerUpdate
```

> **Note:** Single example, no duplicates found

### Unsubscribe from events using the -= operator, and use the @event.once decorator for one-time handlers that automatically unsubscribe after firing.

```python
# Unsubscribe
ticker.updateEvent -= onTickerUpdate

# One-time handler
@ticker.updateEvent.once
def onFirstUpdate(ticker):
    print(f"First update received: {ticker.last}")
```

> **Note:** Single example, no duplicates found

### Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately.

```python
# WRONG - blocks event loop in callback
def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        ib.qualifyContracts(contract)  # Blocking!

# CORRECT - use async handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        await ib.qualifyContractsAsync(contract)
```

> **Note:** Single example, no duplicates found

### Missing tick data with waitOnUpdate(): The waitOnUpdate() method can miss rapid updates because ticks from the first update get cleared before processing. Always use event handlers for tick data colle...

```python
# WRONG - misses rapid ticks
while True:
    ib.waitOnUpdate()
    print(ticker.last)

# CORRECT - captures all updates
def onTicker(ticker):
    print(ticker.last)
    
ticker.updateEvent += onTicker
```

> **Note:** Single example, no duplicates found

### Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking.

```python
def onPositionUpdate(position):
    print(f"Position: {position.contract.symbol}: {position.position}")

ib.positionEvent += onPositionUpdate

def onPortfolioUpdate(item):
    print(f"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}")

ib.updatePortfolioEvent += onPortfolioUpdate
```

> **Note:** Single example, no duplicates found

### The global updateEvent fires on any state change, useful for triggering comprehensive checks:

```python
def onUpdate():
    positions = ib.positions()
    print(f"Current positions: {len(positions)}")

ib.updateEvent += onUpdate
```

> **Note:** Single example, no duplicates found

### When performing calculations or processing that takes significant time, yield control to the event loop periodically using ib.sleep(0). This allows the Wrapper to process incoming messages and update ...

```python
def long_calculation():
    for i in range(1000):
        result = expensive_operation()
        
        # Periodically yield to allow state updates
        if i % 100 == 0:
            ib.sleep(0)
        
        # State may have changed during sleep
        current_positions = ib.positions()
```

> **Note:** Single example, no duplicates found

### ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.

```python
# WRONG - threading with asyncio
from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor(max_workers=2)
executor.submit(ib.positions)  # Will fail!

# CORRECT - use asyncio tasks
async def fetch_multiple_contracts():
    tasks = [
        ib.qualifyContractsAsync(contract1),
        ib.qualifyContractsAsync(contract2),
        ib.qualifyContractsAsync(contract3)
    ]
    results = await asyncio.gather(*tasks)
    return results
```

> **Note:** Single example, no duplicates found

###  Production-ready state manager

```python
from ib_insync import *
import logging

class IBDataManager:
    """Demonstrates best practices for single source of truth pattern"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self._setup_logging()
        self._setup_events()
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _setup_events(self):
        self.ib.connectedEvent += self._on_connected
        self.ib.disconnectedEvent += self._on_disconnected
        self.ib.positionEvent += self._on_position
        self.ib.updatePortfolioEvent += self._on_portfolio
    
    def connect(self):
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info("Connected to IB")
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _on_connected(self):
        self.logger.info("Connection established")
        self.ib.reqAccountSummary()
    
    def _on_disconnected(self):
        self.logger.warning("Disconnected from IB")
    
    def _on_position(self, position):
        self.logger.info(f"Position update: {position.contract.symbol}")
    
    def _on_portfolio(self, item):
        self.logger.info(f"Portfolio update: {item.contract.symbol}")
    
    def get_current_positions(self):
        """Get current positions (always fresh from single source)"""
        if not self.ib.isConnected():
            raise ConnectionError("Not connected")
        return self.ib.positions()
    
    def get_position_for_symbol(self, symbol):
        """Get position for specific symbol"""
        for pos in self.get_current_positions():
            if pos.contract.symbol == symbol:
                return pos
        return None
```

> **Note:** Single example, no duplicates found

### Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders.

```python
def order_status_callback(trade):
    if trade.orderStatus.status == 'Filled':
        fill = trade.fills[-1]
        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '
              f'{fill.execution.shares} @ {fill.execution.avgPrice}')

trade.filledEvent += order_status_callback
```

> **Note:** Single example, no duplicates found

###  Order status monitoring

```python
# Trade object attributes
trade.order          # The original order
trade.orderStatus    # Current status object
trade.fills          # List of fills
trade.log            # Log of status changes
trade.isActive()     # Is order still active
trade.isDone()       # Is order complete

# Order status values
# PendingSubmit, PendingCancel, PreSubmitted, Submitted, 
# Filled, Cancelled, Inactive, ApiPending

# Event callbacks for monitoring
def on_fill(trade, fill):
    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')

trade.fillEvent += on_fill

def on_filled(trade):
    total = sum(f.execution.shares for f in trade.fills)
    avg_price = trade.orderStatus.avgFillPrice
    print(f'Complete: {total} shares @ avg {avg_price}')

trade.filledEvent += on_filled

def on_status(trade):
    print(f'Status: {trade.orderStatus.status}')

trade.statusEvent += on_status
```

> **Note:** Single example, no duplicates found

### Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing.

```python
contract = Stock('TSLA', 'SMART', 'USD')

bars = ib.reqHistoricalData(
    contract,
    endDateTime='',
    durationStr='1 D',
    barSizeSetting='1 min',
    whatToShow='TRADES',
    useRTH=True,
    formatDate=1,
    keepUpToDate=True  # Enables live updates
)
```

> **Note:** Example 1 includes formatDate=1 while Example 2 omits it. Example 2 explicitly mentions bars.updateEvent firing on changes. Both agree on core parameters. Contract creation shown in Example 1 but not Example 2.

### Individual ticker events for ticker-specific logic:

```python
def onTickerUpdate(ticker):
    print(f"{ticker.contract.symbol}: Last {ticker.last}")

contract = Stock('AAPL', 'SMART', 'USD')
ticker = ib.reqMktData(contract)
ticker.updateEvent += onTickerUpdate

ib.run()
```

> **Note:** Single example, no duplicates found

### Global pendingTickersEvent for monitoring multiple tickers efficiently:

```python
contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

def onPendingTickers(tickers):
    """Called when any subscribed ticker has new data"""
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.last}")

ib.pendingTickersEvent += onPendingTickers
ib.run()
```

> **Note:** Single example, no duplicates found

### Bar update events for streaming bar data:

```python
def onBarUpdate(bars, hasNewBar):
    """
    bars: BarDataList containing all bars
    hasNewBar: Boolean indicating if a new bar was added
    """
    if hasNewBar:
        latest = bars[-1]
        print(f"New bar: O={latest.open}, H={latest.high}, "
              f"L={latest.low}, C={latest.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += onBarUpdate
ib.run()
```

> **Note:** Single example, no duplicates found

### Combine ibinsync with pandas for structured data handling:

```python
import pandas as pd

contracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]
ib.qualifyContracts(*contracts)
tickers = [ib.reqMktData(c) for c in contracts]

# Create DataFrame
df = pd.DataFrame(
    index=[c.pair() for c in contracts],
    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']
)

def onPendingTickers(tickers):
    for t in tickers:
        df.loc[t.contract.pair()] = (
            t.bidSize, t.bid, t.ask, t.askSize, 
            t.high, t.low, t.close
        )
    print(df)

ib.pendingTickersEvent += onPendingTickers
ib.sleep(30)
```

> **Note:** Single example, no duplicates found

### Never use time.sleep() in callbacks or main code—it freezes the event loop and prevents message processing. Always use ib.sleep() to yield control.

```python
# WRONG - blocks everything
import time

def onTickerUpdate(ticker):
    time.sleep(5)  # Frozen!
    process(ticker)

# CORRECT - yields control
def onTickerUpdate(ticker):
    ib.sleep(0)  # Yields to allow message processing
    process(ticker)
```

> **Note:** Single example, no duplicates found

### Encapsulate subscription management in a reusable class:

```python
class TickerManager:
    def __init__(self, ib):
        self.ib = ib
        self.tickers = {}
        self.contracts = {}
        
    def subscribe(self, symbol, exchange='SMART', currency='USD'):
        contract = Stock(symbol, exchange, currency)
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract)
        ticker.updateEvent += self.onUpdate
        
        self.tickers[symbol] = ticker
        self.contracts[symbol] = contract
        return ticker
    
    def unsubscribe(self, symbol):
        if symbol in self.tickers:
            self.ib.cancelMktData(self.contracts[symbol])
            del self.tickers[symbol]
            del self.contracts[symbol]
    
    def onUpdate(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")

# Usage
manager = TickerManager(ib)
manager.subscribe('AAPL')
manager.subscribe('GOOGL')
```

> **Note:** Single example, no duplicates found

### Remove event handlers before unsubscribing to prevent memory leaks:

```python
ticker.updateEvent += handler
# Later...
ticker.updateEvent -= handler
ib.cancelMktData(contract)
```

> **Note:** Single example, no duplicates found

### Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update—process ticks in event handlers when they arrive.

```python
# WRONG - ticks cleared before checking
ticker = ib.reqMktData(contract)
ib.sleep(5)
print(ticker.ticks)  # Likely empty

# CORRECT - process in event
def onUpdate(ticker):
    for tick in ticker.ticks:
        process_tick(tick)

ticker.updateEvent += onUpdate
```

> **Note:** Single example, no duplicates found

### Accumulating historical bars: When using keepUpToDate=True, limit buffer size to prevent unbounded memory growth.

```python
def onBarUpdate(bars, hasNewBar):
    if len(bars) > 1000:
        # Keep only last 1000 bars
        del bars[:len(bars)-1000]
```

> **Note:** Single example, no duplicates found

###  Production-ready streaming system

```python
from ib_insync import *
import logging

logging.basicConfig(level=logging.INFO)

class TradingSystem:
    def __init__(self):
        self.ib = IB()
        self.tickers = {}
        self.active_contracts = set()
        
    def connect(self):
        self.ib.connect('127.0.0.1', 7497, clientId=1)
        self.ib.errorEvent += self.onError
        self.ib.pendingTickersEvent += self.onPendingTickers
        
    def subscribe(self, symbol):
        contract = Stock(symbol, 'SMART', 'USD')
        self.ib.qualifyContracts(contract)
        
        ticker = self.ib.reqMktData(contract, '', False, False)
        self.tickers[symbol] = ticker
        self.active_contracts.add(contract)
        
    def onPendingTickers(self, tickers):
        for ticker in tickers:
            self.process_ticker(ticker)
            
    def process_ticker(self, ticker):
        symbol = ticker.contract.symbol
        print(f"{symbol}: {ticker.last}")
        
        # Always yield control in callbacks
        self.ib.sleep(0)
        
    def onError(self, reqId, errorCode, errorString, contract):
        logging.error(f"Error {errorCode}: {errorString}")
        
    def shutdown(self):
        for contract in self.active_contracts:
            self.ib.cancelMktData(contract)
        self.ib.sleep(1)
        self.ib.disconnect()
        
    def run(self):
        try:
            self.ib.run()
        except KeyboardInterrupt:
            print("Shutting down...")
        finally:
            self.shutdown()

# Usage
if __name__ == '__main__':
    system = TradingSystem()
    system.connect()
    system.subscribe('AAPL')
    system.subscribe('GOOGL')
    system.run()
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### 
Order

```python
#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',
totalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =
1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:
str = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',
ocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,
blockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,
triggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,
goodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:
bool = False, minQty: int = 2147483647, percentOffset: float =
1.7976931348623157e+308, overridePercentageConstraints: bool = False,
trailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =
1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str
= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',
origin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:
float = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,
nbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool
= False, auctionStrategy: int = 0, startingPrice: float =
1.7976931348623157e+308, stockRefPrice: float =
1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,
stockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float
= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:
bool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int
= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =
1.7976931348623157e+308, deltaNeutralConId: int = 0,
deltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',
deltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',
deltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,
deltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,
referencePriceType: int = 2147483647, basisPoints: float =
1.7976931348623157e+308, basisPointsType: int = 2147483647,
scaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,
scalePriceIncrement: float = 1.7976931348623157e+308,
scalePriceAdjustValue: float = 1.7976931348623157e+308,
scalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =
1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:
int = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:
bool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',
account: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:
str = '', algoStrategy: str = '', algoParams:
~typing.List[~ib_insync.contract.TagValue] = <factory>,
smartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =
<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,
solicited: bool = False, modelCode: str = '', orderComboLegs:
~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,
orderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,
referenceContractId: int = 0, peggedChangeAmount: float = 0.0,
isPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float
= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:
float = 1.7976931348623157e+308, adjustedStopPrice: float =
1.7976931348623157e+308, adjustedStopLimitPrice: float =
1.7976931348623157e+308, adjustedTrailingAmount: float =
1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:
float = 1.7976931348623157e+308, conditions:
~typing.List[~ib_insync.order.OrderCondition] = <factory>,
conditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,
extOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =
<factory>, cashQty: float = 1.7976931348623157e+308,
mifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',
mifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',
dontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,

Order for trading contracts.
https://interactivebrokers.github.io/tws-api/available_orders.html
orderId: int = 0
clientId: int = 0
permId: int = 0
action: str = ''
totalQuantity: float = 0.0
orderType: str = ''
lmtPrice: float = 1.7976931348623157e+308
auxPrice: float = 1.7976931348623157e+308
tif: str = ''
activeStartTime: str = ''
activeStopTime: str = ''
ocaGroup: str = ''
ocaType: int = 0
orderRef: str = ''
transmit: bool = True
parentId: int = 0
blockOrder: bool = False
sweepToFill: bool = False
displaySize: int = 0
triggerMethod: int = 0
outsideRth: bool = False
hidden: bool = False
goodAfterTime: str = ''
goodTillDate: str = ''
rule80A: str = ''
allOrNone: bool = False
minQty: int = 2147483647
percentOffset: float = 1.7976931348623157e+308
overridePercentageConstraints: bool = False
trailStopPrice: float = 1.7976931348623157e+308
trailingPercent: float = 1.7976931348623157e+308
faGroup: str = ''
faProfile: str = ''
faMethod: str = ''
faPercentage: str = ''
designatedLocation: str = ''
openClose: str = 'O'
origin: int = 0
shortSaleSlot: int = 0
exemptCode: int = -1
discretionaryAmt: float = 0.0
eTradeOnly: bool = False
firmQuoteOnly: bool = False
nbboPriceCap: float = 1.7976931348623157e+308
optOutSmartRouting: bool = False
auctionStrategy: int = 0
startingPrice: float = 1.7976931348623157e+308
stockRefPrice: float = 1.7976931348623157e+308
delta: float = 1.7976931348623157e+308
stockRangeLower: float = 1.7976931348623157e+308
stockRangeUpper: float = 1.7976931348623157e+308
randomizePrice: bool = False
randomizeSize: bool = False
volatility: float = 1.7976931348623157e+308
volatilityType: int = 2147483647
deltaNeutralOrderType: str = ''
deltaNeutralAuxPrice: float = 1.7976931348623157e+308
deltaNeutralConId: int = 0
deltaNeutralSettlingFirm: str = ''
deltaNeutralClearingAccount: str = ''
deltaNeutralClearingIntent: str = ''
deltaNeutralOpenClose: str = ''
deltaNeutralShortSale: bool = False
deltaNeutralShortSaleSlot: int = 0
deltaNeutralDesignatedLocation: str = ''
continuousUpdate: bool = False
referencePriceType: int = 2147483647
basisPoints: float = 1.7976931348623157e+308
basisPointsType: int = 2147483647
scaleInitLevelSize: int = 2147483647
scaleSubsLevelSize: int = 2147483647
scalePriceIncrement: float = 1.7976931348623157e+308
scalePriceAdjustValue: float = 1.7976931348623157e+308
scalePriceAdjustInterval: int = 2147483647
scaleProfitOffset: float = 1.7976931348623157e+308
scaleAutoReset: bool = False
scaleInitPosition: int = 2147483647
scaleInitFillQty: int = 2147483647
scaleRandomPercent: bool = False
scaleTable: str = ''
hedgeType: str = ''
hedgeParam: str = ''
account: str = ''
settlingFirm: str = ''
clearingAccount: str = ''
clearingIntent: str = ''
algoStrategy: str = ''
algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
algoId: str = ''
whatIf: bool = False
notHeld: bool = False
solicited: bool = False
modelCode: str = ''
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
referenceContractId: int = 0
peggedChangeAmount: float = 0.0
isPeggedChangeAmountDecrease: bool = False
referenceChangeAmount: float = 0.0
referenceExchangeId: str = ''
adjustedOrderType: str = ''
triggerPrice: float = 1.7976931348623157e+308
adjustedStopPrice: float = 1.7976931348623157e+308
adjustedStopLimitPrice: float = 1.7976931348623157e+308
adjustedTrailingAmount: float = 1.7976931348623157e+308
adjustableTrailingUnit: int = 0
lmtPriceOffset: float = 1.7976931348623157e+308
conditions: List[OrderCondition]
conditionsCancelOrder: bool = False
conditionsIgnoreRth: bool = False
extOperator: str = ''
softDollarTier: SoftDollarTier
cashQty: float = 1.7976931348623157e+308
mifid2DecisionMaker: str = ''
mifid2DecisionAlgo: str = ''
mifid2ExecutionTrader: str = ''
mifid2ExecutionAlgo: str = ''
dontUseAutoPriceForHedge: bool = False
isOmsContainer: bool = False
discretionaryUpToLimitPrice: bool = False
autoCancelDate: str = ''
filledQuantity: float = 1.7976931348623157e+308
refFuturesConId: int = 0
autoCancelParent: bool = False
shareholder: str = ''
imbalanceOnly: bool = False
routeMarketableToBbo: bool = False
parentPermId: int = 0
usePriceMgmtAlgo: bool = False
duration: int = 2147483647
postToAts: int = 2147483647
advancedErrorOverride: str = ''
manualOrderTime: str = ''
minTradeQty: int = 2147483647
minCompeteSize: int = 2147483647
competeAgainstBestOffset: float = 1.7976931348623157e+308
midOffsetAtWhole: float = 1.7976931348623157e+308
midOffsetAtHalf: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)
dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =
0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,
lastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',
mktCapPrice: float = 0.0)

orderId: int = 0
status: str = ''
filled: float = 0.0
remaining: float = 0.0
avgFillPrice: float = 0.0
permId: int = 0
parentId: int = 0
lastFillPrice: float = 0.0
clientId: int = 0
whyHeld: str = ''
mktCapPrice: float = 0.0
PendingSubmit: ClassVar[str] = 'PendingSubmit'
PendingCancel: ClassVar[str] = 'PendingCancel'
PreSubmitted: ClassVar[str] = 'PreSubmitted'
Submitted: ClassVar[str] = 'Submitted'
ApiPending: ClassVar[str] = 'ApiPending'
ApiCancelled: ClassVar[str] = 'ApiCancelled'
Cancelled: ClassVar[str] = 'Cancelled'
Filled: ClassVar[str] = 'Filled'
Inactive: ClassVar[str] = 'Inactive'
DoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}
ActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',
'Submitted'}

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',
equityWithLoanBefore: str = '', initMarginChange: str = '',
maintMarginChange: str = '', equityWithLoanChange: str = '',
initMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:
str = '', commission: float = 1.7976931348623157e+308,
minCommission: float = 1.7976931348623157e+308, maxCommission:
float = 1.7976931348623157e+308, commissionCurrency: str = '',
warningText: str = '', completedTime: str = '', completedStatus: str = '')

status: str = ''
initMarginBefore: str = ''
maintMarginBefore: str = ''
equityWithLoanBefore: str = ''
initMarginChange: str = ''
maintMarginChange: str = ''
equityWithLoanChange: str = ''
initMarginAfter: str = ''
maintMarginAfter: str = ''
equityWithLoanAfter: str = ''
commission: float = 1.7976931348623157e+308
minCommission: float = 1.7976931348623157e+308
maxCommission: float = 1.7976931348623157e+308
commissionCurrency: str = ''
warningText: str = ''
completedTime: str = ''
completedStatus: str = ''
dict()

Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)

price: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:
~ib_insync.order.Order = <factory>, orderStatus:
~ib_insync.order.OrderStatus = <factory>, fills:
~typing.List[~ib_insync.objects.Fill] = <factory>, log:
~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:
str = '')
Trade keeps track of an order, its status and all its fills.
Events:
-statusEvent (trade: Trade)
-modifyEvent (trade: Trade)
-fillEvent (trade: Trade, fill: Fill)
-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)
-filledEvent (trade: Trade)
-cancelEvent (trade: Trade)
-cancelledEvent (trade: Trade)
events: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',
'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')
contract: Contract
order: Order
orderStatus: OrderStatus
fills: List[Fill]
log: List[TradeLogEntry]
advancedError: str = ''
isActive()
True if eligible for execution, false otherwise.
isDone()
True if completely filled or cancelled, false otherwise.
filled()
Number of shares filled.
remaining()
Number of shares remaining to be filled.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)
Create new instance of BracketOrder(parent, takeProfit, stopLoss)
property parent
property takeProfit
property stopLoss

#### class ib_insync.order.OrderCondition
static createClass(condType)
And()
Or()

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,
price: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =
0)
condType: int = 1
conjunction: str = 'a'
isMore: bool = True
price: float = 0.0
conId: int = 0
exch: str = ''
triggerMethod: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:
str = '')
condType: int = 3
conjunction: str = 'a'
isMore: bool = True
time: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,
percent: int = 0)
condType: int = 4
conjunction: str = 'a'
isMore: bool = True
percent: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',
exch: str = '', symbol: str = '')
condType: int = 5
conjunction: str = 'a'
secType: str = ''
exch: str = ''
symbol: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,
volume: int = 0, conId: int = 0, exch: str = '')
condType: int = 6
conjunction: str = 'a'
isMore: bool = True
volume: int = 0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =
True, changePercent: float = 0.0, conId: int = 0, exch: str
= '')
condType: int = 7
conjunction: str = 'a'
isMore: bool = True
changePercent: float = 0.0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

onDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
```

> **Note:** Single example, no duplicates found

### class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =
'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:
float = 2, appStartupTime: float = 30, ...

```python
def onConnected():
    print(ib.accountValues())

ibc = IBC(974, gateway=True, tradingMode='paper')
ib = IB()
ib.connectedEvent += onConnected
watchdog = Watchdog(ibc, ib, port=4002)
watchdog.start()
ib.run()
```

> **Note:** Single example, no duplicates found

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.

###  Scanner data (streaming)

```python
def onScanData(scanData):
print(scanData[0])
print(len(scanData))
sub = ScannerSubscription(
instrument='FUT.US',
locationCode='FUT.CME',
scanCode='TOP_PERC_GAIN')
scanData = ib.reqScannerSubscription(sub)
scanData.updateEvent += onScanData
ib.sleep(60)
ib.cancelScannerSubscription(scanData)
```

> **Note:** Single example, no duplicates found

###  Comprehensive Error Handler

```python
from ib_insync import *
import logging

class IBErrorHandler:
    def __init__(self, ib):
        self.ib = ib
        self.error_log = []
        self.ib.errorEvent += self.on_error
        
    def on_error(self, reqId, errorCode, errorString, contract):
        """Centralized error handling"""
        error_info = {
            'time': datetime.now(),
            'reqId': reqId,
            'code': errorCode,
            'message': errorString,
            'contract': contract
        }
        self.error_log.append(error_info)
        
        # Categorize and handle
        if errorCode in [502, 503, 504]:
            self.handle_connection_error(errorCode, errorString)
        elif errorCode in [200, 201, 202]:
            self.handle_order_error(errorCode, errorString, contract)
        elif errorCode == 162:
            self.handle_data_error(errorCode, errorString, contract)
        elif errorCode == 354:
            self.handle_market_data_subscription_error(errorCode, errorString)
        elif errorCode in [2104, 2106, 2158]:
            # Info messages - ignore
            pass
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def handle_connection_error(self, code, message):
        """Handle connection failures"""
        logging.critical(f"Connection error {code}: {message}")
        # Trigger reconnection
        self.schedule_reconnect()
    
    def handle_order_error(self, code, message, contract):
        """Handle order rejections"""
        logging.error(f"Order error {code}: {message} for {contract}")
        # Could retry with modified params
        # Or alert user
    
    def handle_data_error(self, code, message, contract):
        """Handle data request failures"""
        logging.warning(f"Data error {code}: {message} for {contract}")
        # Retry with different params
    
    def handle_market_data_subscription_error(self, code, message):
        """Handle market data subscription issues"""
        logging.warning(f"Market data error {code}: {message}")
        # Fall back to delayed data
        self.ib.reqMarketDataType(3)  # Delayed
    
    def schedule_reconnect(self):
        """Schedule reconnection attempt"""
        # Implementation in reconnection section
        pass

# Usage
ib = IB()
error_handler = IBErrorHandler(ib)
ib.connect('127.0.0.1', 7497, clientId=1)
```

> **Note:** Single example, no duplicates found

###  Position Reconciliation

```python
class PositionManager:
    def __init__(self, ib):
        self.ib = ib
        self.expected_positions = {}  # conId -> quantity
        
    def record_trade(self, trade):
        """Record expected position change"""
        if trade.orderStatus.status == 'Filled':
            conId = trade.contract.conId
            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()
            
            if conId in self.expected_positions:
                self.expected_positions[conId] += qty
            else:
                self.expected_positions[conId] = qty
    
    def reconcile(self):
        """Check actual vs expected positions"""
        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}
        
        discrepancies = []
        
        # Check expected positions
        for conId, expected_qty in self.expected_positions.items():
            actual_qty = actual_positions.get(conId, 0)
            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding
                discrepancies.append({
                    'conId': conId,
                    'expected': expected_qty,
                    'actual': actual_qty,
                    'diff': actual_qty - expected_qty
                })
        
        # Check for unexpected positions
        for conId, actual_qty in actual_positions.items():
            if conId not in self.expected_positions and abs(actual_qty) > 0.01:
                discrepancies.append({
                    'conId': conId,
                    'expected': 0,
                    'actual': actual_qty,
                    'diff': actual_qty
                })
        
        if discrepancies:
            logging.warning(f"Position discrepancies found: {discrepancies}")
        
        return discrepancies
    
    def reset_tracking(self):
        """Reset to current positions"""
        self.expected_positions = {
            p.contract.conId: p.position 
            for p in self.ib.positions()
        }

# Usage
pm = PositionManager(ib)
pm.reset_tracking()

# Track trades
ib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)

# Periodic reconciliation
while True:
    discrepancies = pm.reconcile()
    if discrepancies:
        # Alert or take action
        pass
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Heartbeat Monitor

```python
class HeartbeatMonitor:
    def __init__(self, ib, timeout=60):
        self.ib = ib
        self.timeout = timeout
        self.last_update = time.time()
        self.ib.updateEvent += self.on_update
        
    def on_update(self):
        """Reset timer on any update"""
        self.last_update = time.time()
    
    def check(self):
        """Check if connection is alive"""
        elapsed = time.time() - self.last_update
        
        if elapsed > self.timeout:
            logging.warning(f"No updates for {elapsed:.0f}s. Connection may be dead.")
            return False
        
        return True
    
    def run(self):
        """Run heartbeat check loop"""
        while True:
            if not self.check():
                logging.error("Heartbeat timeout. Triggering reconnect...")
                # Trigger reconnection
                break
            
            time.sleep(10)

# Usage
heartbeat = HeartbeatMonitor(ib, timeout=60)
# Run in separate thread or async task
```

> **Note:** Single example, no duplicates found

###  Tick-by-Tick with Filtering

```python
class TickFilter:
    def __init__(self, ib, contract, min_size=100):
        self.ib = ib
        self.contract = contract
        self.min_size = min_size
        self.large_trades = []
        
    def start(self):
        """Start tick-by-tick subscription with filtering"""
        self.ticker = self.ib.reqTickByTickData(
            self.contract,
            'AllLast',  # All trades
            0,
            False
        )
        self.ticker.updateEvent += self.on_tick
    
    def on_tick(self, ticker):
        """Filter and process ticks"""
        if not ticker.tickByTicks:
            return
        
        latest_tick = ticker.tickByTicks[-1]
        
        # Filter by size
        if latest_tick.size >= self.min_size:
            self.large_trades.append({
                'time': latest_tick.time,
                'price': latest_tick.price,
                'size': latest_tick.size
            })
            
            logging.info(f"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}")
    
    def stop(self):
        """Stop subscription"""
        self.ib.cancelTickByTickData(self.contract)
    
    def get_stats(self):
        """Get statistics on large trades"""
        if not self.large_trades:
            return None
        
        total_volume = sum(t['size'] for t in self.large_trades)
        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume
        
        return {
            'num_trades': len(self.large_trades),
            'total_volume': total_volume,
            'vwap': avg_price
        }

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

filter = TickFilter(ib, contract, min_size=1000)
filter.start()

# Run for period
ib.sleep(3600)  # 1 hour

filter.stop()
stats = filter.get_stats()
print(f"Large trades: {stats}")
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Events

```python
events = (
    'connectedEvent',       # Connection established
    'disconnectedEvent',    # Connection lost
    'updateEvent',          # Any state update
    'pendingTickersEvent',  # Ticker updates available
    'barUpdateEvent',       # Real-time bar update
    'newOrderEvent',        # New order created
    'orderModifyEvent',     # Order modified
    'cancelOrderEvent',     # Order cancel requested
    'openOrderEvent',       # Open order status
    'orderStatusEvent',     # Order status changed
    'execDetailsEvent',     # Trade execution details
    'commissionReportEvent',# Commission report
    'updatePortfolioEvent', # Portfolio updated
    'positionEvent',        # Position changed
    'accountValueEvent',    # Account value updated
    'accountSummaryEvent',  # Account summary updated
    'pnlEvent',            # PnL update
    'pnlSingleEvent',      # Single position PnL
    'scannerDataEvent',    # Scanner data received
    'tickNewsEvent',       # News tick
    'newsBulletinEvent',   # News bulletin
    'errorEvent',          # Error occurred
    'timeoutEvent'         # Request timeout
)
```

> **Note:** Single example, no duplicates found

###  Wait & Sleep

```python
ib.waitOnUpdate(timeout: float = 0) -> bool
# Wait for network update. Returns False on timeout.

ib.sleep(seconds: float = 0.02) -> None
# Sleep while keeping event loop alive
# ALWAYS use this instead of time.sleep()
```

> **Note:** Single example, no duplicates found

###  Real-Time Bars

```python
bars = ib.reqRealTimeBars(
    contract: Contract,
    barSize: int = 5,           # Only 5 supported
    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK
    useRTH: bool = False,
    realTimeBarsOptions: List = None
) -> RealTimeBarList

# Returns RealTimeBarList (auto-updating)
# bars.updateEvent fires on new bar
```

> **Note:** Single example, no duplicates found

###  Event Handling

```python
# Events use eventkit library

# Subscribe to event
def onPendingTickers(tickers):
    for ticker in tickers:
        print(f"{ticker.contract.symbol}: {ticker.marketPrice()}")

ib.pendingTickersEvent += onPendingTickers

# Unsubscribe
ib.pendingTickersEvent -= onPendingTickers

# One-time handler
ib.connectedEvent += lambda: print('Connected!')
```

> **Note:** Single example, no duplicates found

###  Trade Events

```python
# New order placed
ib.newOrderEvent += lambda trade: print(f'New order: {trade}')

# Order modified
ib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')

# Order status changed
ib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')

# Execution received
ib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')

# Commission report
ib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')
```

> **Note:** Single example, no duplicates found

###  Market Data Events

```python
# Ticker updates
ib.pendingTickersEvent += lambda tickers: handle_tickers(tickers)

# Bar updates
ib.barUpdateEvent += lambda bars, hasNewBar: handle_bars(bars, hasNewBar)

# Scanner data
ib.scannerDataEvent += lambda scanData: print(scanData)
```

> **Note:** Single example, no duplicates found

###  Account Events

```python
# Portfolio updates
ib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')

# Position changes
ib.positionEvent += lambda position: print(f'Position: {position}')

# Account value updates
ib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')

# PnL updates
ib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')
```

> **Note:** Single example, no duplicates found

###  Connection Events

```python
# Connected
ib.connectedEvent += lambda: print('Connected to TWS')

# Disconnected
ib.disconnectedEvent += lambda: print('Disconnected')

# Error
ib.errorEvent += lambda reqId, errorCode, errorString, contract: \
    print(f'Error {errorCode}: {errorString}')
```

> **Note:** Single example, no duplicates found

###  Qt Integration

```python
util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'
# Integrates asyncio with Qt event loop
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Use streaming:

```python
# For tick data
ticker = ib.reqMktData(contract, '233')  # Last, volume, vwap
ticker.updateEvent += lambda ticker: process_tick(ticker)

# For bar data
bars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)
bars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)
```

> **Note:** Single example, no duplicates found

### ❌ BAD:

```python
time.sleep(5)  # Blocks event loop!
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
ib.sleep(5)  # Keeps event loop running
```

> **Note:** Single example, no duplicates found

### ❌ BAD - Polling:

```python
while True:
    if ticker.last > 150:
        break
    ib.sleep(0.1)
```

> **Note:** Single example, no duplicates found

### ✅ GOOD - Event-driven:

```python
def on_price_update(ticker):
    if ticker.last > 150:
        take_action()

ticker.updateEvent += on_price_update
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
def on_error(reqId, errorCode, errorString, contract):
    if errorCode == 200:
        print(f"Contract not found: {contract}")
    elif errorCode == 321:
        print(f"Validation error: {errorString}")
    # Handle other errors...

ib.errorEvent += on_error
```

> **Note:** Single example, no duplicates found

### ✅ GOOD:

```python
def on_disconnect():
    print("Disconnected! Attempting reconnect...")
    reconnect_logic()

ib.disconnectedEvent += on_disconnect
```

> **Note:** Single example, no duplicates found

###  Pattern: Live Ticker Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contracts = [
    Stock('AAPL', 'SMART', 'USD'),
    Stock('GOOGL', 'SMART', 'USD'),
    Stock('MSFT', 'SMART', 'USD')
]

contracts = ib.qualifyContracts(*contracts)

def on_pending_tickers(tickers):
    for ticker in tickers:
        symbol = ticker.contract.symbol
        price = ticker.marketPrice()
        volume = ticker.volume
        print(f"{symbol}: ${price:.2f} | Vol: {volume}")

ib.pendingTickersEvent += on_pending_tickers

# Subscribe to all
for contract in contracts:
    ib.reqMktData(contract, '', False, False)

# Run forever
ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Real-Time Bar Processing

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
contract = ib.qualifyContracts(contract)[0]

def on_bar_update(bars, hasNewBar):
    if hasNewBar:
        bar = bars[-1]
        print(f"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}")

bars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)
bars.updateEvent += on_bar_update

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

###  Pattern: Portfolio Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def show_portfolio():
    print("\n=== PORTFOLIO ===")
    for item in ib.portfolio():
        symbol = item.contract.symbol
        pos = item.position
        price = item.marketPrice
        value = item.marketValue
        pnl = item.unrealizedPNL
        print(f"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}")
    
    print("\n=== ACCOUNT ===")
    values = ib.accountValues()
    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']
    for value in values:
        if value.tag in important_tags:
            print(f"{value.tag:20} | {value.value:15} {value.currency}")

def on_update(item):
    show_portfolio()

# Show initial state
show_portfolio()

# Update on changes
ib.updatePortfolioEvent += on_update

ib.run()
```

> **Note:** Single example, no duplicates found

### Missing tick data

```python
# Don't use waitOnUpdate() loop for ticks - data loss!

# ❌ BAD
while True:
    ib.waitOnUpdate()
    # Some ticks lost!

# ✅ GOOD - Use events
ticker.updateEvent += lambda t: process(t)
```

> **Note:** Single example, no duplicates found

### Too many requests

```python
# IB throttles automatically at 45 req/sec
# Monitor throttle events:

def on_throttle_start():
    print("Throttling started")

def on_throttle_end():
    print("Throttling ended")

ib.client.throttleStart += on_throttle_start
ib.client.throttleEnd += on_throttle_end
```

> **Note:** Single example, no duplicates found

### Event loop conflicts

```python
# At start of notebook:
util.startLoop()

# If still issues:
util.patchAsyncio()

# For old notebooks:
import nest_asyncio
nest_asyncio.apply()
```

> **Note:** Single example, no duplicates found


## Forex

### Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.

```python
contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',          # '' = now
    durationStr='30 D',      # 30 days
    barSizeSetting='1 hour',
    whatToShow='TRADES',     # Can be MIDPOINT for FX
    useRTH=True              # Regular hours only
)

# Convert to pandas
df = util.df(bars)
print(df.head())
```

> **Note:** Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df


## Historical

### Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.

```python
contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',          # '' = now
    durationStr='30 D',      # 30 days
    barSizeSetting='1 hour',
    whatToShow='TRADES',     # Can be MIDPOINT for FX
    useRTH=True              # Regular hours only
)

# Convert to pandas
df = util.df(bars)
print(df.head())
```

> **Note:** Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df


## Ibkr

### Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds).

```python
class ib_insync.contract.ContractType(**kwargs)
    [Contract Type Description]

    dict()
        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
        Return type: dict

    nonDefaults()
        For a dataclass instance get the fields that are different from the default values and return as dict.
        Return type: dict

    tuple()
        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
        Return type: tuple

    update(*srcObjs, **kwargs)
        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
        Return type: object

    comboLegs: List[ComboLeg]
```

> **Note:** Variations occur only in contract-specific descriptions: Bond = 'Bond.', MutualFund = 'Mutual fund.', Warrant = 'Warrant option.', Bag = 'Bag contract.'. Method implementations and comboLegs attribute are identical across all contract types. Minor formatting differences exist in source docs (asterisks/spacing) but don't affect functionality.


## Limit_Price

### Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.

```python
order.lmtPrice = 176.0
trade = ib.placeOrder(contract, order)
```

> **Note:** Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.


## Margin

### The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis.

```python
orderState = ib.whatIfOrder(contract, order)
# Test order without placing
# Returns OrderState with commission/margin impact

# OrderState fields:
# .initMarginBefore
# .maintMarginBefore
# .equityWithLoanBefore
# .initMarginAfter
# .maintMarginAfter
# .equityWithLoanAfter
# .commission
# .minCommission
# .maxCommission
# .commissionCurrency
```

> **Note:** Example 1 focuses on field structure while Example 2 emphasizes debugging order rejections. Both agree on core usage but Example 2 adds error context and debugging practices.


## Market Data

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.


## Market-Data

### Cancels real-time market data subscriptions. Use cancelMktData to stop receiving market data (e.g., last price, bid/ask) for a specific contract. Use cancelMktDepth to stop receiving market depth (order book level 2) data for a specific contract. Both require the original Contract object used for subscription.

```python
ib.cancelMktData(contract: Contract) -> None
ib.cancelMktDepth(contract: Contract) -> None
```

> **Note:** cancelMktData stops standard market data streams while cancelMktDepth stops level 2 market depth data. They are separate methods for different subscription types but both require the same Contract parameter.


## Market-Depth

### Cancels real-time market data subscriptions. Use cancelMktData to stop receiving market data (e.g., last price, bid/ask) for a specific contract. Use cancelMktDepth to stop receiving market depth (order book level 2) data for a specific contract. Both require the original Contract object used for subscription.

```python
ib.cancelMktData(contract: Contract) -> None
ib.cancelMktDepth(contract: Contract) -> None
```

> **Note:** cancelMktData stops standard market data streams while cancelMktDepth stops level 2 market depth data. They are separate methods for different subscription types but both require the same Contract parameter.


## Modify

### Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.

```python
order.lmtPrice = 176.0
trade = ib.placeOrder(contract, order)
```

> **Note:** Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.


## Options

### Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters.

```python
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),
    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')
]

order = LimitOrder('BUY', 10, 5.50)  # Debit spread
trade = ib.placeOrder(combo, order)
```

> **Note:** Key variations: 1) Vertical spread uses same expiration/different strikes, calendar spread uses same strike/different expirations. 2) Action ratios reverse for credit spreads (SELL then BUY). 3) Order direction ('BUY'/'SELL') depends on spread type (debit/credit). Example 2 shows calendar spread construction with reversed actions.


## Order

###  Market Order

```python
from ib_insync import *
order = MarketOrder('BUY', 100)
```

> **Note:** Single example, no duplicates found

###  Limit Order

```python
order = LimitOrder('BUY', 100, 175.50)
```

> **Note:** Single example, no duplicates found

###  Stop Order

```python
order = StopOrder('SELL', 100, 170.00)  # Stop loss
```

> **Note:** Single example, no duplicates found

### Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading.

```python
parent, takeProfit, stopLoss = BracketOrder(
    'BUY', 100, 175.0,
    takeProfitPrice=185.0,
    stopLossPrice=170.0
)

for order in (parent, takeProfit, stopLoss):
    ib.placeOrder(contract, order)
```

> **Note:** Examples show different price parameters (175/185/170 vs 150/160/145) demonstrating the pattern works with any price levels. Example 1 includes 'error' tag highlighting potential error handling considerations.

### Creates a trailing stop order that tracks price movements by percentage. Specifies SELL action, 100 shares, 2% trailing offset, and Good-Til-Canceled duration. Includes order placement example requiring a valid contract object. Suitable for percentage-based trailing stop loss strategies.

```python
order = Order()
order.action = 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'
order.trailingPercent = 2.0  # Trail by 2%
order.tif = 'GTC'

# Requires valid contract object
# trade = ib.placeOrder(contract, order)
```

> **Note:** Example 2 includes order placement with contract while Example 1 stops at order configuration. Both use identical order parameters. Actual implementation requires valid contract object for placement.

###  Conditional Order

```python
# Trigger when SPY hits 450
trigger_contract = Stock('SPY', 'SMART', 'USD')
trigger_contract = ib.qualifyContracts(trigger_contract)[0]

condition = PriceCondition(
    condType=1,
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,  # Above price
    price=450.0
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [condition]
```

> **Note:** Single example, no duplicates found

### Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter.

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 10000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'
order.algoStrategy = 'Twap'
order.algoParams = [
    TagValue('startTime', '09:30:00 EST'),
    TagValue('endTime', '16:00:00 EST'),
    TagValue('allowPastEndTime', '1')
]

# Requires contract definition before placement:
# trade = ib.placeOrder(contract, order)
```

> **Note:** Example 2 adds 'allowPastEndTime=1' parameter and demonstrates order placement. Example 1 omits these but shows basic structure. Both use same core TWAP configuration.

###  Basic Pattern

```python
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

order = LimitOrder('BUY', 100, 175.0)
trade = ib.placeOrder(contract, order)

# Wait for fill
while not trade.isDone():
    ib.sleep(0.1)

print(f"Status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  With Validation

```python
# Check buying power first
order_copy = Order(**{k: v for k, v in order.__dict__.items()})
order_copy.whatIf = True

orderState = ib.whatIfOrder(contract, order_copy)
if orderState.commission > 0:
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Cancel Order

```python
ib.cancelOrder(order)
```

> **Note:** Single example, no duplicates found

### Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.

```python
order.lmtPrice = 176.0
trade = ib.placeOrder(contract, order)
```

> **Note:** Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.

###  Monitor Status

```python
def on_order_status(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")

ib.orderStatusEvent += on_order_status
```

> **Note:** Single example, no duplicates found

###  Single Option

```python
option = Option('SPY', '20240315', 450, 'C', 'SMART')
option = ib.qualifyContracts(option)[0]
order = LimitOrder('BUY', 10, 5.50)
trade = ib.placeOrder(option, order)
```

> **Note:** Single example, no duplicates found

### Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters.

```python
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),
    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')
]

order = LimitOrder('BUY', 10, 5.50)  # Debit spread
trade = ib.placeOrder(combo, order)
```

> **Note:** Key variations: 1) Vertical spread uses same expiration/different strikes, calendar spread uses same strike/different expirations. 2) Action ratios reverse for credit spreads (SELL then BUY). 3) Order direction ('BUY'/'SELL') depends on spread type (debit/credit). Example 2 shows calendar spread construction with reversed actions.

###  Time In Force

```python
'DAY'    # Day order (default)
'GTC'    # Good till cancelled
'IOC'    # Immediate or cancel
'GTD'    # Good till date
'FOK'    # Fill or kill
```

> **Note:** Single example, no duplicates found

###  Position Entry with Protection

```python
# 1. Enter position
entry = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry)

# 2. Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    avg_price = entry_trade.orderStatus.avgFillPrice
    
    # 3. Set stop loss
    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop
    ib.placeOrder(contract, stop)
    
    # 4. Set take profit
    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit
    ib.placeOrder(contract, target)
```

> **Note:** Single example, no duplicates found

###  Scale In/Out

```python
# Scale in
for qty in [25, 25, 25, 25]:
    order = LimitOrder('BUY', qty, price)
    ib.placeOrder(contract, order)
    ib.sleep(300)  # 5 min between orders

# Scale out
total_position = 100
for pct in [0.25, 0.25, 0.25, 0.25]:
    qty = int(total_position * pct)
    order = LimitOrder('SELL', qty, price)
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Error Handling

```python
def place_order_safe(ib, contract, order):
    try:
        trade = ib.placeOrder(contract, order)
        
        # Wait with timeout
        timeout = 10
        start = time.time()
        while trade.orderStatus.status == 'PendingSubmit':
            if time.time() - start > timeout:
                ib.cancelOrder(order)
                raise TimeoutError("Order submission timeout")
            ib.sleep(0.1)
        
        return trade
    except Exception as e:
        print(f"Order failed: {e}")
        return None
```

> **Note:** Single example, no duplicates found

### ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.

```python
# Synchronous event handler
def onOrderStatus(trade):
    print(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    if trade.isDone():
        print(f"Filled at: {trade.orderStatus.avgFillPrice}")

ib.orderStatusEvent += onOrderStatus

# Asynchronous event handler
async def onBarUpdate(bars, hasNewBar):
    if hasNewBar:
        print(f"New bar: {bars[-1]}")
        # Can use await inside async handlers
        await ib.qualifyContractsAsync(contract)

bars.updateEvent += onBarUpdate
```

> **Note:** Single example, no duplicates found

### The returned objects themselves—Ticker, Trade, Position, Portfolio—are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...

```python
# Trade object is automatically updated
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# trade.orderStatus updates automatically in background
def check_order_status():
    if trade.orderStatus.status == 'Filled':
        print("Order filled!")
    elif trade.isDone():
        print("Order completed")
```

> **Note:** Single example, no duplicates found

###  Trade and order management state

```python
# Get all open orders
open_orders = ib.orders()

# Get all trades (open and completed from this session)
all_trades = ib.trades()

# Get all fills from this session
fills = ib.fills()

# Request all open orders including from other clients
ib.reqAllOpenOrders()
```

> **Note:** Single example, no duplicates found

### Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets.

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Create and qualify contract
contract = Stock('AAPL', 'SMART', 'USD')
ib.qualifyContracts(contract)

# Create and place market order
order = MarketOrder('BUY', 100)
trade = ib.placeOrder(contract, order)

# Monitor order status
print(f"Order status: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

### Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders.

```python
def order_status_callback(trade):
    if trade.orderStatus.status == 'Filled':
        fill = trade.fills[-1]
        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '
              f'{fill.execution.shares} @ {fill.execution.avgPrice}')

trade.filledEvent += order_status_callback
```

> **Note:** Single example, no duplicates found

### Limit orders execute only at the specified price or better, providing price protection but no guarantee of execution. Set time-in-force parameters to control order lifespan.

```python
# Basic limit order
limit_order = LimitOrder('BUY', 100, 150.00)
trade = ib.placeOrder(contract, limit_order)

# Limit order with time-in-force
limit_order = LimitOrder('BUY', 100, 150.00)
limit_order.tif = 'GTD'  # Good Till Date
limit_order.goodTillDate = '20240331 23:59:59'
trade = ib.placeOrder(contract, limit_order)

# Allow outside regular trading hours
limit_order = LimitOrder('BUY', 100, 150.00)
limit_order.outsideRth = True
trade = ib.placeOrder(contract, limit_order)
```

> **Note:** Single example, no duplicates found

### Trailing stops follow favorable price movement, maintaining a specified distance from the highest price reached (for sells) or lowest price (for buys). They protect profits while allowing continued up...

```python
# Trailing stop with fixed dollar amount
trailing_order = Order()
trailing_order.action = 'SELL'
trailing_order.orderType = 'TRAIL'
trailing_order.totalQuantity = 100
trailing_order.auxPrice = 2.0  # Trail by $2
trailing_order.trailStopPrice = 150.0  # Initial trigger price

trade = ib.placeOrder(contract, trailing_order)

# Trailing stop with percentage
trailing_order = Order()
trailing_order.action = 'SELL'
trailing_order.orderType = 'TRAIL'
trailing_order.totalQuantity = 100
trailing_order.trailingPercent = 5.0  # Trail by 5%

trade = ib.placeOrder(contract, trailing_order)
```

> **Note:** Single example, no duplicates found

### Trailing stop limit orders trigger a limit order (rather than market order) when the stop is hit, providing more control but risking non-execution:

```python
trail_limit_order = Order()
trail_limit_order.orderType = 'TRAIL LIMIT'
trail_limit_order.totalQuantity = 100
trail_limit_order.action = 'SELL'
trail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop
trail_limit_order.auxPrice = 2.0  # Trail amount
trail_limit_order.trailStopPrice = 150.0

trade = ib.placeOrder(contract, trail_limit_order)
```

> **Note:** Single example, no duplicates found

### OCO orders link multiple orders such that when one executes, the others automatically cancel. Use for scenarios like placing buy orders at multiple price levels where you only want one fill.

```python
# Using the helper method (recommended)
orders = [
    LimitOrder('BUY', 100, 150.00),
    LimitOrder('BUY', 100, 149.00),
    LimitOrder('BUY', 100, 148.00)
]

oca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)

for order in oca_orders:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Manual OCO setup provides more control over individual order parameters:

```python
oca_group_name = 'MyOCAGroup_123'

order1 = LimitOrder('BUY', 100, 150.00)
order1.ocaGroup = oca_group_name
order1.ocaType = 2  # Proportional reduction with block
order1.transmit = False

order2 = LimitOrder('BUY', 100, 149.00)
order2.ocaGroup = oca_group_name
order2.ocaType = 2
order2.transmit = False

order3 = LimitOrder('BUY', 100, 148.00)
order3.ocaGroup = oca_group_name
order3.ocaType = 2
order3.transmit = True  # Last order triggers transmission

ib.placeOrder(contract, order1)
ib.placeOrder(contract, order2)
ib.placeOrder(contract, order3)
```

> **Note:** Single example, no duplicates found

### Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af...

```python
# Using the helper function (recommended)
bracket = ib.bracketOrder(
    'BUY',
    quantity=100,
    limitPrice=150.00,
    takeProfitPrice=155.00,
    stopLossPrice=145.00
)

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For market entry instead of limit entry, modify the parent order:

```python
bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)
bracket[0].orderType = 'MKT'
bracket[0].lmtPrice = 0

for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Manual bracket construction for full control:

```python
parent = Order()
parent.orderId = ib.client.getReqId()
parent.action = 'BUY'
parent.orderType = 'LMT'
parent.totalQuantity = 100
parent.lmtPrice = 150.00
parent.transmit = False

takeProfit = Order()
takeProfit.orderId = parent.orderId + 1
takeProfit.action = 'SELL'
takeProfit.orderType = 'LMT'
takeProfit.totalQuantity = 100
takeProfit.lmtPrice = 155.00
takeProfit.parentId = parent.orderId
takeProfit.transmit = False

stopLoss = Order()
stopLoss.orderId = parent.orderId + 2
stopLoss.action = 'SELL'
stopLoss.orderType = 'STP'
stopLoss.auxPrice = 145.00
stopLoss.totalQuantity = 100
stopLoss.parentId = parent.orderId
stopLoss.transmit = True  # Last order triggers all

ib.placeOrder(contract, parent)
ib.placeOrder(contract, takeProfit)
ib.placeOrder(contract, stopLoss)
```

> **Note:** Single example, no duplicates found

### Scale out of positions by setting multiple take-profit levels:

```python
from typing import NamedTuple

class BracketOrderTwoTargets(NamedTuple):
    parent: Order
    takeProfit1: Order
    takeProfit2: Order
    stopLoss: Order

def bracket_two_targets(action, quantity, limit_price, 
                       tp_price1, tp_price2, sl_price, ib):
    """Create bracket with two take-profit targets"""
    
    parent = LimitOrder(action, quantity, limit_price)
    parent.orderId = ib.client.getReqId()
    parent.transmit = False
    
    # First take profit (half position)
    takeProfit1 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price1
    )
    takeProfit1.orderId = parent.orderId + 1
    takeProfit1.parentId = parent.orderId
    takeProfit1.transmit = False
    
    # Second take profit (remaining half)
    takeProfit2 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price2
    )
    takeProfit2.orderId = parent.orderId + 2
    takeProfit2.parentId = parent.orderId
    takeProfit2.transmit = False
    
    # Stop loss for full position
    stopLoss = StopOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity,
        sl_price
    )
    stopLoss.orderId = parent.orderId + 3
    stopLoss.parentId = parent.orderId
    stopLoss.transmit = True
    
    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)

# Usage
bracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)
for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:

```python
contract = Forex('GBPUSD')
ib.qualifyContracts(contract)

# Place entry order
parent_order = MarketOrder('BUY', 25000)
trade = ib.placeOrder(contract, parent_order)

# Wait for fill
ib.sleep(1)
while trade.orderStatus.status != 'Filled':
    ib.waitOnUpdate()

# Calculate levels based on actual fill price
fill_price = trade.orderStatus.avgFillPrice
stop_loss_price = fill_price - 0.0015
take_profit_price = fill_price + 0.0020

# Place child orders
stop_loss_order = StopOrder('SELL', 25000, stop_loss_price)
take_profit_order = LimitOrder('SELL', 25000, take_profit_price)

ib.placeOrder(contract, stop_loss_order)
ib.placeOrder(contract, take_profit_order)
```

> **Note:** Single example, no duplicates found

###  Order status monitoring

```python
# Trade object attributes
trade.order          # The original order
trade.orderStatus    # Current status object
trade.fills          # List of fills
trade.log            # Log of status changes
trade.isActive()     # Is order still active
trade.isDone()       # Is order complete

# Order status values
# PendingSubmit, PendingCancel, PreSubmitted, Submitted, 
# Filled, Cancelled, Inactive, ApiPending

# Event callbacks for monitoring
def on_fill(trade, fill):
    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')

trade.fillEvent += on_fill

def on_filled(trade):
    total = sum(f.execution.shares for f in trade.fills)
    avg_price = trade.orderStatus.avgFillPrice
    print(f'Complete: {total} shares @ avg {avg_price}')

trade.filledEvent += on_filled

def on_status(trade):
    print(f'Status: {trade.orderStatus.status}')

trade.statusEvent += on_status
```

> **Note:** Single example, no duplicates found

### Always validate and handle qualification failures before placing orders:

```python
def validate_futures_contract(ib, contract):
    """Validate and qualify a futures contract"""
    try:
        qualified = ib.qualifyContracts(contract)
        if not qualified:
            print(f"ERROR: Contract could not be qualified")
            return None
        
        contract = qualified[0]
        print(f"✓ Qualified: {contract.localSymbol}")
        print(f"  ConId: {contract.conId}")
        print(f"  Expiry: {contract.lastTradeDateOrContractMonth}")
        return contract
    except Exception as e:
        print(f"ERROR: {e}")
        return None

# Usage
contract = Future('ES', '202506', 'CME')
validated = validate_futures_contract(ib, contract)
if validated:
    order = MarketOrder('BUY', 1)
    trade = ib.placeOrder(validated, order)
```

> **Note:** Single example, no duplicates found

### The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl...

```python
# Request data for expired contract
contract = Future('ES', '202012', 'CME')
contract.includeExpired = True

qualified = ib.qualifyContracts(contract)
if qualified:
    bars = ib.reqHistoricalData(
        qualified[0],
        endDateTime='',
        durationStr='1 Y',
        barSizeSetting='1 day',
        whatToShow='TRADES',
        useRTH=True
    )
    print(f"Retrieved {len(bars)} bars")
```

> **Note:** Single example, no duplicates found

### Order book (Level II) data showing bid and ask depth. Requires Level II market data subscription:

```python
contract = Forex('EURUSD')

ticker = ib.reqMktDepth(contract)
ib.sleep(2)

# Access order book
print("Bids:", [(d.price, d.size) for d in ticker.domBids[:5]])
print("Asks:", [(d.price, d.size) for d in ticker.domAsks[:5]])
```

> **Note:** Single example, no duplicates found

### For futures trading, complex order types like OCO and trailing stops require careful setup:

```python
# Trailing stop for ES futures
def place_es_trailing_stop(ib, action, quantity, trail_amount):
    """Place a trailing stop order for ES futures"""
    # Get current front month ES contract
    es = get_front_month_contract(ib, 'ES', 'CME')
    
    # Create trailing stop order
    order = Order()
    order.action = action  # 'BUY' or 'SELL'
    order.orderType = 'TRAIL'
    order.totalQuantity = quantity
    order.auxPrice = trail_amount  # Trail amount in points
    
    # Place the order
    trade = ib.placeOrder(es, order)
    return trade

# Market-Limit OCO for MNQ futures
def place_mnq_market_limit_oco(ib, action, quantity, limit_price):
    """Place a market-limit OCO order for MNQ futures"""
    # Get current front month MNQ contract
    mnq = get_front_month_contract(ib, 'MNQ', 'CME')
    
    # Create OCO orders
    market_order = MarketOrder(action, quantity)
    limit_order = LimitOrder(action, quantity, limit_price)
    
    # Set up OCO group
    oca_group = f"MNQ_OCO_{int(time.time())}"  # Unique group ID
    
    market_order.ocaGroup = oca_group
    market_order.ocaType = 2  # Proportional
    
    limit_order.ocaGroup = oca_group
    limit_order.ocaType = 2
    
    # Place orders
    trade1 = ib.placeOrder(mnq, market_order)
    trade2 = ib.placeOrder(mnq, limit_order)
    
    return [trade1, trade2]
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

###  Code Examples
- Fetching consecutive historical data
- Async streaming ticks
- Scanner data (blocking)
- Scanner data (streaming)
- Option calculations
- Order book
- Minimum price increments
- News ...

```python
pip install ib_insync


from ib_insync import *
# util.startLoop() # uncomment this line when in a notebook
ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
contract, endDateTime='', durationStr='30 D',
barSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)

# convert to pandas dataframe:
df = util.df(bars)
print(df)
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### 
Order

```python
#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',
totalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =
1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:
str = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',
ocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,
blockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,
triggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,
goodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:
bool = False, minQty: int = 2147483647, percentOffset: float =
1.7976931348623157e+308, overridePercentageConstraints: bool = False,
trailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =
1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str
= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',
origin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:
float = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,
nbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool
= False, auctionStrategy: int = 0, startingPrice: float =
1.7976931348623157e+308, stockRefPrice: float =
1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,
stockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float
= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:
bool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int
= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =
1.7976931348623157e+308, deltaNeutralConId: int = 0,
deltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',
deltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',
deltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,
deltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,
referencePriceType: int = 2147483647, basisPoints: float =
1.7976931348623157e+308, basisPointsType: int = 2147483647,
scaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,
scalePriceIncrement: float = 1.7976931348623157e+308,
scalePriceAdjustValue: float = 1.7976931348623157e+308,
scalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =
1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:
int = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:
bool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',
account: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:
str = '', algoStrategy: str = '', algoParams:
~typing.List[~ib_insync.contract.TagValue] = <factory>,
smartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =
<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,
solicited: bool = False, modelCode: str = '', orderComboLegs:
~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,
orderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,
referenceContractId: int = 0, peggedChangeAmount: float = 0.0,
isPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float
= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:
float = 1.7976931348623157e+308, adjustedStopPrice: float =
1.7976931348623157e+308, adjustedStopLimitPrice: float =
1.7976931348623157e+308, adjustedTrailingAmount: float =
1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:
float = 1.7976931348623157e+308, conditions:
~typing.List[~ib_insync.order.OrderCondition] = <factory>,
conditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,
extOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =
<factory>, cashQty: float = 1.7976931348623157e+308,
mifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',
mifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',
dontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,

Order for trading contracts.
https://interactivebrokers.github.io/tws-api/available_orders.html
orderId: int = 0
clientId: int = 0
permId: int = 0
action: str = ''
totalQuantity: float = 0.0
orderType: str = ''
lmtPrice: float = 1.7976931348623157e+308
auxPrice: float = 1.7976931348623157e+308
tif: str = ''
activeStartTime: str = ''
activeStopTime: str = ''
ocaGroup: str = ''
ocaType: int = 0
orderRef: str = ''
transmit: bool = True
parentId: int = 0
blockOrder: bool = False
sweepToFill: bool = False
displaySize: int = 0
triggerMethod: int = 0
outsideRth: bool = False
hidden: bool = False
goodAfterTime: str = ''
goodTillDate: str = ''
rule80A: str = ''
allOrNone: bool = False
minQty: int = 2147483647
percentOffset: float = 1.7976931348623157e+308
overridePercentageConstraints: bool = False
trailStopPrice: float = 1.7976931348623157e+308
trailingPercent: float = 1.7976931348623157e+308
faGroup: str = ''
faProfile: str = ''
faMethod: str = ''
faPercentage: str = ''
designatedLocation: str = ''
openClose: str = 'O'
origin: int = 0
shortSaleSlot: int = 0
exemptCode: int = -1
discretionaryAmt: float = 0.0
eTradeOnly: bool = False
firmQuoteOnly: bool = False
nbboPriceCap: float = 1.7976931348623157e+308
optOutSmartRouting: bool = False
auctionStrategy: int = 0
startingPrice: float = 1.7976931348623157e+308
stockRefPrice: float = 1.7976931348623157e+308
delta: float = 1.7976931348623157e+308
stockRangeLower: float = 1.7976931348623157e+308
stockRangeUpper: float = 1.7976931348623157e+308
randomizePrice: bool = False
randomizeSize: bool = False
volatility: float = 1.7976931348623157e+308
volatilityType: int = 2147483647
deltaNeutralOrderType: str = ''
deltaNeutralAuxPrice: float = 1.7976931348623157e+308
deltaNeutralConId: int = 0
deltaNeutralSettlingFirm: str = ''
deltaNeutralClearingAccount: str = ''
deltaNeutralClearingIntent: str = ''
deltaNeutralOpenClose: str = ''
deltaNeutralShortSale: bool = False
deltaNeutralShortSaleSlot: int = 0
deltaNeutralDesignatedLocation: str = ''
continuousUpdate: bool = False
referencePriceType: int = 2147483647
basisPoints: float = 1.7976931348623157e+308
basisPointsType: int = 2147483647
scaleInitLevelSize: int = 2147483647
scaleSubsLevelSize: int = 2147483647
scalePriceIncrement: float = 1.7976931348623157e+308
scalePriceAdjustValue: float = 1.7976931348623157e+308
scalePriceAdjustInterval: int = 2147483647
scaleProfitOffset: float = 1.7976931348623157e+308
scaleAutoReset: bool = False
scaleInitPosition: int = 2147483647
scaleInitFillQty: int = 2147483647
scaleRandomPercent: bool = False
scaleTable: str = ''
hedgeType: str = ''
hedgeParam: str = ''
account: str = ''
settlingFirm: str = ''
clearingAccount: str = ''
clearingIntent: str = ''
algoStrategy: str = ''
algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
algoId: str = ''
whatIf: bool = False
notHeld: bool = False
solicited: bool = False
modelCode: str = ''
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
referenceContractId: int = 0
peggedChangeAmount: float = 0.0
isPeggedChangeAmountDecrease: bool = False
referenceChangeAmount: float = 0.0
referenceExchangeId: str = ''
adjustedOrderType: str = ''
triggerPrice: float = 1.7976931348623157e+308
adjustedStopPrice: float = 1.7976931348623157e+308
adjustedStopLimitPrice: float = 1.7976931348623157e+308
adjustedTrailingAmount: float = 1.7976931348623157e+308
adjustableTrailingUnit: int = 0
lmtPriceOffset: float = 1.7976931348623157e+308
conditions: List[OrderCondition]
conditionsCancelOrder: bool = False
conditionsIgnoreRth: bool = False
extOperator: str = ''
softDollarTier: SoftDollarTier
cashQty: float = 1.7976931348623157e+308
mifid2DecisionMaker: str = ''
mifid2DecisionAlgo: str = ''
mifid2ExecutionTrader: str = ''
mifid2ExecutionAlgo: str = ''
dontUseAutoPriceForHedge: bool = False
isOmsContainer: bool = False
discretionaryUpToLimitPrice: bool = False
autoCancelDate: str = ''
filledQuantity: float = 1.7976931348623157e+308
refFuturesConId: int = 0
autoCancelParent: bool = False
shareholder: str = ''
imbalanceOnly: bool = False
routeMarketableToBbo: bool = False
parentPermId: int = 0
usePriceMgmtAlgo: bool = False
duration: int = 2147483647
postToAts: int = 2147483647
advancedErrorOverride: str = ''
manualOrderTime: str = ''
minTradeQty: int = 2147483647
minCompeteSize: int = 2147483647
competeAgainstBestOffset: float = 1.7976931348623157e+308
midOffsetAtWhole: float = 1.7976931348623157e+308
midOffsetAtHalf: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)
dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

algoParams: List[TagValue]
smartComboRoutingParams: List[TagValue]
orderComboLegs: List[OrderComboLeg]
orderMiscOptions: List[TagValue]
conditions: List[OrderCondition]
softDollarTier: SoftDollarTier

#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =
0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,
lastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',
mktCapPrice: float = 0.0)

orderId: int = 0
status: str = ''
filled: float = 0.0
remaining: float = 0.0
avgFillPrice: float = 0.0
permId: int = 0
parentId: int = 0
lastFillPrice: float = 0.0
clientId: int = 0
whyHeld: str = ''
mktCapPrice: float = 0.0
PendingSubmit: ClassVar[str] = 'PendingSubmit'
PendingCancel: ClassVar[str] = 'PendingCancel'
PreSubmitted: ClassVar[str] = 'PreSubmitted'
Submitted: ClassVar[str] = 'Submitted'
ApiPending: ClassVar[str] = 'ApiPending'
ApiCancelled: ClassVar[str] = 'ApiCancelled'
Cancelled: ClassVar[str] = 'Cancelled'
Filled: ClassVar[str] = 'Filled'
Inactive: ClassVar[str] = 'Inactive'
DoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}
ActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',
'Submitted'}

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',
equityWithLoanBefore: str = '', initMarginChange: str = '',
maintMarginChange: str = '', equityWithLoanChange: str = '',
initMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:
str = '', commission: float = 1.7976931348623157e+308,
minCommission: float = 1.7976931348623157e+308, maxCommission:
float = 1.7976931348623157e+308, commissionCurrency: str = '',
warningText: str = '', completedTime: str = '', completedStatus: str = '')

status: str = ''
initMarginBefore: str = ''
maintMarginBefore: str = ''
equityWithLoanBefore: str = ''
initMarginChange: str = ''
maintMarginChange: str = ''
equityWithLoanChange: str = ''
initMarginAfter: str = ''
maintMarginAfter: str = ''
equityWithLoanAfter: str = ''
commission: float = 1.7976931348623157e+308
minCommission: float = 1.7976931348623157e+308
maxCommission: float = 1.7976931348623157e+308
commissionCurrency: str = ''
warningText: str = ''
completedTime: str = ''
completedStatus: str = ''
dict()

Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)

price: float = 1.7976931348623157e+308

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:
~ib_insync.order.Order = <factory>, orderStatus:
~ib_insync.order.OrderStatus = <factory>, fills:
~typing.List[~ib_insync.objects.Fill] = <factory>, log:
~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:
str = '')
Trade keeps track of an order, its status and all its fills.
Events:
-statusEvent (trade: Trade)
-modifyEvent (trade: Trade)
-fillEvent (trade: Trade, fill: Fill)
-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)
-filledEvent (trade: Trade)
-cancelEvent (trade: Trade)
-cancelledEvent (trade: Trade)
events: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',
'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')
contract: Contract
order: Order
orderStatus: OrderStatus
fills: List[Fill]
log: List[TradeLogEntry]
advancedError: str = ''
isActive()
True if eligible for execution, false otherwise.
isDone()
True if completely filled or cancelled, false otherwise.
filled()
Number of shares filled.
remaining()
Number of shares remaining to be filled.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)
Create new instance of BracketOrder(parent, takeProfit, stopLoss)
property parent
property takeProfit
property stopLoss

#### class ib_insync.order.OrderCondition
static createClass(condType)
And()
Or()

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,
price: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =
0)
condType: int = 1
conjunction: str = 'a'
isMore: bool = True
price: float = 0.0
conId: int = 0
exch: str = ''
triggerMethod: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:
str = '')
condType: int = 3
conjunction: str = 'a'
isMore: bool = True
time: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,
percent: int = 0)
condType: int = 4
conjunction: str = 'a'
isMore: bool = True
percent: int = 0

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict
tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',
exch: str = '', symbol: str = '')
condType: int = 5
conjunction: str = 'a'
secType: str = ''
exch: str = ''
symbol: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,
volume: int = 0, conId: int = 0, exch: str = '')
condType: int = 6
conjunction: str = 'a'
isMore: bool = True
volume: int = 0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =
True, changePercent: float = 0.0, conId: int = 0, exch: str
= '')
condType: int = 7
conjunction: str = 'a'
isMore: bool = True
changePercent: float = 0.0
conId: int = 0
exch: str = ''

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

onDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
```

> **Note:** Single example, no duplicates found

### 
Contract

```python
Financial instrument types used by Interactive Brokers

class ib_insync.contract.Contract(secType: str = '', conId: int = 0, symbol: str = '',
lastTradeDateOrContractMonth: str = '', strike: float = 0.0, right: str =
'', multiplier: str = '', exchange: str = '', primaryExchange: str = '',
currency: str = '', localSymbol: str = '', tradingClass: str = '',
includeExpired: bool = False, secIdType: str = '', secId: str = '',
description: str = '', issuerId: str = '', comboLegsDescrip: str = '',
comboLegs: ~typing.List[~ib_insync.contract.ComboLeg] = <factory>,
deltaNeutralContract:
~typing.Optional[~ib_insync.contract.DeltaNeutralContract] = None)
Contract(**kwargs) can create any contract using keyword arguments. To simplify working with contracts,
there are also more specialized contracts that take optional positional arguments. Some examples:


Contract(conId=270639)
Stock('AMD', 'SMART', 'USD')
Stock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')
Forex('EURUSD')
CFD('IBUS30')
Future('ES', '20180921', 'CME')
Option('SPY', '20170721', 240, 'C', 'SMART')
Bond(secIdType='ISIN', secId='US03076KAA60')
Crypto('BTC', 'PAXOS', 'USD')

Parameters
-conId (int) -The unique IB contract identifier.
-symbol (str) -The contract (or its underlying) symbol.
-secType (str) -The security type:
– ’STK’ = Stock (or ETF)
– ’OPT’ = Option
– ’FUT’ = Future
– ’IND’ = Index
– ’FOP’ = Futures option
– ’CASH’ = Forex pair
– ’CFD’ = CFD
– ’BAG’ = Combo
– ’WAR’ = Warrant
– ’BOND’ = Bond
– ’CMDTY’ = Commodity
– ’NEWS’ = News
– ’FUND’ = Mutual fund
– ’CRYPTO’ = Crypto currency
-lastTradeDateOrContractMonth (str) -The contract’s last trading day or contract
month (for Options and Futures). Strings with format YYYYMM will be interpreted as
the Contract Month whereas YYYYMMDD will be interpreted as Last Trading Day.
-strike (float) -The option’s strike price.
-right (str) -Put or Call. Valid values are ‘P’, ‘PUT’, ‘C’, ‘CALL’, or ‘’ for non-options.
-multiplier (str) -he instrument’s multiplier (i.e. options, futures).
-exchange (str) -The destination exchange.
-currency (str) -The underlying’s currency.
-localSymbol (str) -The contract’s symbol within its primary exchange. For options, this
will be the OCC symbol.
-primaryExchange (str) -The contract’s primary exchange. For smart routed contracts,
used to define contract in case of ambiguity. Should be defined as native exchange of contract,
e.g. ISLAND for MSFT. For exchanges which contain a period in name, will only be part of
exchange name prior to period, i.e. ENEXT for ENEXT.BE.
-tradingClass (str) -The trading class name for this contract. Available in TWS contract
description window as well. For example, GBL Dec ‘13 future’s trading class is “FGBL”.
-includeExpired (bool) -If set to true, contract details requests and historical data queries
can be performed pertaining to expired futures contracts. Expired options or other instrument
types are not available.
-secIdType (str) -Security identifier type. Examples for Apple:
– secIdType=’ISIN’, secId=’US0378331005’
– secIdType=’CUSIP’, secId=’037833100’
-secId (str) -Security identifier.
-comboLegsDescription (str) -Description of the combo legs.
-comboLegs (List[ComboLeg]) -The legs of a combined contract definition.
-deltaNeutralContract (DeltaNeutralContract) -Delta and underlying price for
Delta-Neutral combo orders.
secType: str = ''
conId: int = 0
symbol: str = ''
lastTradeDateOrContractMonth: str = ''
strike: float = 0.0
right: str = ''
multiplier: str = ''
exchange: str = ''
primaryExchange: str = ''
currency: str = ''
localSymbol: str = ''
tradingClass: str = ''
includeExpired: bool = False
secIdType: str = ''
secId: str = ''
description: str = ''
issuerId: str = ''
comboLegsDescrip: str = ''
comboLegs: List[ComboLeg]
deltaNeutralContract: Optional[DeltaNeutralContract] = None

static create(**kwargs)
Create and a return a specialized contract based on the given secType, or a general Contract if secType is
not given.
Return type
Contract

isHashable()
See if this contract can be hashed by conId.
Note: Bag contracts always get conId=28812380, so they’re not hashable.
Return type
bool

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple
update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object

#### class ib_insync.contract.Stock(symbol='', exchange='', currency='', **kwargs)
Stock contract.
Parameters
-symbol (str) -Symbol name.
-exchange (str) -Destination exchange.
-currency (str) -Underlying currency.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from
keyword arguments.
Return type
object
comboLegs: List[ComboLeg]

#### class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',
exchange='', multiplier='', currency='', **kwargs)
Option contract.
Parameters
-symbol (str) -Symbol name.
-lastTradeDateOrContractMonth (str) -The option’s last trading day or contract month.
– YYYYMM format: To specify last month
– YYYYMMDD format: To specify last trading day
-strike (float) -The option’s strike price.
-right (str) -Put or call option. Valid values are ‘P’, ‘PUT’, ‘C’ or ‘CALL’.
-exchange (str) -Destination exchange.
-multiplier (str) -The contract multiplier.
-currency (str) -Underlying currency.

dict()
Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
Return type
dict

nonDefaults()
For a dataclass instance get the fields that are different from the default values and return as dict.
Return type
dict

tuple()
Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
Return type
tuple

update(*srcObjs, **kwargs)
Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
Return type
object

comboLegs: List[ComboLeg]
```

> **Note:** Single example, no duplicates found

###  Order book

```python
eurusd = Forex('EURUSD')
ticker = ib.reqMktDepth(eurusd)
while ib.sleep(5):
print(
[d.price for d in ticker.domBids],
[d.price for d in ticker.domAsks])
```

> **Note:** Single example, no duplicates found

###  Price-Based Condition

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Order triggers when SPY hits 450
contract = Stock('AAPL', 'SMART', 'USD')
trigger_contract = Stock('SPY', 'SMART', 'USD')

# Qualify both
contract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)

# Create price condition
condition = PriceCondition(
    condType=1,  # Price
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,  # True = above, False = below
    price=450.0
)

# Create order with condition
order = LimitOrder('BUY', 100, 175.0)
order.conditions = [condition]
order.conditionsIgnoreRth = False
order.conditionsCancelOrder = False

trade = ib.placeOrder(contract, order)
print(f"Conditional order placed: {trade.order.orderId}")
```

> **Note:** Single example, no duplicates found

###  Time-Based Condition

```python
from datetime import datetime, timedelta

# Order triggers at specific time
time_condition = TimeCondition(
    condType=3,  # Time
    isMore=True,
    time=datetime.now() + timedelta(hours=1)
)

order = MarketOrder('BUY', 100)
order.conditions = [time_condition]
trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Volume-Based Condition

```python
# Trigger when daily volume exceeds threshold
volume_condition = VolumeCondition(
    condType=4,  # Volume
    conId=contract.conId,
    exchange='SMART',
    isMore=True,
    volume=10000000  # 10M shares
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [volume_condition]
trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Multiple Conditions (AND/OR)

```python
# Order triggers when BOTH conditions met
price_cond = PriceCondition(
    condType=1,
    conId=trigger_contract.conId,
    exchange='SMART',
    isMore=True,
    price=450.0
)

volume_cond = VolumeCondition(
    condType=4,
    conId=contract.conId,
    exchange='SMART',
    isMore=True,
    volume=5000000
)

order = LimitOrder('BUY', 100, 175.0)
order.conditions = [price_cond, volume_cond]
order.conditionsIgnoreRth = False
order.conditionsCancelOrder = False  # False = AND, True = OR

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Places advanced order types in Interactive Brokers API. Covers:
1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount
2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)
3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging
4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging
5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO
Common parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.

```python
order = Order()
order.action = 'BUY'  # or 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL
# For TRAIL: set auxPrice (fixed trail amount)
# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent
# For PEG MID/PEG BEST: no additional price fields
# For REL: set lmtPrice (offset from NBBO)
order.tif = 'GTC'  # or other time in force

trade = ib.placeOrder(contract, order)
```

> **Note:** Key variations:
- TRAIL requires auxPrice (fixed $ trail)
- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)
- PEG MID/PEG BEST require no price parameters
- REL uses lmtPrice for NBBO offset
- Action (BUY/SELL) varies by use case
- All examples use GTC time-in-force but other values are possible

###  Multiple Exits from Same Entry

```python
# Buy at market, then set multiple exit strategies
entry_order = MarketOrder('BUY', 100)
entry_trade = ib.placeOrder(contract, entry_order)

# Wait for fill
while not entry_trade.isDone():
    ib.sleep(0.1)

if entry_trade.orderStatus.status == 'Filled':
    # Create OCA group for exits
    oca_group = f"OCA_{int(time.time())}"
    
    # Exit 1: Take profit at +5%
    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)
    exit1.ocaGroup = oca_group
    exit1.ocaType = 1  # Cancel all on fill
    
    # Exit 2: Stop loss at -2%
    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)
    exit2.ocaGroup = oca_group
    exit2.ocaType = 1
    
    # Exit 3: Trailing stop
    exit3 = Order()
    exit3.action = 'SELL'
    exit3.totalQuantity = 100
    exit3.orderType = 'TRAIL'
    exit3.trailingPercent = 3.0
    exit3.ocaGroup = oca_group
    exit3.ocaType = 1
    
    for order in [exit1, exit2, exit3]:
        ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  VWAP (Volume-Weighted Average Price)

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 10000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'

order.algoStrategy = 'Vwap'
order.algoParams = [
    TagValue('maxPctVol', '0.1'),  # Max 10% of volume
    TagValue('startTime', '09:30:00 EST'),
    TagValue('endTime', '16:00:00 EST'),
    TagValue('allowPastEndTime', '1'),
    TagValue('noTakeLiq', '1')
]

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Adaptive (IB's Smart Routing)

```python
order = Order()
order.action = 'BUY'
order.totalQuantity = 1000
order.orderType = 'LMT'
order.lmtPrice = 175.0
order.tif = 'DAY'

order.algoStrategy = 'Adaptive'
order.algoParams = [
    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient
]

trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Vertical Spread (Bull Call Spread)

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

# Define legs
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')

# Qualify
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

# Create combo contract
combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

# Define legs
leg1 = ComboLeg()
leg1.conId = buy_call.conId
leg1.ratio = 1
leg1.action = 'BUY'
leg1.exchange = 'SMART'

leg2 = ComboLeg()
leg2.conId = sell_call.conId
leg2.ratio = 1
leg2.action = 'SELL'
leg2.exchange = 'SMART'

combo.comboLegs = [leg1, leg2]

# Place order
order = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50
trade = ib.placeOrder(combo, order)
```

> **Note:** Single example, no duplicates found

###  Iron Condor

```python
# Four-leg strategy: sell OTM call spread + sell OTM put spread
buy_call = Option('SPY', '20240315', 470, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 465, 'C', 'SMART')
buy_put = Option('SPY', '20240315', 430, 'P', 'SMART')
sell_put = Option('SPY', '20240315', 435, 'P', 'SMART')

# Qualify all
contracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)

# Create BAG
combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call
    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call
    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put
    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put
]

# Place as credit spread
order = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit
trade = ib.placeOrder(combo, order)
```

> **Note:** JSON parse failed. Raw response: {
  "canonical_code": "```python\n# Four-leg strategy: sell OTM call spread + sell OTM put spread\nb...

###  Delta Hedging Pattern

```python
# Dynamic delta hedging for options position
def calculate_position_delta(portfolio):
    """Calculate total portfolio delta"""
    total_delta = 0.0
    
    for item in portfolio:
        if item.contract.secType == 'OPT':
            # Request option computations
            ticker = ib.reqMktData(item.contract, '', False, False)
            ib.sleep(1)
            
            if ticker.modelGreeks:
                delta = ticker.modelGreeks.delta
                total_delta += delta * item.position
            
            ib.cancelMktData(item.contract)
    
    return total_delta

def hedge_delta(underlying_contract, target_delta=0.0):
    """Adjust underlying position to achieve target delta"""
    portfolio = ib.portfolio()
    current_delta = calculate_position_delta(portfolio)
    
    delta_to_hedge = current_delta - target_delta
    
    if abs(delta_to_hedge) > 0.1:  # Threshold
        # Delta of stock is 1.0
        shares_to_trade = int(delta_to_hedge * 100)  # Per contract
        
        if shares_to_trade > 0:
            order = MarketOrder('SELL', abs(shares_to_trade))
        else:
            order = MarketOrder('BUY', abs(shares_to_trade))
        
        trade = ib.placeOrder(underlying_contract, order)
        print(f"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}")
        
        return trade
    else:
        print(f"Delta within tolerance: {current_delta:.2f}")
        return None

# Run periodically
underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

while True:
    hedge_delta(underlying, target_delta=0.0)
    ib.sleep(300)  # Every 5 minutes
```

> **Note:** Single example, no duplicates found

###  Comprehensive Error Handler

```python
from ib_insync import *
import logging

class IBErrorHandler:
    def __init__(self, ib):
        self.ib = ib
        self.error_log = []
        self.ib.errorEvent += self.on_error
        
    def on_error(self, reqId, errorCode, errorString, contract):
        """Centralized error handling"""
        error_info = {
            'time': datetime.now(),
            'reqId': reqId,
            'code': errorCode,
            'message': errorString,
            'contract': contract
        }
        self.error_log.append(error_info)
        
        # Categorize and handle
        if errorCode in [502, 503, 504]:
            self.handle_connection_error(errorCode, errorString)
        elif errorCode in [200, 201, 202]:
            self.handle_order_error(errorCode, errorString, contract)
        elif errorCode == 162:
            self.handle_data_error(errorCode, errorString, contract)
        elif errorCode == 354:
            self.handle_market_data_subscription_error(errorCode, errorString)
        elif errorCode in [2104, 2106, 2158]:
            # Info messages - ignore
            pass
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def handle_connection_error(self, code, message):
        """Handle connection failures"""
        logging.critical(f"Connection error {code}: {message}")
        # Trigger reconnection
        self.schedule_reconnect()
    
    def handle_order_error(self, code, message, contract):
        """Handle order rejections"""
        logging.error(f"Order error {code}: {message} for {contract}")
        # Could retry with modified params
        # Or alert user
    
    def handle_data_error(self, code, message, contract):
        """Handle data request failures"""
        logging.warning(f"Data error {code}: {message} for {contract}")
        # Retry with different params
    
    def handle_market_data_subscription_error(self, code, message):
        """Handle market data subscription issues"""
        logging.warning(f"Market data error {code}: {message}")
        # Fall back to delayed data
        self.ib.reqMarketDataType(3)  # Delayed
    
    def schedule_reconnect(self):
        """Schedule reconnection attempt"""
        # Implementation in reconnection section
        pass

# Usage
ib = IB()
error_handler = IBErrorHandler(ib)
ib.connect('127.0.0.1', 7497, clientId=1)
```

> **Note:** Single example, no duplicates found

###  Order Validation Before Submission

```python
def validate_order(ib, contract, order):
    """Validate order before placing"""
    errors = []
    
    # 1. Check contract is qualified
    if contract.conId == 0:
        errors.append("Contract not qualified")
    
    # 2. Check buying power
    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}
    
    if order.action == 'BUY':
        # Estimate cost
        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot
        ib.sleep(1)
        
        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN
            estimated_cost = ticker.ask * order.totalQuantity
            if estimated_cost > account_values.get('BuyingPower', 0):
                errors.append(f"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}")
        
        ib.cancelMktData(contract)
    
    # 3. What-if order check
    try:
        order_copy = Order(**{k: v for k, v in order.__dict__.items()})
        order_copy.whatIf = True
        
        orderState = ib.whatIfOrder(contract, order_copy)
        
        if orderState.commission and orderState.commission > 0:
            # Valid response
            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):
                errors.append("Insufficient margin")
        else:
            errors.append("What-if order returned invalid state")
            
    except Exception as e:
        errors.append(f"What-if validation failed: {e}")
    
    # 4. Check trading hours
    details = ib.reqContractDetails(contract)
    if details:
        # Parse trading hours (simplified)
        # Would need full implementation
        pass
    
    return errors

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
order = LimitOrder('BUY', 1000, 175.0)

validation_errors = validate_order(ib, contract, order)
if validation_errors:
    print("Order validation failed:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    trade = ib.placeOrder(contract, order)
    print("Order placed successfully")
```

> **Note:** Single example, no duplicates found

###  Retry Logic with Exponential Backoff

```python
import time
from functools import wraps

def retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):
    """Decorator for retrying failed operations"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            delay = base_delay
            
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    retries += 1
                    if retries >= max_retries:
                        logging.error(f"{func.__name__} failed after {max_retries} retries: {e}")
                        raise
                    
                    logging.warning(f"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...")
                    time.sleep(delay)
                    delay = min(delay * 2, max_delay)  # Exponential backoff
            
        return wrapper
    return decorator

# Usage
@retry_with_backoff(max_retries=3, base_delay=2.0)
def place_order_with_retry(ib, contract, order):
    """Place order with automatic retry"""
    trade = ib.placeOrder(contract, order)
    
    # Wait for submission
    timeout = 10
    start = time.time()
    while trade.orderStatus.status in ['PendingSubmit', '']:
        if time.time() - start > timeout:
            raise TimeoutError("Order submission timeout")
        ib.sleep(0.1)
    
    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:
        raise Exception(f"Order cancelled: {trade.orderStatus.status}")
    
    return trade

# Usage
try:
    trade = place_order_with_retry(ib, contract, order)
    print(f"Order placed: {trade.order.orderId}")
except Exception as e:
    print(f"Order failed: {e}")
```

> **Note:** Single example, no duplicates found

###  Position Reconciliation

```python
class PositionManager:
    def __init__(self, ib):
        self.ib = ib
        self.expected_positions = {}  # conId -> quantity
        
    def record_trade(self, trade):
        """Record expected position change"""
        if trade.orderStatus.status == 'Filled':
            conId = trade.contract.conId
            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()
            
            if conId in self.expected_positions:
                self.expected_positions[conId] += qty
            else:
                self.expected_positions[conId] = qty
    
    def reconcile(self):
        """Check actual vs expected positions"""
        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}
        
        discrepancies = []
        
        # Check expected positions
        for conId, expected_qty in self.expected_positions.items():
            actual_qty = actual_positions.get(conId, 0)
            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding
                discrepancies.append({
                    'conId': conId,
                    'expected': expected_qty,
                    'actual': actual_qty,
                    'diff': actual_qty - expected_qty
                })
        
        # Check for unexpected positions
        for conId, actual_qty in actual_positions.items():
            if conId not in self.expected_positions and abs(actual_qty) > 0.01:
                discrepancies.append({
                    'conId': conId,
                    'expected': 0,
                    'actual': actual_qty,
                    'diff': actual_qty
                })
        
        if discrepancies:
            logging.warning(f"Position discrepancies found: {discrepancies}")
        
        return discrepancies
    
    def reset_tracking(self):
        """Reset to current positions"""
        self.expected_positions = {
            p.contract.conId: p.position 
            for p in self.ib.positions()
        }

# Usage
pm = PositionManager(ib)
pm.reset_tracking()

# Track trades
ib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)

# Periodic reconciliation
while True:
    discrepancies = pm.reconcile()
    if discrepancies:
        # Alert or take action
        pass
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Close All Positions

```python
def close_all_positions(ib, exclude_symbols=None):
    """Emergency position closer"""
    exclude_symbols = exclude_symbols or []
    
    positions = ib.positions()
    trades = []
    
    for position in positions:
        symbol = position.contract.symbol
        
        if symbol in exclude_symbols:
            continue
        
        qty = abs(position.position)
        action = 'SELL' if position.position > 0 else 'BUY'
        
        order = MarketOrder(action, qty)
        trade = ib.placeOrder(position.contract, order)
        trades.append(trade)
        
        print(f"Closing {action} {qty} {symbol}")
    
    # Wait for all to fill
    timeout = 30
    start = time.time()
    
    while any(not t.isDone() for t in trades):
        if time.time() - start > timeout:
            logging.error("Timeout waiting for position closures")
            break
        ib.sleep(0.5)
    
    return trades

# Usage - emergency exit
if emergency_condition:
    close_all_positions(ib)
```

> **Note:** Single example, no duplicates found

###  Position Size Calculator

```python
def calculate_position_size(
    ib,
    contract,
    risk_per_trade_pct=0.02,  # 2% risk
    stop_loss_pct=0.05         # 5% stop
):
    """Calculate position size based on risk"""
    
    # Get account value
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    # Calculate dollar risk
    dollar_risk = net_liq * risk_per_trade_pct
    
    # Get current price
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if not ticker.last or ticker.last != ticker.last:  # NaN check
        logging.error("Unable to get price for position sizing")
        return 0
    
    price = ticker.last
    ib.cancelMktData(contract)
    
    # Calculate shares
    # dollar_risk = shares * price * stop_loss_pct
    shares = dollar_risk / (price * stop_loss_pct)
    
    # Round to nearest tradeable lot
    if contract.secType == 'OPT':
        shares = int(shares / 100) * 100  # Options in contracts (100 shares)
    else:
        shares = int(shares)
    
    print(f"Position size for {contract.symbol}: {shares} shares")
    print(f"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})")
    
    return shares

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

shares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)

if shares > 0:
    order = LimitOrder('BUY', shares, 175.0)
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Daily Loss Limit

```python
class DailyLossLimiter:
    def __init__(self, ib, max_daily_loss_pct=0.05):
        self.ib = ib
        self.max_daily_loss_pct = max_daily_loss_pct
        self.start_equity = None
        self.breached = False
        
    def initialize(self):
        """Set starting equity for the day"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        self.breached = False
        print(f"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}")
    
    def check_limit(self):
        """Check if daily loss limit breached"""
        if self.breached:
            return True
        
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            self.breached = True
            logging.critical(f"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)")
            return True
        
        return False
    
    def enforce(self):
        """Close all positions and cancel all orders"""
        if not self.breached:
            return
        
        print("Enforcing daily loss limit...")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        close_all_positions(self.ib)
        
        print("All positions closed. Trading halted for the day.")

# Usage
limiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit
limiter.initialize()

# Check periodically
while True:
    if limiter.check_limit():
        limiter.enforce()
        break
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Max Position Concentration

```python
def check_position_concentration(ib, max_position_pct=0.20):
    """Ensure no single position exceeds % of portfolio"""
    
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    violations = []
    
    for item in ib.portfolio():
        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0
        
        if position_pct > max_position_pct:
            violations.append({
                'symbol': item.contract.symbol,
                'value': item.marketValue,
                'pct': position_pct,
                'limit': max_position_pct
            })
    
    if violations:
        logging.warning(f"Position concentration violations: {violations}")
    
    return violations

# Check before placing order
def place_order_with_concentration_check(ib, contract, order, max_pct=0.20):
    """Place order only if it doesn't violate concentration"""
    
    # Estimate new position value
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if ticker.ask:
        estimated_value = ticker.ask * order.totalQuantity
        
        account_values = {v.tag: float(v.value) for v in ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        # Get current position
        current_position = next(
            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),
            0
        )
        
        new_position_value = abs(current_position + estimated_value)
        new_pct = new_position_value / net_liq if net_liq > 0 else 0
        
        if new_pct > max_pct:
            logging.error(f"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%")
            ib.cancelMktData(contract)
            return None
    
    ib.cancelMktData(contract)
    return ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Target Allocation Rebalancer

```python
class PortfolioRebalancer:
    def __init__(self, ib):
        self.ib = ib
        
    def rebalance_to_target(self, target_allocations, tolerance=0.05):
        """
        Rebalance portfolio to target allocations
        
        Args:
            target_allocations: Dict[symbol: str, target_pct: float]
                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}
            tolerance: Rebalance threshold (0.05 = 5%)
        """
        
        # Validate target allocations
        total = sum(target_allocations.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Target allocations must sum to 1.0, got {total}")
        
        # Get current portfolio
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}
        
        # Calculate current allocations
        current_allocations = {
            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)
            for symbol, item in portfolio.items()
        }
        
        # Determine needed trades
        trades_needed = []
        
        for symbol, target_pct in target_allocations.items():
            current_pct = current_allocations.get(symbol, 0)
            diff = target_pct - current_pct
            
            if abs(diff) > tolerance:
                target_value = net_liq * target_pct
                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0
                value_change = target_value - current_value
                
                # Get current price
                contract = Stock(symbol, 'SMART', 'USD')
                contract = self.ib.qualifyContracts(contract)[0]
                
                ticker = self.ib.reqMktData(contract, '', True, False)
                self.ib.sleep(1)
                
                if ticker.last and ticker.last == ticker.last:
                    price = ticker.last
                    shares_change = int(value_change / price)
                    
                    if shares_change != 0:
                        trades_needed.append({
                            'symbol': symbol,
                            'contract': contract,
                            'current_pct': current_pct,
                            'target_pct': target_pct,
                            'shares': shares_change,
                            'action': 'BUY' if shares_change > 0 else 'SELL'
                        })
                
                self.ib.cancelMktData(contract)
        
        # Execute trades
        if not trades_needed:
            logging.info("Portfolio within tolerance. No rebalancing needed.")
            return []
        
        logging.info(f"Rebalancing {len(trades_needed)} positions...")
        placed_trades = []
        
        for trade_info in trades_needed:
            logging.info(f"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} "
                        f"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)")
            
            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))
            trade = self.ib.placeOrder(trade_info['contract'], order)
            placed_trades.append(trade)
        
        return placed_trades

# Usage
target = {
    'AAPL': 0.30,
    'GOOGL': 0.30,
    'MSFT': 0.40
}

rebalancer = PortfolioRebalancer(ib)
trades = rebalancer.rebalance_to_target(target, tolerance=0.03)

# Monitor fills
for trade in trades:
    while not trade.isDone():
        ib.sleep(1)
    print(f"{trade.contract.symbol}: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Dollar-Cost Averaging

```python
class DCAScheduler:
    def __init__(self, ib):
        self.ib = ib
        self.schedules = []
        
    def add_schedule(self, symbol, amount_per_period, frequency_days):
        """
        Add DCA schedule
        
        Args:
            symbol: Stock symbol
            amount_per_period: Dollar amount to invest
            frequency_days: Days between purchases
        """
        self.schedules.append({
            'symbol': symbol,
            'amount': amount_per_period,
            'frequency': frequency_days,
            'last_purchase': None
        })
    
    def check_and_execute(self):
        """Check if any DCA purchases are due"""
        from datetime import datetime, timedelta
        
        now = datetime.now()
        
        for schedule in self.schedules:
            last = schedule['last_purchase']
            
            # Check if purchase is due
            if last is None or (now - last).days >= schedule['frequency']:
                self.execute_dca(schedule)
                schedule['last_purchase'] = now
    
    def execute_dca(self, schedule):
        """Execute DCA purchase"""
        symbol = schedule['symbol']
        amount = schedule['amount']
        
        # Create contract
        contract = Stock(symbol, 'SMART', 'USD')
        contract = self.ib.qualifyContracts(contract)[0]
        
        # Get current price
        ticker = self.ib.reqMktData(contract, '', True, False)
        self.ib.sleep(1)
        
        if ticker.last and ticker.last == ticker.last:
            price = ticker.last
            shares = int(amount / price)
            
            if shares > 0:
                logging.info(f"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})")
                order = MarketOrder('BUY', shares)
                trade = self.ib.placeOrder(contract, order)
                return trade
        
        self.ib.cancelMktData(contract)
        return None

# Usage
dca = DCAScheduler(ib)
dca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days
dca.add_schedule('VTI', 500, 14)   # $500 every 14 days

# Run daily check
while True:
    dca.check_and_execute()
    ib.sleep(86400)  # Check daily
```

> **Note:** Single example, no duplicates found

###  Multi-Account Order Router

```python
class MultiAccountRouter:
    def __init__(self, host='127.0.0.1', port=7497):
        self.connections = {}
        self.host = host
        self.port = port
        
    def add_account(self, account_name, client_id):
        """Add account connection"""
        ib = IB()
        ib.connect(self.host, self.port, client_id)
        self.connections[account_name] = ib
        logging.info(f"Connected account {account_name} with clientId {client_id}")
    
    def place_order_all(self, contract, order_template, quantities):
        """
        Place orders across multiple accounts
        
        Args:
            contract: Contract to trade
            order_template: Base order
            quantities: Dict[account_name, quantity]
        """
        trades = {}
        
        for account_name, quantity in quantities.items():
            if account_name not in self.connections:
                logging.error(f"Account {account_name} not connected")
                continue
            
            ib = self.connections[account_name]
            
            # Clone order
            order = Order(**{k: v for k, v in order_template.__dict__.items()})
            order.totalQuantity = quantity
            order.account = account_name
            
            # Place order
            trade = ib.placeOrder(contract, order)
            trades[account_name] = trade
            
            logging.info(f"Placed {order.action} {quantity} {contract.symbol} for {account_name}")
        
        return trades
    
    def get_combined_portfolio(self):
        """Get combined portfolio across all accounts"""
        combined = {}
        
        for account_name, ib in self.connections.items():
            for item in ib.portfolio():
                symbol = item.contract.symbol
                
                if symbol not in combined:
                    combined[symbol] = {
                        'position': 0,
                        'market_value': 0,
                        'unrealized_pnl': 0,
                        'accounts': {}
                    }
                
                combined[symbol]['position'] += item.position
                combined[symbol]['market_value'] += item.marketValue
                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL
                combined[symbol]['accounts'][account_name] = item.position
        
        return combined
    
    def disconnect_all(self):
        """Disconnect all accounts"""
        for account_name, ib in self.connections.items():
            ib.disconnect()
            logging.info(f"Disconnected {account_name}")

# Usage
router = MultiAccountRouter()
router.add_account('Account1', client_id=1)
router.add_account('Account2', client_id=2)
router.add_account('Account3', client_id=3)

# Place order across all accounts
contract = Stock('AAPL', 'SMART', 'USD')
order_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account

quantities = {
    'Account1': 100,
    'Account2': 200,
    'Account3': 150
}

trades = router.place_order_all(contract, order_template, quantities)

# Monitor combined portfolio
combined = router.get_combined_portfolio()
for symbol, data in combined.items():
    print(f"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts")
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Events

```python
events = (
    'connectedEvent',       # Connection established
    'disconnectedEvent',    # Connection lost
    'updateEvent',          # Any state update
    'pendingTickersEvent',  # Ticker updates available
    'barUpdateEvent',       # Real-time bar update
    'newOrderEvent',        # New order created
    'orderModifyEvent',     # Order modified
    'cancelOrderEvent',     # Order cancel requested
    'openOrderEvent',       # Open order status
    'orderStatusEvent',     # Order status changed
    'execDetailsEvent',     # Trade execution details
    'commissionReportEvent',# Commission report
    'updatePortfolioEvent', # Portfolio updated
    'positionEvent',        # Position changed
    'accountValueEvent',    # Account value updated
    'accountSummaryEvent',  # Account summary updated
    'pnlEvent',            # PnL update
    'pnlSingleEvent',      # Single position PnL
    'scannerDataEvent',    # Scanner data received
    'tickNewsEvent',       # News tick
    'newsBulletinEvent',   # News bulletin
    'errorEvent',          # Error occurred
    'timeoutEvent'         # Request timeout
)
```

> **Note:** Single example, no duplicates found

###  State Properties

```python
# Access current state (auto-synced)
ib.accountValues()      # List[AccountValue]
ib.portfolio()          # List[PortfolioItem]
ib.positions()          # List[Position]
ib.trades()             # List[Trade]
ib.openTrades()         # List[Trade] - open only
ib.orders()             # List[Order]
ib.openOrders()         # List[Order] - open only
ib.fills()              # List[Fill]
ib.executions()         # List[Execution]
ib.tickers()            # List[Ticker]
ib.pendingTickers()     # Set[Ticker] - with updates
ib.reqId()              # int - next request ID
```

> **Note:** Single example, no duplicates found

###  Base Contract

```python
@dataclass
class Contract:
    conId: int = 0              # Unique IB contract ID
    symbol: str = ''            # Ticker symbol
    secType: str = ''           # Security type
    lastTradeDateOrContractMonth: str = ''
    strike: float = 0.0
    right: str = ''             # 'C' or 'P' for options
    multiplier: str = ''
    exchange: str = ''
    primaryExchange: str = ''
    currency: str = ''
    localSymbol: str = ''
    tradingClass: str = ''
    includeExpired: bool = False
    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC
    secId: str = ''
    description: str = ''
    issuerId: str = ''
    comboLegsDescrip: str = ''
    comboLegs: List = None      # For combo orders
    deltaNeutralContract: DeltaNeutralContract = None
```

> **Note:** Single example, no duplicates found

###  Contract Details

```python
details = ib.reqContractDetails(contract)
# Returns List[ContractDetails]

# ContractDetails fields:
# .contract - Fully qualified contract
# .marketName
# .minTick
# .priceMagnifier
# .orderTypes
# .validExchanges
# .underConId
# .longName
# .contractMonth
# .industry
# .category
# .subcategory
# .timeZoneId
# .tradingHours
# .liquidHours
# And many more...
```

> **Note:** Single example, no duplicates found

###  Base Order

```python
@dataclass
class Order:
    orderId: int = 0
    clientId: int = 0
    permId: int = 0
    action: str = ''            # 'BUY' or 'SELL'
    totalQuantity: float = 0.0
    orderType: str = ''         # See order types below
    lmtPrice: float = 0.0
    auxPrice: float = 0.0       # Stop price
    tif: str = 'DAY'            # Time in force
    
    # Advanced fields
    ocaGroup: str = ''          # One-Cancels-All group
    account: str = ''
    openClose: str = 'O'        # 'O'=open, 'C'=close
    origin: int = 0             # 0=customer
    orderRef: str = ''
    transmit: bool = True       # Auto-transmit
    parentId: int = 0           # For bracket orders
    blockOrder: bool = False
    sweepToFill: bool = False
    displaySize: int = 0
    triggerMethod: int = 0
    outsideRth: bool = False    # Outside regular hours
    hidden: bool = False
    
    # Order combos
    goodAfterTime: str = ''
    goodTillDate: str = ''
    rule80A: str = ''
    allOrNone: bool = False
    minQty: int = None
    percentOffset: float = None
    overridePercentageConstraints: bool = False
    trailStopPrice: float = None
    trailingPercent: float = None
    
    # Financial advisors
    faGroup: str = ''
    faProfile: str = ''
    faMethod: str = ''
    faPercentage: str = ''
    
    # Institutional
    designatedLocation: str = ''
    exemptCode: int = -1
    
    # Smart routing
    discretionaryAmt: float = 0.0
    eTradeOnly: bool = False
    firmQuoteOnly: bool = False
    nbboPriceCap: float = None
    optOutSmartRouting: bool = False
    
    # Pegged orders
    stockRefPrice: float = None
    delta: float = None
    
    # Volatility orders
    volatility: float = None
    volatilityType: int = None
    deltaNeutralOrderType: str = ''
    deltaNeutralAuxPrice: float = None
    deltaNeutralConId: int = 0
    deltaNeutralShortSale: bool = False
    deltaNeutralShortSaleSlot: int = 0
    deltaNeutralDesignatedLocation: str = ''
    continuousUpdate: bool = False
    referencePriceType: int = None
    
    # Conditions
    conditions: List = None
    conditionsIgnoreRth: bool = False
    conditionsCancelOrder: bool = False
    
    # Algo orders
    algoStrategy: str = ''
    algoParams: List = None
    
    # What-if
    whatIf: bool = False
    
    # Misc
    notHeld: bool = False
    solicited: bool = False
    randomizeSize: bool = False
    randomizePrice: bool = False
    
    # Pegged to benchmark
    referenceContractId: int = 0
    peggedChangeAmount: float = 0.0
    isPeggedChangeAmountDecrease: bool = False
    referenceChangeAmount: float = 0.0
    referenceExchangeId: str = ''
    adjustedOrderType: str = ''
    
    # Misc2
    modelCode: str = ''
    extOperator: str = ''
    cashQty: float = None
    mifid2DecisionMaker: str = ''
    mifid2DecisionAlgo: str = ''
    mifid2ExecutionTrader: str = ''
    mifid2ExecutionAlgo: str = ''
    dontUseAutoPriceForHedge: bool = False
    
    # Manual times (for audit)
    manualOrderTime: str = ''
    manualOrderCancelTime: str = ''
    
    # Post to ATS
    usePriceMgmtAlgo: bool = None
```

> **Note:** Single example, no duplicates found

###  Market Order

```python
MarketOrder(action: str, totalQuantity: float, **kwargs)

# Examples
order = MarketOrder('BUY', 100)
order = MarketOrder('SELL', 50, tif='GTC')
```

> **Note:** Single example, no duplicates found

###  Limit Order

```python
LimitOrder(
    action: str,
    totalQuantity: float,
    lmtPrice: float,
    **kwargs
)

# Examples
order = LimitOrder('BUY', 100, 150.50)
order = LimitOrder('SELL', 50, 155.00, tif='GTC')
```

> **Note:** Single example, no duplicates found

### Represents stop and stop-limit order types. Stop orders become market orders when the stop price is reached. Stop-limit orders become limit orders with both a stop price (trigger) and limit price (execution constraint). Use StopOrder for basic stop-loss orders (single price trigger) and StopLimitOrder for price-controlled executions.

```python
StopLimitOrder(
    action: str,
    totalQuantity: float,
    lmtPrice: float,
    stopPrice: float,
    **kwargs
)
```

> **Note:** Key difference: StopOrder requires only stopPrice while StopLimitOrder needs both lmtPrice and stopPrice. Example 1 demonstrates a stop-loss, Example 2 shows a stop-limit with price control.

###  Bracket Order

```python
BracketOrder(
    action: str,
    quantity: float,
    limitPrice: float,
    takeProfitPrice: float,
    stopLossPrice: float
) -> Tuple[Order, Order, Order]

# Returns (parent, takeProfit, stopLoss)
# Example
parent, takeProfit, stopLoss = BracketOrder(
    'BUY', 100, 150.0, 160.0, 145.0
)
```

> **Note:** Single example, no duplicates found

###  Place Order

```python
trade = ib.placeOrder(contract: Contract, order: Order) -> Trade
# Returns Trade object (live-updated)

# Example
contract = Stock('AAPL', 'SMART', 'USD')
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# Trade object updated in real-time:
# - trade.orderStatus
# - trade.fills
# - trade.log
```

> **Note:** Single example, no duplicates found

###  Cancel Order

```python
trade = ib.cancelOrder(order: Order) -> Trade

# Cancel all orders
ib.reqGlobalCancel()
```

> **Note:** Single example, no duplicates found

###  Order Status

```python
@dataclass
class OrderStatus:
    orderId: int = 0
    status: str = ''        # PendingSubmit, Submitted, Filled, Cancelled, etc.
    filled: float = 0.0
    remaining: float = 0.0
    avgFillPrice: float = 0.0
    permId: int = 0
    parentId: int = 0
    lastFillPrice: float = 0.0
    clientId: int = 0
    whyHeld: str = ''
    mktCapPrice: float = 0.0
```

> **Note:** Single example, no duplicates found

###  Trade Object

```python
@dataclass
class Trade:
    contract: Contract = None
    order: Order = None
    orderStatus: OrderStatus = None
    fills: List[Fill] = []
    log: List[TradeLogEntry] = []
    
    # Methods
    def isActive(self) -> bool
    def isDone(self) -> bool
    def filled(self) -> float
    def remaining(self) -> float
```

> **Note:** Single example, no duplicates found

### The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis.

```python
orderState = ib.whatIfOrder(contract, order)
# Test order without placing
# Returns OrderState with commission/margin impact

# OrderState fields:
# .initMarginBefore
# .maintMarginBefore
# .equityWithLoanBefore
# .initMarginAfter
# .maintMarginAfter
# .equityWithLoanAfter
# .commission
# .minCommission
# .maxCommission
# .commissionCurrency
```

> **Note:** Example 1 focuses on field structure while Example 2 emphasizes debugging order rejections. Both agree on core usage but Example 2 adds error context and debugging practices.

###  Trade Events

```python
# New order placed
ib.newOrderEvent += lambda trade: print(f'New order: {trade}')

# Order modified
ib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')

# Order status changed
ib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')

# Execution received
ib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')

# Commission report
ib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')
```

> **Note:** Single example, no duplicates found

### Errors:

```python
200 - No security definition found
201 - Order rejected
202 - Order cancelled
321 - Error validating request
326 - Unable to connect (check port)
354 - Requested market data not subscribed
404 - Order held
502 - Couldn't connect to TWS
```

> **Note:** Single example, no duplicates found

###  Pattern: Automated Trading Strategy

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

contract = Stock('SPY', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

# Strategy parameters
quantity = 100
entry_price = None
position = 0

def on_tick(ticker):
    global entry_price, position
    price = ticker.last
    
    if price is None or price != price:  # NaN check
        return
    
    # Entry logic
    if position == 0 and should_enter(price):
        order = MarketOrder('BUY', quantity)
        trade = ib.placeOrder(contract, order)
        entry_price = price
        position = quantity
        print(f"ENTRY: Buy {quantity} @ {price}")
    
    # Exit logic
    elif position > 0 and should_exit(price, entry_price):
        order = MarketOrder('SELL', quantity)
        trade = ib.placeOrder(contract, order)
        profit = (price - entry_price) * quantity
        print(f"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}")
        position = 0
        entry_price = None

def should_enter(price):
    # Your entry logic
    return False

def should_exit(price, entry):
    # Your exit logic (e.g., stop loss, take profit)
    return False

ticker = ib.reqMktData(contract, '233', False, False)
ticker.updateEvent += on_tick

ib.run()
```

> **Note:** Single example, no duplicates found

### Orders not showing

```python
# Check:
# 1. Correct clientId
# 2. "Download open orders on connection" enabled in TWS
# 3. Use ib.openOrders() not ib.reqOpenOrders()

# Sync orders
ib.reqOpenOrders()  # Legacy, can be stale
ib.openOrders()     # Better - auto-synced
```

> **Note:** Single example, no duplicates found


## Pandas

### Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.

```python
contract = Forex('EURUSD')
bars = ib.reqHistoricalData(
    contract,
    endDateTime='',          # '' = now
    durationStr='30 D',      # 30 days
    barSizeSetting='1 hour',
    whatToShow='TRADES',     # Can be MIDPOINT for FX
    useRTH=True              # Regular hours only
)

# Convert to pandas
df = util.df(bars)
print(df.head())
```

> **Note:** Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df


## Pegged_Order

### Places advanced order types in Interactive Brokers API. Covers:
1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount
2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)
3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging
4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging
5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO
Common parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.

```python
order = Order()
order.action = 'BUY'  # or 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL
# For TRAIL: set auxPrice (fixed trail amount)
# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent
# For PEG MID/PEG BEST: no additional price fields
# For REL: set lmtPrice (offset from NBBO)
order.tif = 'GTC'  # or other time in force

trade = ib.placeOrder(contract, order)
```

> **Note:** Key variations:
- TRAIL requires auxPrice (fixed $ trail)
- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)
- PEG MID/PEG BEST require no price parameters
- REL uses lmtPrice for NBBO offset
- Action (BUY/SELL) varies by use case
- All examples use GTC time-in-force but other values are possible


## Portfolio

### For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def onTicker(ticker):
    print(f"Price update: {ticker.contract.symbol} @ {ticker.last}")

ticker = ib.reqMktData(contract)
ticker.updateEvent += onTicker

ib.run()  # Runs event loop indefinitely
```

> **Note:** Single example, no duplicates found

### The IB class provides the user-facing interface, but internally delegates all state storage to the Wrapper. This Wrapper maintains dictionaries for account values, portfolio items, positions, trades, ...

```python
# Internal architecture (conceptual)
IB Instance
    └── Wrapper Instance (single source of truth)
        ├── accountValues (dict)
        ├── acctSummary (dict)
        ├── portfolio (defaultdict)
        ├── positions (defaultdict)
        ├── trades (dict)
        ├── tickers (dict)
        └── [other state collections]
    └── Client Instance (network communication)
```

> **Note:** Single example, no duplicates found

### The critical pattern: never store copies of state in long-lived variables. Always call IB methods to access current state. Stored copies become stale as the Wrapper updates in the background.

```python
# CORRECT - access live state
def check_positions():
    positions = ib.positions()
    for pos in positions:
        print(f"{pos.contract.symbol}: {pos.position}")

# WRONG - storing stale copies
cached_positions = ib.positions()  # Snapshot becomes stale
# Later...
print(cached_positions)  # Likely outdated
```

> **Note:** Single example, no duplicates found

### The returned objects themselves—Ticker, Trade, Position, Portfolio—are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...

```python
# Trade object is automatically updated
order = LimitOrder('BUY', 100, 150.0)
trade = ib.placeOrder(contract, order)

# trade.orderStatus updates automatically in background
def check_order_status():
    if trade.orderStatus.status == 'Filled':
        print("Order filled!")
    elif trade.isDone():
        print("Order completed")
```

> **Note:** Single example, no duplicates found

### Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking.

```python
def onPositionUpdate(position):
    print(f"Position: {position.contract.symbol}: {position.position}")

ib.positionEvent += onPositionUpdate

def onPortfolioUpdate(item):
    print(f"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}")

ib.updatePortfolioEvent += onPortfolioUpdate
```

> **Note:** Single example, no duplicates found

### The global updateEvent fires on any state change, useful for triggering comprehensive checks:

```python
def onUpdate():
    positions = ib.positions()
    print(f"Current positions: {len(positions)}")

ib.updateEvent += onUpdate
```

> **Note:** Single example, no duplicates found

### When performing calculations or processing that takes significant time, yield control to the event loop periodically using ib.sleep(0). This allows the Wrapper to process incoming messages and update ...

```python
def long_calculation():
    for i in range(1000):
        result = expensive_operation()
        
        # Periodically yield to allow state updates
        if i % 100 == 0:
            ib.sleep(0)
        
        # State may have changed during sleep
        current_positions = ib.positions()
```

> **Note:** Single example, no duplicates found

###  Patterns for accessing portfolio and positions

```python
# All portfolio items across accounts
all_portfolio = ib.portfolio()

# Portfolio for specific account
account_portfolio = ib.portfolio(account='U1234567')

# All positions
all_positions = ib.positions()

# Positions for specific account
account_positions = ib.positions(account='U1234567')

# Iterate through positions
for position in ib.positions():
    symbol = position.contract.symbol
    qty = position.position
    avg_cost = position.avgCost
    print(f"{symbol}: {qty} @ ${avg_cost}")
```

> **Note:** Single example, no duplicates found

### ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.

```python
# WRONG - threading with asyncio
from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor(max_workers=2)
executor.submit(ib.positions)  # Will fail!

# CORRECT - use asyncio tasks
async def fetch_multiple_contracts():
    tasks = [
        ib.qualifyContractsAsync(contract1),
        ib.qualifyContractsAsync(contract2),
        ib.qualifyContractsAsync(contract3)
    ]
    results = await asyncio.gather(*tasks)
    return results
```

> **Note:** Single example, no duplicates found

### Caching with incorrect invalidation: If you must cache state for performance, implement short-lived caching with explicit refresh logic.

```python
class TradingBot:
    def __init__(self, ib):
        self.ib = ib
        self._positions_cache = None
        self._cache_time = None
        
    def get_positions(self, max_age=1.0):
        """Get positions with short-term caching"""
        now = time.time()
        if (self._positions_cache is None or 
            self._cache_time is None or 
            now - self._cache_time > max_age):
            self._positions_cache = self.ib.positions()
            self._cache_time = now
        return self._positions_cache
```

> **Note:** Single example, no duplicates found

###  Production-ready state manager

```python
from ib_insync import *
import logging

class IBDataManager:
    """Demonstrates best practices for single source of truth pattern"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self._setup_logging()
        self._setup_events()
    
    def _setup_logging(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def _setup_events(self):
        self.ib.connectedEvent += self._on_connected
        self.ib.disconnectedEvent += self._on_disconnected
        self.ib.positionEvent += self._on_position
        self.ib.updatePortfolioEvent += self._on_portfolio
    
    def connect(self):
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info("Connected to IB")
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _on_connected(self):
        self.logger.info("Connection established")
        self.ib.reqAccountSummary()
    
    def _on_disconnected(self):
        self.logger.warning("Disconnected from IB")
    
    def _on_position(self, position):
        self.logger.info(f"Position update: {position.contract.symbol}")
    
    def _on_portfolio(self, item):
        self.logger.info(f"Portfolio update: {item.contract.symbol}")
    
    def get_current_positions(self):
        """Get current positions (always fresh from single source)"""
        if not self.ib.isConnected():
            raise ConnectionError("Not connected")
        return self.ib.positions()
    
    def get_position_for_symbol(self, symbol):
        """Get position for specific symbol"""
        for pos in self.get_current_positions():
            if pos.contract.symbol == symbol:
                return pos
        return None
```

> **Note:** Single example, no duplicates found

### Scale out of positions by setting multiple take-profit levels:

```python
from typing import NamedTuple

class BracketOrderTwoTargets(NamedTuple):
    parent: Order
    takeProfit1: Order
    takeProfit2: Order
    stopLoss: Order

def bracket_two_targets(action, quantity, limit_price, 
                       tp_price1, tp_price2, sl_price, ib):
    """Create bracket with two take-profit targets"""
    
    parent = LimitOrder(action, quantity, limit_price)
    parent.orderId = ib.client.getReqId()
    parent.transmit = False
    
    # First take profit (half position)
    takeProfit1 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price1
    )
    takeProfit1.orderId = parent.orderId + 1
    takeProfit1.parentId = parent.orderId
    takeProfit1.transmit = False
    
    # Second take profit (remaining half)
    takeProfit2 = LimitOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity // 2,
        tp_price2
    )
    takeProfit2.orderId = parent.orderId + 2
    takeProfit2.parentId = parent.orderId
    takeProfit2.transmit = False
    
    # Stop loss for full position
    stopLoss = StopOrder(
        'SELL' if action == 'BUY' else 'BUY',
        quantity,
        sl_price
    )
    stopLoss.orderId = parent.orderId + 3
    stopLoss.parentId = parent.orderId
    stopLoss.transmit = True
    
    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)

# Usage
bracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)
for order in bracket:
    ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

### Here's a more comprehensive structure for a futures trading system:

```python
class FuturesTradingSystem:
    """Complete futures trading system with proper state management"""
    
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        
        self.active_contracts = {}  # symbol -> contract
        self.active_orders = {}     # orderId -> order
        self.active_positions = {}  # symbol -> position
        
        # Setup logger
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        logger = logging.getLogger('FuturesTradingSystem')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
        
    def connect(self):
        """Connect to IB and initialize state"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.logger.info(f"Connected to IB ({self.host}:{self.port})")
            
            # Setup event handlers
            self.ib.errorEvent += self._handle_error
            self.ib.positionEvent += self._handle_position
            self.ib.orderStatusEvent += self._handle_order_status
            
            # Initialize positions
            self._update_positions()
            
            return True
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
    
    def _update_positions(self):
        """Update current positions"""
        positions = self.ib.positions()
        
        for position in positions:
            if position.contract.secType == 'FUT':
                symbol = position.contract.symbol
                self.active_positions[symbol] = position
                self.logger.info(f"Current position: {symbol}: {position.position}")
    
    def _handle_position(self, position):
        """Handle position updates"""
        if position.contract.secType == 'FUT':
            symbol = position.contract.symbol
            self.active_positions[symbol] = position
            self.logger.info(f"Position update: {symbol}: {position.position}")
    
    def _handle_order_status(self, trade):
        """Handle order status updates"""
        orderId = trade.order.orderId
        status = trade.orderStatus.status
        
        self.logger.info(f"Order {orderId} status: {status}")
        
        # Store active orders
        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:
            self.active_orders[orderId] = trade
        # Remove completed orders
        elif status in ['Filled', 'Cancelled', 'Inactive']:
            if orderId in self.active_orders:
                del self.active_orders[orderId]
    
    def _handle_error(self, reqId, errorCode, errorString, contract):
        """Handle error events"""
        self.logger.error(f"Error {errorCode}: {errorString}")
        
        # Handle connection issues
        if errorCode in [1100, 1101, 1102]:
            self.logger.critical("Connection issue detected!")
    
    def get_contract(self, symbol, expiry, exchange):
        """Get a fully qualified futures contract"""
        contract_key = f"{symbol}_{expiry}_{exchange}"
        
        # Use cached contract if available
        if contract_key in self.active_contracts:
            return self.active_contracts[contract_key]
            
        # Otherwise qualify a new one
        contract = Future(symbol=symbol, 
                         lastTradeDateOrContractMonth=expiry,
                         exchange=exchange)
        
        qualified = self.ib.qualifyContracts(contract)
        
        if not qualified:
            self.logger.error(f"Failed to qualify contract: {symbol} {expiry}")
            return None
            
        qualified_contract = qualified[0]
        self.active_contracts[contract_key] = qualified_contract
        
        return qualified_contract
    
    def place_market_order(self, symbol, expiry, exchange, action, quantity):
        """Place market order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = MarketOrder(action, quantity)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} market order for {quantity} {symbol}")
        return trade
    
    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):
        """Place limit order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        order = LimitOrder(action, quantity, price)
        trade = self.ib.placeOrder(contract, order)
        
        self.logger.info(f"Placed {action} limit order for {quantity} {symbol} @ {price}")
        return trade
    
    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, 
                          entry_price, profit_price, stop_price):
        """Place bracket order for futures contract"""
        contract = self.get_contract(symbol, expiry, exchange)
        
        if not contract:
            return None
            
        # Create bracket orders
        bracket = self.ib.bracketOrder(
            action,
            quantity,
            entry_price,
            profit_price,
            stop_price
        )
        
        # Place all orders
        trades = []
        for order in bracket:
            trade = self.ib.placeOrder(contract, order)
            trades.append(trade)
        
        self.logger.info(f"Placed bracket order for {quantity} {symbol}")
        return trades
    
    def cancel_all_orders(self):
        """Cancel all open orders"""
        open_trades = self.ib.openTrades()
        for trade in open_trades:
            if not trade.isDone():
                self.ib.cancelOrder(trade.order)
                self.logger.info(f"Cancelled order {trade.order.orderId}")
    
    def get_position(self, symbol):
        """Get current position for symbol"""
        return self.active_positions.get(symbol)
    
    def close_position(self, symbol):
        """Close position for symbol"""
        position = self.get_position(symbol)
        
        if not position or position.position == 0:
            self.logger.info(f"No position to close for {symbol}")
            return None
        
        # Create closing order
        action = 'SELL' if position.position > 0 else 'BUY'
        quantity = abs(position.position)
        
        return self.place_market_order(
            symbol,
            position.contract.lastTradeDateOrContractMonth,
            position.contract.exchange,
            action,
            quantity
        )
    
    def run(self):
        """Run the system indefinitely"""
        try:
            self.ib.run()
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
        finally:
            # Cleanup on exit
            self.cancel_all_orders()
            self.ib.disconnect()
            self.logger.info("Disconnected from IB")
```

> **Note:** Single example, no duplicates found

### Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.

```python
events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',
          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',
          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',
          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',
          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',
          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',
          'timeoutEvent')

RequestTimeout: float = 0
RaiseRequestErrors: bool = False
MaxSyncedSubAccounts: int = 50
TimezoneTWS = None

#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')
Connect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.
**This method is blocking.**
**Parameters:**
- **host** (str) - Host name or IP address.
- **port** (int) - Port number.
- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.
- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.
- **readonly** (bool) - Set to True when API is in read-only mode.
- **account** (str) - Main account to receive updates for.
- 
#### disconnect()
Disconnect from a TWS or IB gateway application. This will clear all session state.

#### isConnected()
Is there an API connection to TWS or IB gateway?
**Return type:** bool

#### static run(*, timeout=None)
By default run the event loop forever.
When awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.
An optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.

#### static schedule(callback, *args)
Schedule the callback to be run at the given time with the given arguments. This will return the Event Handle.
**Parameters:**
- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.
- **callback** (Callable) - Callable scheduled to run.
- **args** - Arguments for to call callback with.

#### static sleep()
Wait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.
**Parameters:**
- **secs** (float) - Time in seconds to wait.
**Return type:** bool

#### static timeRange(end, step)
Iterator that waits periodically until certain time points are reached while yielding those time points.
**Parameters:**
- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date
- **step** (float) - The number of seconds of each period
**Return type:** Iterator[datetime]

#### static timeRangeAsync(end, step)
Async version of timeRange().
**Return type:** AsyncIterator[datetime]

#### static waitUntil()
Wait until the given time t is reached.
**Parameters:**
- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.
**Return type:** bool

#### waitOnUpdate(timeout=0)
Wait on any new update to arrive from the network.
**Parameters:**
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used
**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.
**Return type:** bool
**Returns:** True if not timed-out, False otherwise.

#### loopUntil(condition=None, timeout=0)
Iterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.
**Parameters:**
- **condition** - Predicate function that is tested after every network update.
- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.
**Return type:** Iterator[object]

#### setTimeout(timeout=60)
Set a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.
The timeout fires once per connected session but can be set again after firing or after a reconnect.
**Parameters:**
- **timeout** (float) - Timeout in seconds.

#### managedAccounts()
List of account names.
**Return type:** List[str]

#### accountValues(account='')
List of account values for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### accountSummary(account='')
List of account values for the given account, or of all accounts if account is left blank.
**This method is blocking on first run, non-blocking after that.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[AccountValue]

#### portfolio()
List of portfolio items of the default account.
**Return type:** List[PortfolioItem]

#### positions(account='')
List of positions for the given account, or of all accounts if account is left blank.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
**Return type:** List[Position]

#### pnl(account='', modelCode='')
List of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.
**Parameters:**
- **account** - If specified, filter for this account name.
- **modelCode** - If specified, filter for this account model.
**Return type:** List[PnL]

#### pnlSingle(account='', modelCode='', conId=0)
List of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.
- **conId** (int) - If specified, filter for this contract ID.
**Return type:** List[PnLSingle]

#### trades()
List of all order trades from this session.
**Return type:** List[Trade]

#### openTrades()
List of all open order trades.
**Return type:** List[Trade]

#### orders()
List of all orders from this session.
**Return type:** List[Order]

#### openOrders()
List of all open orders.
**Return type:** List[Order]

#### fills()
List of all fills from this session.
**Return type:** List[Fill]

#### executions()
List of all executions from this session.
**Return type:** List[Execution]

#### ticker(contract)
Get ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().
**Parameters:**
- **contract** (Contract) - Contract to get ticker for.
**Return type:** Ticker

#### tickers()
Get a list of all tickers.
**Return type:** List[Ticker]

#### pendingTickers()
Get a list of all tickers that have pending ticks or domTicks.
**Return type:** List[Ticker]

#### realtimeBars()
Get a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.
**Return type:** List[Union[BarDataList, RealTimeBarList]]

#### newsTicks()
List of ticks with headline news. The article itself can be retrieved with reqNewsArticle().
**Return type:** List[NewsTick]

#### newsBulletins()
List of IB news bulletins.
**Return type:** List[NewsBulletin]

#### reqTickers(*contracts, regulatorySnapshot=False)
Request and return a list of snapshot tickers. The list is returned when all tickers are ready.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to get tickers for.
- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).
**Return type:** List[Ticker]

#### qualifyContracts(*contracts)
Fully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.
**This method is blocking.**
**Parameters:**
- **contracts** (Contract) - Contracts to qualify.
**Return type:** List[Contract]

#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)
Create a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:

for o in bracket:
    ib.placeOrder(contract, o)
**Parameters:**
- **action** (str) - 'BUY' or 'SELL'.
- **quantity** (float) - Size of order.
- **limitPrice** (float) - Limit price of entry order.
- **takeProfitPrice** (float) - Limit price of profit order.
- **stopLossPrice** (float) - Stop price of loss order.
**Return type:** BracketOrder

#### static oneCancelsAll(orders, ocaGroup, ocaType)
Place the trades in the same One Cancels All (OCA) group.
https://interactivebrokers.github.io/tws-api/oca.html
**Parameters:**
- **orders** (List[Order]) - The orders that are to be placed together.
**Return type:** List[Order]

#### whatIfOrder(contract, order)
Retrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.
**This method is blocking.**
**Parameters:**
- **contract** (Contract) - Contract to test.
- **order** (Order) - Order to test.
**Return type:** OrderState

#### placeOrder(contract, order)
Place a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.
**Parameters:**
- **contract** (Contract) - Contract to use for order.
- **order** (Order) - The order to be placed.
**Return type:** Trade

#### cancelOrder(order, manualCancelOrderTime='')
Cancel the order and return the Trade it belongs to.
**Parameters:**
- **order** (Order) - The order to be canceled.
- **manualCancelOrderTime** (str) - For audit trail.
**Return type:** Trade

#### reqGlobalCancel()
Cancel all active trades including those placed by other clients or TWS/IB gateway.

#### reqCurrentTime()
Request TWS current time.
**This method is blocking.**
**Return type:** datetime

#### reqAccountUpdates(account='')
This is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.

#### reqAccountUpdatesMulti(account='', modelCode='')
It is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.
**This method is blocking.**
**Parameters:**
- **account** (str) - If specified, filter for this account name.
- **modelCode** (str) - If specified, filter for this account model.

#### reqAccountSummary()
It is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.
**This method is blocking.**

#### reqAutoOpenOrders(autoBind=True)
Bind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting "Use negative numbers to bind automatic orders" must be checked. This request is automatically called when clientId=0.
https://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html

**Parameters:**
- **autoBind** (bool) - Set binding on or off.

#### reqOpenOrders()
Request and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.
**This method is blocking.**
**Return type:** List[Order]

#### reqAllOpenOrders()
Request and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.
**Return type:** List[Order]

#### reqCompletedOrders(apiOnly)
Request and return a list of completed trades.
**Parameters:**
- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).
**Return type:** List[Trade]

#### reqExecutions(execFilter=None)
It is recommended to use fills() or executions() instead. Request and return a list of fills.
**This method is blocking.**
**Parameters:**
- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.
**Return type:** List[Fill]

#### reqPositions()
It is recommended to use positions() instead. Request and return a list of positions for all accounts.
**This method is blocking.**
**Return type:** List[Position]

#### reqPnL(account, modelCode='')
Start a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - If specified, filter for this account model.
**Return type:** PnL

#### cancelPnL(account, modelCode='')
Cancel PnL subscription.
**Parameters:**
- **account** - Cancel for this account.
- **modelCode** (str) - If specified, cancel for this account model.

#### reqPnLSingle(account, modelCode, conId)
Start a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().
https://interactivebrokers.github.io/tws-api/pnl.html
**Parameters:**
- **account** (str) - Subscribe to this account.
- **modelCode** (str) - Filter for this account model.
- **conId** (int) - Filter for this contract ID.
**Return type:** PnLSingle

#### cancelPnLSingle(account, modelCode, conId)
Cancel PnLSingle subscription for the given account, modelCode and conId.
**Parameters:**
- **account** (str) - Cancel for this account name.
- **modelCode** (str) - Cancel for this account model.
- **conId** (int) - Cancel for this contract ID.

#### reqContractDetails(contract)
Get a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/contract_details.html
**Parameters:**
- **contract** (Contract) - The contract to get details for.
**Return type:** List[ContractDetails]

#### reqMatchingSymbols(pattern)
Request contract descriptions of contracts that match a pattern.
**This method is blocking.**
https://interactivebrokers.github.io/tws-api/matching_symbols.html
**Parameters:**
pattern (str) -The first few letters of the ticker symbol, or for longer strings a character
sequence matching a word in the security name.
Return type
List[ContractDescription]

#### reqMarketRule(marketRuleId)
Request price increments rule.
https://interactivebrokers.github.io/tws-api/minimum_increment.html
Parameters
marketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-
tained via reqContractDetails() from ContractDetails.marketRuleIds, which con-
tains a comma separated string of market rule IDs.
Return type
PriceIncrement

#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])
Request realtime 5 second bars.
https://interactivebrokers.github.io/tws-api/realtime_bars.html
Parameters
-contract (Contract) -Contract of interest.
-barSize (int) -Must be 5.
-whatToShow (str) -Specifies the source for constructing bars. Can be ‘TRADES’, ‘MID-
POINT’, ‘BID’ or ‘ASK’.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-realTimeBarsOptions (List[TagValue]) -Unknown.
Return type
RealTimeBarList

#### cancelRealTimeBars(bars)
Cancel the realtime bars subscription.
Parameters
bars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.

#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)
Request historical bar data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_bars.html
Parameters
-contract (Contract) -Contract of interest.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-durationStr (str) -Time span of all the bars. Examples: ‘60 S’, ‘30 D’, ‘13 W’, ‘6 M’,
‘10 Y’.
-barSizeSetting (str) -Time period of one bar. Must be one of: ‘1 secs’, ‘5 secs’, ‘10
secs’ 15 secs’, ‘30 secs’, ‘1 min’, ‘2 mins’, ‘3 mins’, ‘5 mins’, ‘10 mins’, ‘15 mins’, ‘20
mins’, ‘30 mins’, ‘1 hour’, ‘2 hours’, ‘3 hours’, ‘4 hours’, ‘8 hours’, ‘1 day’, ‘1 week’, ‘1
month’.
-whatToShow (str) -Specifies the source for constructing bars. Must be one
of: ‘TRADES’, ‘MIDPOINT’, ‘BID’, ‘ASK’, ‘BID_ASK’, ‘ADJUSTED_LAST’, ‘HIS-
TORICAL_VOLATILITY’, ‘OPTION_IMPLIED_VOLATILITY’, ‘REBATE_RATE’,
‘FEE_RATE’, ‘YIELD_BID’, ‘YIELD_ASK’, ‘YIELD_BID_ASK’, ‘YIELD_LAST’. For
‘SCHEDULE’ use reqHistoricalSchedule().
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields
to be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as
used by TWS.
-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars
updated; endDateTime must be set empty (‘’) then.
-chartOptions (List[TagValue]) -Unknown.
-timeout (float) -Timeout in seconds after which to cancel the request and return an
empty bar series. Set to 0 to wait indefinitely.
Return type
BarDataList

#### cancelHistoricalData(bars)
Cancel the update subscription for the historical bars.
Parameters
bars (BarDataList) -The bar list that was obtained from reqHistoricalData with a
keepUpToDate subscription.


#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)
Request historical schedule.
This method is blocking.
Parameters
-contract (Contract) -Contract of interest.
-numDays (int) -Number of days.
-endDateTime (Union[datetime, date, str, None]) -Can be set to ‘’ to indicate the
current time, or it can be given as a datetime.date or datetime.datetime, or it can be given
as a string in ‘yyyyMMdd HH:mm:ss’ format. If no timezone is given then the TWS login
timezone is used.
-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for
extended hours.
Return type
HistoricalSchedule

#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Request historical ticks. The time resolution of the ticks is one second.
This method is blocking.
https://interactivebrokers.github.io/tws-api/historical_time_and_sales.html
Parameters
-contract (Contract) -Contract to query.
-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-
time.datetime, or it can be given as a string in ‘yyyyMMdd HH:mm:ss’ format. If no
timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be
given, the other must be blank.
-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can
contain a bit more to accommodate all ticks in the latest second.
-whatToShow (str) -One of ‘Bid_Ask’, ‘Midpoint’ or ‘Trades’.
-useRTH -If True then only show data from within Regular Trading Hours, if False then
show all data.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
-miscOptions (List[TagValue]) -Unknown.
Return type
List

#### reqMarketDataType(marketDataType)
Set the market data type used for reqMktData().
Parameters
marketDataType (int) -One of:
-1 = Live
-2 = Frozen
-3 = Delayed
-4 = Delayed frozen
https://interactivebrokers.github.io/tws-api/market_data_type.html
reqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)
Get the datetime of earliest available historical data for the contract.
Parameters
-contract (Contract) -Contract of interest.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-
time.datetime with UTC timezone.
Return type
datetime

#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,
mktDataOptions=None)
Subscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will
initially be empty and gradually (after a couple of seconds) be filled.
https://interactivebrokers.github.io/tws-api/md_request.html
Parameters
-contract (Contract) -Contract of interest.
-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause
corresponding Ticker fields to be filled:

ID  Ticker fields
100 putVolume, callVolume (for options)
101 putOpenInterest, callOpenInterest (for options)
104 histVolatility (for options)
105 avOptionVolume (for options)
106 impliedVolatility (for options)
162 indexFuturePremium
165 low13week, high13week, low26week, high26week, low52week,
high52week, avVolume
221 markPrice
225 auctionVolume, auctionPrice, auctionImbalance
233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)
236 shortableShares
258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)
293 tradeCount
294 tradeRate
295 volumeRate
375 rtTradeVolume
411 rtHistVolatility
456 dividends (of type ib_insync.objects.Dividends)
588 futuresOpenInterest

-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a
stream of realtime tick data.
-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).
-mktDataOptions (Optional[List[TagValue]]) -Unknown
Return type
Ticker

#### cancelMktData(contract)
Unsubscribe from realtime streaming tick data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.
reqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)
Subscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.
https://interactivebrokers.github.io/tws-api/tick_data.html
Parameters
-contract (Contract) -Contract of interest.
-tickType (str) -One of ‘Last’, ‘AllLast’, ‘BidAsk’ or ‘MidPoint’.
-numberOfTicks (int) -Number of ticks or 0 for unlimited.
-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.
Return type
Ticker

#### cancelTickByTickData(contract, tickType)
Unsubscribe from tick-by-tick data
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqSmartComponents(bboExchange)
Obtain mapping from single letter codes to exchange names.
Note: The exchanges must be open when using this request, otherwise an empty list is returned.
Return type
List[SmartComponent]

#### reqMktDepthExchanges()
Get those exchanges that have have multiple market makers (and have ticks returned with marketMaker
info).
Return type
List[DepthMktDataDescription]

#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)
Subscribe to market depth data (a.k.a. DOM, L2 or order book).
https://interactivebrokers.github.io/tws-api/market_depth.html
Parameters
-contract (Contract) -Contract of interest.
-numRows (int) -Number of depth level on each side of the order book (5 max).
-isSmartDepth (bool) -Consolidate the order book across exchanges.
-mktDepthOptions -Unknown.
Return type
Ticker
Returns
The Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the
list of MktDepthData in ticker.domTicks.

#### cancelMktDepth(contract, isSmartDepth=False)
Unsubscribe from market depth data.
Parameters
contract (Contract) -The exact contract object that was used to subscribe with.

#### reqHistogramData(contract, useRTH, period)
Request histogram data.
This method is blocking.
https://interactivebrokers.github.io/tws-api/histograms.html
Parameters
-contract (Contract) -Contract to query.
-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False
then show all data.
-period (str) -Period of which data is being requested, for example ‘3 days’.
Return type
List[HistogramData]

#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])
Get fundamental data of a contract in XML format.
This method is blocking.
https://interactivebrokers.github.io/tws-api/fundamentals.html
Parameters
-contract (Contract) -Contract to query.
-reportType (str) –
– ‘ReportsFinSummary’: Financial summary
– ’ReportsOwnership’: Company’s ownership
– ’ReportSnapshot’: Company’s financial overview
– ’ReportsFinStatements’: Financial Statements
– ’RESC’: Analyst Estimates
– ’CalendarReport’: Company’s calendar
-fundamentalDataOptions (List[TagValue]) -Unknown
Return type
str

#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])
Do a blocking market scan by starting a subscription and canceling it after the initial list of results are in.
This method is blocking.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -Basic filters.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.
Return type
ScanDataList

#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Subscribe to market scan data.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
-subscription (ScannerSubscription) -What to scan for.
-scannerSubscriptionOptions (List[TagValue]) -Unknown.
-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.
Return type
ScanDataList

#### cancelScannerSubscription(dataList)
Cancel market data subscription.
https://interactivebrokers.github.io/tws-api/market_scanners.html
Parameters
dataList (ScanDataList) -The scan data list that was obtained from
reqScannerSubscription().

#### reqScannerParameters()
Requests an XML list of scanner parameters.
This method is blocking.
Return type
str

#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])
Calculate the volatility given the option price.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-optionPrice (float) -Option price to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions (List[TagValue]) -Unknown
Return type
OptionComputation

#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])
Calculate the option price given the volatility.
This method is blocking.
https://interactivebrokers.github.io/tws-api/option_computations.html
Parameters
-contract (Contract) -Option contract.
-volatility (float) -Option volatility to use in calculation.
-underPrice (float) -Price of the underlier to use in calculation
-implVolOptions -Unknown
Return type
OptionComputation

#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Get the option chain.
This method is blocking.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-underlyingSymbol (str) -Symbol of underlier contract.
-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).
-underlyingSecType (str) -The type of the underlying security, like ‘STK’ or ‘FUT’.
-underlyingConId (int) -conId of the underlying contract.
Return type
List[OptionChain]

#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)
Exercise an options contract.
https://interactivebrokers.github.io/tws-api/options.html
Parameters
-contract (Contract) -The option contract to be exercised.
-exerciseAction (int) –
– 1 = exercise the option
– 2 = let the option lapse
-exerciseQuantity (int) -Number of contracts to be exercised.
-account (str) -Destination account.
-override (int) –
– 0 = no override
– 1 = override the system’s natural action

#### reqNewsProviders()
Get a list of news providers.
This method is blocking.
Return type
List[NewsProvider]

#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)
Get the body of a news article.
This method is blocking.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
-providerCode (str) -Code indicating news provider, like ‘BZ’ or ‘FLY’.
-articleId (str) -ID of the specific article.
-newsArticleOptions (Optional[List[TagValue]]) -Unknown.
Return type
NewsArticle

#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Get historical news headline.
https://interactivebrokers.github.io/tws-api/news.html
This method is blocking.
Parameters
-conId (int) -Search news articles for contract with this conId.
-providerCodes (str) -A ‘+’-separated list of provider codes, like ‘BZ+FLY’.
-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be
given as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given
as a datetime.date or datetime.datetime, or it can be given as a string in ‘yyyyMMdd
HH:mm:ss’ format. If no timezone is given then the TWS login timezone is used.
-totalResults (int) -Maximum number of headlines to fetch (300 max).
-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.
Return type
HistoricalNews

#### reqNewsBulletins(allMessages)
Subscribe to IB news bulletins.
https://interactivebrokers.github.io/tws-api/news.html
Parameters
allMessages (bool) -If True then fetch all messages for the day.

#### cancelNewsBulletins()
Cancel subscription to IB news bulletins.

#### requestFA(faDataType)
Requests to change the FA configuration.
This method is blocking.
Parameters
faDataType (int) –
-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation
method to all accounts in the group.
-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined
calculation value.
-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than
account numbers.

#### replaceFA(faDataType, xml)
Replaces Financial Advisor’s settings.
Parameters
-faDataType (int) -See requestFA().
-xml (str) -The XML-formatted configuration string.

#### reqUserInfo()
Get the White Branding ID of the user.
Return type
str

#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')

#### async qualifyContractsAsync(*contracts)
Return type
List[Contract]

#### async reqTickersAsync(*contracts, regulatorySnapshot=False)
Return type
List[Ticker]

#### whatIfOrderAsync(contract, order)
Return type
Awaitable[OrderState]

#### reqCurrentTimeAsync()
Return type
Awaitable[datetime]

#### reqAccountUpdatesAsync(account)
Return type
Awaitable[None]

#### reqAccountUpdatesMultiAsync(account, modelCode='')
Return type
Awaitable[None]

#### async accountSummaryAsync(account='')
Return type
List[AccountValue]

#### reqAccountSummaryAsync()
Return type
Awaitable[None]

#### reqOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqAllOpenOrdersAsync()
Return type
Awaitable[List[Order]]

#### reqCompletedOrdersAsync(apiOnly)
Return type
Awaitable[List[Trade]]

#### reqExecutionsAsync(execFilter=None)
Return type
Awaitable[List[Fill]]

#### reqPositionsAsync()
Return type
Awaitable[List[Position]]

#### reqContractDetailsAsync(contract)
Return type
Awaitable[List[ContractDetails]]

#### async reqMatchingSymbolsAsync(pattern)
Return type
Optional[List[ContractDescription]]

#### async reqMarketRuleAsync(marketRuleId)
Return type
Optional[List[PriceIncrement]]

#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,
useRTH, formatDate=1, keepUpToDate=False, chartOptions=[],
timeout=60)
Return type
BarDataList

#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)
Return type
Awaitable[HistoricalSchedule]

#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize=False, miscOptions=[])
Return type
Awaitable[List]

#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)
Return type
Awaitable[datetime]

#### reqSmartComponentsAsync(bboExchange)

#### reqMktDepthExchangesAsync()
Return type
Awaitable[List[DepthMktDataDescription]]

#### reqHistogramDataAsync(contract, useRTH, period)
Return type
Awaitable[List[HistogramData]]

#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])
Return type
Awaitable[str]

#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],
scannerSubscriptionFilterOptions=[])
Return type
ScanDataList

#### reqScannerParametersAsync()
Return type
Awaitable[str]

#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])
Return type
Optional[OptionComputation]

#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])
Return type
Optional[OptionComputation]

#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)
Return type
Awaitable[List[OptionChain]]

#### reqNewsProvidersAsync()
Return type
Awaitable[List[NewsProvider]]

#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)
Return type
Awaitable[NewsArticle

#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions=None)
Return type
Optional[HistoricalNews]

#### async requestFAAsync(faDataType)
reqUserInfoAsync()
```

> **Note:** Single example, no duplicates found

### 
Client

```python
Socket client for communicating with Interactive Brokers.

#### class ib_insync.client.Client(wrapper)
Replacement for ibapi.client.EClient that uses asyncio.
The client is fully asynchronous and has its own event-driven networking code that replaces the networking code
of the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can
be used as a drop-in replacement for the standard EClient as provided by IBAPI.
Compared to the standard EClient this client has the following additional features:
-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for
nextValidId to start requests as the client has already done that. The reqId is directly available with
getReqId().
-client.connectAsync() is a coroutine for connecting asynchronously.
-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-
onds).
-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size
instead of the two wrapper methods priceTick and sizeTick.
-Automatic request throttling.
-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after
a network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.
-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the
network packet’s data has been handled. A possible use is to write or evaluate the newly arrived data in one
batch instead of item by item.
Parameters
-MaxRequests (int) -Throttle the number of requests to MaxRequests per
RequestsInterval seconds. Set to 0 to disable throttling.
-RequestsInterval (float) -Time interval (in seconds) for request throttling.
-MinClientVersion (int) -Client protocol version.
-MaxClientVersion (int) -Client protocol version

Events:
-apiStart ()
-apiEnd ()
-apiError (errorMsg: str)
-throttleStart ()
-throttleEnd ()
events = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')
MaxRequests = 45
RequestsInterval = 1
MinClientVersion = 157
MaxClientVersion = 176
DISCONNECTED = 0
CONNECTING = 1
CONNECTED = 2
reset()
serverVersion()
Return type
int
run()
isConnected()
isReady()
Is the API connection up and running?
Return type
bool
connectionStats()
Get statistics about the connection.
Return type
ConnectionStats
getReqId()
Get new request ID.
Return type
int
updateReqId(minReqId)
Update the next reqId to be at least minReqId.
getAccounts()
Get the list of account names that are under management.
Return type
List[str]

setConnectOptions(connectOptions)
Set additional connect options.
Parameters
connectOptions (str) -Use “+PACEAPI” to use request-pacing built into TWS/gateway
974+.

connect(host, port, clientId, timeout=2.0)
Connect to a running TWS or IB gateway application.
Parameters
-host (str) -Host name or IP address.
-port (int) -Port number.
-clientId (int) -ID number to use for this client; must be unique per connection.
-timeout (Optional[float]) -If establishing the connection takes longer than timeout
seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.

async connectAsync(host, port, clientId, timeout=2.0)

disconnect()
Disconnect from IB connection.

send(*fields)
Serialize and send the given fields using the IB socket protocol.

sendMsg(msg)

reqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)

cancelMktData(reqId)

placeOrder(orderId, contract, order)

cancelOrder(orderId, manualCancelOrderTime='')

reqOpenOrders()

reqAccountUpdates(subscribe, acctCode)

reqExecutions(reqId, execFilter)

reqIds(numIds)

reqContractDetails(reqId, contract)

reqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)

cancelMktDepth(reqId, isSmartDepth)

reqNewsBulletins(allMsgs)

cancelNewsBulletins()

setServerLogLevel(logLevel)

reqAutoOpenOrders(bAutoBind)

reqAllOpenOrders()

reqManagedAccts()

requestFA(faData)

replaceFA(reqId, faData, cxml)

reqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,
formatDate, keepUpToDate, chartOptions)

exerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)

reqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,
scannerSubscriptionFilterOptions)

cancelScannerSubscription(reqId)

reqScannerParameters()

cancelHistoricalData(reqId)

reqCurrentTime()

reqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)

cancelRealTimeBars(reqId)

reqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)

cancelFundamentalData(reqId)

calculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)

calculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)

cancelCalculateImpliedVolatility(reqId)

cancelCalculateOptionPrice(reqId)

reqGlobalCancel()

reqMarketDataType(marketDataType)

reqPositions()

reqAccountSummary(reqId, groupName, tags)

cancelAccountSummary(reqId)

cancelPositions()

verifyRequest(apiName, apiVersion)

verifyMessage(apiData)

queryDisplayGroups(reqId)

subscribeToGroupEvents(reqId, groupId)

updateDisplayGroup(reqId, contractInfo)

unsubscribeFromGroupEvents(reqId)

startApi()

verifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)

verifyAndAuthMessage(apiData, xyzResponse)

reqPositionsMulti(reqId, account, modelCode)

cancelPositionsMulti(reqId)

reqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )

cancelAccountUpdatesMulti(reqId)

reqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)

reqSoftDollarTiers(reqId)

reqFamilyCodes()

reqMatchingSymbols(reqId, pattern)

reqMktDepthExchanges()

reqSmartComponents(reqId, bboExchange)

reqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)

reqNewsProviders()

reqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,
historicalNewsOptions)

reqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)

reqHistogramData(tickerId, contract, useRTH, timePeriod)

cancelHistogramData(tickerId)

cancelHeadTimeStamp(reqId)

reqMarketRule(marketRuleId)

reqPnL(reqId, account, modelCode)

cancelPnL(reqId)

reqPnLSingle(reqId, account, modelCode, conid)

cancelPnLSingle(reqId)

reqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,
ignoreSize, miscOptions)

reqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)

cancelTickByTickData(reqId)

reqCompletedOrders(apiOnly)

reqWshMetaData(reqId)

cancelWshMetaData(reqId)

reqWshEventData(reqId, data)

cancelWshEventData(reqId)

reqUserInfo(reqId)
```

> **Note:** Single example, no duplicates found

### class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =
'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:
float = 2, appStartupTime: float = 30, ...

```python
def onConnected():
    print(ib.accountValues())

ibc = IBC(974, gateway=True, tradingMode='paper')
ib = IB()
ib.connectedEvent += onConnected
watchdog = Watchdog(ibc, ib, port=4002)
watchdog.start()
ib.run()
```

> **Note:** Single example, no duplicates found

###  Delta Hedging Pattern

```python
# Dynamic delta hedging for options position
def calculate_position_delta(portfolio):
    """Calculate total portfolio delta"""
    total_delta = 0.0
    
    for item in portfolio:
        if item.contract.secType == 'OPT':
            # Request option computations
            ticker = ib.reqMktData(item.contract, '', False, False)
            ib.sleep(1)
            
            if ticker.modelGreeks:
                delta = ticker.modelGreeks.delta
                total_delta += delta * item.position
            
            ib.cancelMktData(item.contract)
    
    return total_delta

def hedge_delta(underlying_contract, target_delta=0.0):
    """Adjust underlying position to achieve target delta"""
    portfolio = ib.portfolio()
    current_delta = calculate_position_delta(portfolio)
    
    delta_to_hedge = current_delta - target_delta
    
    if abs(delta_to_hedge) > 0.1:  # Threshold
        # Delta of stock is 1.0
        shares_to_trade = int(delta_to_hedge * 100)  # Per contract
        
        if shares_to_trade > 0:
            order = MarketOrder('SELL', abs(shares_to_trade))
        else:
            order = MarketOrder('BUY', abs(shares_to_trade))
        
        trade = ib.placeOrder(underlying_contract, order)
        print(f"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}")
        
        return trade
    else:
        print(f"Delta within tolerance: {current_delta:.2f}")
        return None

# Run periodically
underlying = Stock('SPY', 'SMART', 'USD')
underlying = ib.qualifyContracts(underlying)[0]

while True:
    hedge_delta(underlying, target_delta=0.0)
    ib.sleep(300)  # Every 5 minutes
```

> **Note:** Single example, no duplicates found

###  Order Validation Before Submission

```python
def validate_order(ib, contract, order):
    """Validate order before placing"""
    errors = []
    
    # 1. Check contract is qualified
    if contract.conId == 0:
        errors.append("Contract not qualified")
    
    # 2. Check buying power
    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}
    
    if order.action == 'BUY':
        # Estimate cost
        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot
        ib.sleep(1)
        
        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN
            estimated_cost = ticker.ask * order.totalQuantity
            if estimated_cost > account_values.get('BuyingPower', 0):
                errors.append(f"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}")
        
        ib.cancelMktData(contract)
    
    # 3. What-if order check
    try:
        order_copy = Order(**{k: v for k, v in order.__dict__.items()})
        order_copy.whatIf = True
        
        orderState = ib.whatIfOrder(contract, order_copy)
        
        if orderState.commission and orderState.commission > 0:
            # Valid response
            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):
                errors.append("Insufficient margin")
        else:
            errors.append("What-if order returned invalid state")
            
    except Exception as e:
        errors.append(f"What-if validation failed: {e}")
    
    # 4. Check trading hours
    details = ib.reqContractDetails(contract)
    if details:
        # Parse trading hours (simplified)
        # Would need full implementation
        pass
    
    return errors

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]
order = LimitOrder('BUY', 1000, 175.0)

validation_errors = validate_order(ib, contract, order)
if validation_errors:
    print("Order validation failed:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    trade = ib.placeOrder(contract, order)
    print("Order placed successfully")
```

> **Note:** Single example, no duplicates found

###  Position Reconciliation

```python
class PositionManager:
    def __init__(self, ib):
        self.ib = ib
        self.expected_positions = {}  # conId -> quantity
        
    def record_trade(self, trade):
        """Record expected position change"""
        if trade.orderStatus.status == 'Filled':
            conId = trade.contract.conId
            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()
            
            if conId in self.expected_positions:
                self.expected_positions[conId] += qty
            else:
                self.expected_positions[conId] = qty
    
    def reconcile(self):
        """Check actual vs expected positions"""
        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}
        
        discrepancies = []
        
        # Check expected positions
        for conId, expected_qty in self.expected_positions.items():
            actual_qty = actual_positions.get(conId, 0)
            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding
                discrepancies.append({
                    'conId': conId,
                    'expected': expected_qty,
                    'actual': actual_qty,
                    'diff': actual_qty - expected_qty
                })
        
        # Check for unexpected positions
        for conId, actual_qty in actual_positions.items():
            if conId not in self.expected_positions and abs(actual_qty) > 0.01:
                discrepancies.append({
                    'conId': conId,
                    'expected': 0,
                    'actual': actual_qty,
                    'diff': actual_qty
                })
        
        if discrepancies:
            logging.warning(f"Position discrepancies found: {discrepancies}")
        
        return discrepancies
    
    def reset_tracking(self):
        """Reset to current positions"""
        self.expected_positions = {
            p.contract.conId: p.position 
            for p in self.ib.positions()
        }

# Usage
pm = PositionManager(ib)
pm.reset_tracking()

# Track trades
ib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)

# Periodic reconciliation
while True:
    discrepancies = pm.reconcile()
    if discrepancies:
        # Alert or take action
        pass
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Close All Positions

```python
def close_all_positions(ib, exclude_symbols=None):
    """Emergency position closer"""
    exclude_symbols = exclude_symbols or []
    
    positions = ib.positions()
    trades = []
    
    for position in positions:
        symbol = position.contract.symbol
        
        if symbol in exclude_symbols:
            continue
        
        qty = abs(position.position)
        action = 'SELL' if position.position > 0 else 'BUY'
        
        order = MarketOrder(action, qty)
        trade = ib.placeOrder(position.contract, order)
        trades.append(trade)
        
        print(f"Closing {action} {qty} {symbol}")
    
    # Wait for all to fill
    timeout = 30
    start = time.time()
    
    while any(not t.isDone() for t in trades):
        if time.time() - start > timeout:
            logging.error("Timeout waiting for position closures")
            break
        ib.sleep(0.5)
    
    return trades

# Usage - emergency exit
if emergency_condition:
    close_all_positions(ib)
```

> **Note:** Single example, no duplicates found

###  Position Size Calculator

```python
def calculate_position_size(
    ib,
    contract,
    risk_per_trade_pct=0.02,  # 2% risk
    stop_loss_pct=0.05         # 5% stop
):
    """Calculate position size based on risk"""
    
    # Get account value
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    # Calculate dollar risk
    dollar_risk = net_liq * risk_per_trade_pct
    
    # Get current price
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if not ticker.last or ticker.last != ticker.last:  # NaN check
        logging.error("Unable to get price for position sizing")
        return 0
    
    price = ticker.last
    ib.cancelMktData(contract)
    
    # Calculate shares
    # dollar_risk = shares * price * stop_loss_pct
    shares = dollar_risk / (price * stop_loss_pct)
    
    # Round to nearest tradeable lot
    if contract.secType == 'OPT':
        shares = int(shares / 100) * 100  # Options in contracts (100 shares)
    else:
        shares = int(shares)
    
    print(f"Position size for {contract.symbol}: {shares} shares")
    print(f"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})")
    
    return shares

# Usage
contract = Stock('AAPL', 'SMART', 'USD')
contract = ib.qualifyContracts(contract)[0]

shares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)

if shares > 0:
    order = LimitOrder('BUY', shares, 175.0)
    trade = ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Daily Loss Limit

```python
class DailyLossLimiter:
    def __init__(self, ib, max_daily_loss_pct=0.05):
        self.ib = ib
        self.max_daily_loss_pct = max_daily_loss_pct
        self.start_equity = None
        self.breached = False
        
    def initialize(self):
        """Set starting equity for the day"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        self.breached = False
        print(f"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}")
    
    def check_limit(self):
        """Check if daily loss limit breached"""
        if self.breached:
            return True
        
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            self.breached = True
            logging.critical(f"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)")
            return True
        
        return False
    
    def enforce(self):
        """Close all positions and cancel all orders"""
        if not self.breached:
            return
        
        print("Enforcing daily loss limit...")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        close_all_positions(self.ib)
        
        print("All positions closed. Trading halted for the day.")

# Usage
limiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit
limiter.initialize()

# Check periodically
while True:
    if limiter.check_limit():
        limiter.enforce()
        break
    ib.sleep(60)
```

> **Note:** Single example, no duplicates found

###  Max Position Concentration

```python
def check_position_concentration(ib, max_position_pct=0.20):
    """Ensure no single position exceeds % of portfolio"""
    
    account_values = {v.tag: float(v.value) for v in ib.accountValues()}
    net_liq = account_values.get('NetLiquidation', 0)
    
    violations = []
    
    for item in ib.portfolio():
        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0
        
        if position_pct > max_position_pct:
            violations.append({
                'symbol': item.contract.symbol,
                'value': item.marketValue,
                'pct': position_pct,
                'limit': max_position_pct
            })
    
    if violations:
        logging.warning(f"Position concentration violations: {violations}")
    
    return violations

# Check before placing order
def place_order_with_concentration_check(ib, contract, order, max_pct=0.20):
    """Place order only if it doesn't violate concentration"""
    
    # Estimate new position value
    ticker = ib.reqMktData(contract, '', True, False)
    ib.sleep(1)
    
    if ticker.ask:
        estimated_value = ticker.ask * order.totalQuantity
        
        account_values = {v.tag: float(v.value) for v in ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        # Get current position
        current_position = next(
            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),
            0
        )
        
        new_position_value = abs(current_position + estimated_value)
        new_pct = new_position_value / net_liq if net_liq > 0 else 0
        
        if new_pct > max_pct:
            logging.error(f"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%")
            ib.cancelMktData(contract)
            return None
    
    ib.cancelMktData(contract)
    return ib.placeOrder(contract, order)
```

> **Note:** Single example, no duplicates found

###  Correlation-Based Risk

```python
import numpy as np
import pandas as pd

def calculate_portfolio_correlation_risk(ib, lookback_days=30):
    """Calculate portfolio correlation matrix"""
    
    portfolio = ib.portfolio()
    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']
    
    # Get historical data for all positions
    price_data = {}
    
    for symbol in symbols:
        contract = Stock(symbol, 'SMART', 'USD')
        contract = ib.qualifyContracts(contract)[0]
        
        bars = ib.reqHistoricalData(
            contract,
            endDateTime='',
            durationStr=f'{lookback_days} D',
            barSizeSetting='1 day',
            whatToShow='TRADES',
            useRTH=True
        )
        
        if bars:
            price_data[symbol] = [bar.close for bar in bars]
    
    # Create DataFrame
    df = pd.DataFrame(price_data)
    
    # Calculate returns
    returns = df.pct_change().dropna()
    
    # Correlation matrix
    corr_matrix = returns.corr()
    
    # Identify highly correlated pairs
    high_corr_threshold = 0.7
    high_corr_pairs = []
    
    for i in range(len(corr_matrix.columns)):
        for j in range(i+1, len(corr_matrix.columns)):
            corr = corr_matrix.iloc[i, j]
            if abs(corr) > high_corr_threshold:
                high_corr_pairs.append({
                    'symbol1': corr_matrix.columns[i],
                    'symbol2': corr_matrix.columns[j],
                    'correlation': corr
                })
    
    if high_corr_pairs:
        logging.warning(f"High correlation detected: {high_corr_pairs}")
    
    return corr_matrix, high_corr_pairs

# Usage
corr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)
print("Portfolio Correlation Matrix:")
print(corr_matrix)
```

> **Note:** Single example, no duplicates found

###  Auto-Reconnect Manager

```python
class ReconnectionManager:
    def __init__(self, host='127.0.0.1', port=7497, clientId=1):
        self.host = host
        self.port = port
        self.clientId = clientId
        self.ib = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5
        self.is_connected = False
        
    def connect(self):
        """Initial connection with reconnect logic"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.ib = IB()
                self.ib.disconnectedEvent += self.on_disconnect
                self.ib.errorEvent += self.on_error
                
                self.ib.connect(
                    self.host,
                    self.port,
                    self.clientId,
                    timeout=10
                )
                
                self.is_connected = True
                self.reconnect_attempts = 0
                logging.info(f"Connected to TWS at {self.host}:{self.port}")
                
                # Restore subscriptions
                self.restore_state()
                
                return self.ib
                
            except Exception as e:
                self.reconnect_attempts += 1
                logging.error(f"Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    logging.critical("Max reconnection attempts reached. Giving up.")
                    raise
                
                logging.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
    
    def on_disconnect(self):
        """Handle disconnection"""
        self.is_connected = False
        logging.warning("Disconnected from TWS. Attempting reconnect...")
        
        # Save current state
        self.save_state()
        
        # Attempt reconnection
        self.connect()
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle connection errors"""
        if errorCode in [502, 503, 504, 1100, 1101, 1102]:
            logging.error(f"Connection error {errorCode}: {errorString}")
            if not self.is_connected:
                self.on_disconnect()
    
    def save_state(self):
        """Save subscriptions and state before disconnect"""
        if not self.ib:
            return
        
        # Save tickers
        self.saved_tickers = [
            (ticker.contract, ticker.genericTickList) 
            for ticker in self.ib.tickers()
        ]
        
        # Save positions (for monitoring)
        self.saved_positions = [
            (p.contract, p.position) 
            for p in self.ib.positions()
        ]
        
        logging.info(f"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions")
    
    def restore_state(self):
        """Restore subscriptions after reconnect"""
        if not hasattr(self, 'saved_tickers'):
            return
        
        logging.info("Restoring market data subscriptions...")
        
        # Resubscribe to tickers
        for contract, genericTickList in self.saved_tickers:
            try:
                self.ib.reqMktData(contract, genericTickList, False, False)
            except Exception as e:
                logging.error(f"Failed to restore ticker {contract.symbol}: {e}")
        
        logging.info("State restored")

# Usage
conn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)
ib = conn_mgr.connect()

# Normal trading operations
# Connection will auto-reconnect on failure
```

> **Note:** Single example, no duplicates found

###  Target Allocation Rebalancer

```python
class PortfolioRebalancer:
    def __init__(self, ib):
        self.ib = ib
        
    def rebalance_to_target(self, target_allocations, tolerance=0.05):
        """
        Rebalance portfolio to target allocations
        
        Args:
            target_allocations: Dict[symbol: str, target_pct: float]
                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}
            tolerance: Rebalance threshold (0.05 = 5%)
        """
        
        # Validate target allocations
        total = sum(target_allocations.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Target allocations must sum to 1.0, got {total}")
        
        # Get current portfolio
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        net_liq = account_values.get('NetLiquidation', 0)
        
        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}
        
        # Calculate current allocations
        current_allocations = {
            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)
            for symbol, item in portfolio.items()
        }
        
        # Determine needed trades
        trades_needed = []
        
        for symbol, target_pct in target_allocations.items():
            current_pct = current_allocations.get(symbol, 0)
            diff = target_pct - current_pct
            
            if abs(diff) > tolerance:
                target_value = net_liq * target_pct
                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0
                value_change = target_value - current_value
                
                # Get current price
                contract = Stock(symbol, 'SMART', 'USD')
                contract = self.ib.qualifyContracts(contract)[0]
                
                ticker = self.ib.reqMktData(contract, '', True, False)
                self.ib.sleep(1)
                
                if ticker.last and ticker.last == ticker.last:
                    price = ticker.last
                    shares_change = int(value_change / price)
                    
                    if shares_change != 0:
                        trades_needed.append({
                            'symbol': symbol,
                            'contract': contract,
                            'current_pct': current_pct,
                            'target_pct': target_pct,
                            'shares': shares_change,
                            'action': 'BUY' if shares_change > 0 else 'SELL'
                        })
                
                self.ib.cancelMktData(contract)
        
        # Execute trades
        if not trades_needed:
            logging.info("Portfolio within tolerance. No rebalancing needed.")
            return []
        
        logging.info(f"Rebalancing {len(trades_needed)} positions...")
        placed_trades = []
        
        for trade_info in trades_needed:
            logging.info(f"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} "
                        f"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)")
            
            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))
            trade = self.ib.placeOrder(trade_info['contract'], order)
            placed_trades.append(trade)
        
        return placed_trades

# Usage
target = {
    'AAPL': 0.30,
    'GOOGL': 0.30,
    'MSFT': 0.40
}

rebalancer = PortfolioRebalancer(ib)
trades = rebalancer.rebalance_to_target(target, tolerance=0.03)

# Monitor fills
for trade in trades:
    while not trade.isDone():
        ib.sleep(1)
    print(f"{trade.contract.symbol}: {trade.orderStatus.status}")
```

> **Note:** Single example, no duplicates found

###  Multi-Account Order Router

```python
class MultiAccountRouter:
    def __init__(self, host='127.0.0.1', port=7497):
        self.connections = {}
        self.host = host
        self.port = port
        
    def add_account(self, account_name, client_id):
        """Add account connection"""
        ib = IB()
        ib.connect(self.host, self.port, client_id)
        self.connections[account_name] = ib
        logging.info(f"Connected account {account_name} with clientId {client_id}")
    
    def place_order_all(self, contract, order_template, quantities):
        """
        Place orders across multiple accounts
        
        Args:
            contract: Contract to trade
            order_template: Base order
            quantities: Dict[account_name, quantity]
        """
        trades = {}
        
        for account_name, quantity in quantities.items():
            if account_name not in self.connections:
                logging.error(f"Account {account_name} not connected")
                continue
            
            ib = self.connections[account_name]
            
            # Clone order
            order = Order(**{k: v for k, v in order_template.__dict__.items()})
            order.totalQuantity = quantity
            order.account = account_name
            
            # Place order
            trade = ib.placeOrder(contract, order)
            trades[account_name] = trade
            
            logging.info(f"Placed {order.action} {quantity} {contract.symbol} for {account_name}")
        
        return trades
    
    def get_combined_portfolio(self):
        """Get combined portfolio across all accounts"""
        combined = {}
        
        for account_name, ib in self.connections.items():
            for item in ib.portfolio():
                symbol = item.contract.symbol
                
                if symbol not in combined:
                    combined[symbol] = {
                        'position': 0,
                        'market_value': 0,
                        'unrealized_pnl': 0,
                        'accounts': {}
                    }
                
                combined[symbol]['position'] += item.position
                combined[symbol]['market_value'] += item.marketValue
                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL
                combined[symbol]['accounts'][account_name] = item.position
        
        return combined
    
    def disconnect_all(self):
        """Disconnect all accounts"""
        for account_name, ib in self.connections.items():
            ib.disconnect()
            logging.info(f"Disconnected {account_name}")

# Usage
router = MultiAccountRouter()
router.add_account('Account1', client_id=1)
router.add_account('Account2', client_id=2)
router.add_account('Account3', client_id=3)

# Place order across all accounts
contract = Stock('AAPL', 'SMART', 'USD')
order_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account

quantities = {
    'Account1': 100,
    'Account2': 200,
    'Account3': 150
}

trades = router.place_order_all(contract, order_template, quantities)

# Monitor combined portfolio
combined = router.get_combined_portfolio()
for symbol, data in combined.items():
    print(f"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts")
```

> **Note:** Single example, no duplicates found

###  Complete Production Trading System Template

```python
"""
Production Trading System Template
Features: Auto-reconnect, error handling, risk management, logging
"""

import logging
from datetime import datetime, time as dt_time
from ib_insync import *

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(f'trading_{datetime.now().strftime("%Y%m%d")}.log'),
        logging.StreamHandler()
    ]
)

class ProductionTradingSystem:
    def __init__(self, host='127.0.0.1', port=7497, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = None
        self.running = False
        
        # Risk parameters
        self.max_daily_loss_pct = 0.03
        self.max_position_pct = 0.20
        self.daily_loss_breached = False
        
        # State tracking
        self.start_equity = 0
        self.trades_today = []
        
    def initialize(self):
        """Initialize system"""
        logging.info("Initializing trading system...")
        
        # Connect
        self.ib = IB()
        self.ib.errorEvent += self.on_error
        self.ib.disconnectedEvent += self.on_disconnect
        
        try:
            self.ib.connect(self.host, self.port, self.client_id, timeout=10)
            logging.info("Connected to TWS")
        except Exception as e:
            logging.critical(f"Failed to connect: {e}")
            return False
        
        # Get starting equity
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        self.start_equity = account_values.get('NetLiquidation', 0)
        logging.info(f"Starting equity: ${self.start_equity:,.2f}")
        
        # Setup event handlers
        self.ib.orderStatusEvent += self.on_order_status
        self.ib.execDetailsEvent += self.on_execution
        
        return True
    
    def on_error(self, reqId, errorCode, errorString, contract):
        """Handle errors"""
        if errorCode in [502, 503, 504]:
            logging.error(f"Connection error {errorCode}: {errorString}")
        elif errorCode >= 2000:
            # Warnings
            logging.warning(f"Warning {errorCode}: {errorString}")
        else:
            logging.error(f"Error {errorCode}: {errorString}")
    
    def on_disconnect(self):
        """Handle disconnection"""
        logging.warning("Disconnected from TWS")
        # Attempt reconnection logic here
    
    def on_order_status(self, trade):
        """Track order status"""
        logging.info(f"Order {trade.order.orderId}: {trade.orderStatus.status}")
    
    def on_execution(self, trade, fill):
        """Track executions"""
        self.trades_today.append(trade)
        logging.info(f"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}")
    
    def check_risk_limits(self):
        """Check if risk limits breached"""
        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}
        current_equity = account_values.get('NetLiquidation', 0)
        
        # Daily loss check
        loss = self.start_equity - current_equity
        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0
        
        if loss_pct >= self.max_daily_loss_pct:
            logging.critical(f"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%")
            self.daily_loss_breached = True
            self.emergency_shutdown()
            return False
        
        return True
    
    def emergency_shutdown(self):
        """Emergency shutdown - close all positions"""
        logging.critical("EMERGENCY SHUTDOWN INITIATED")
        
        # Cancel all orders
        self.ib.reqGlobalCancel()
        
        # Close all positions
        for position in self.ib.positions():
            qty = abs(position.position)
            action = 'SELL' if position.position > 0 else 'BUY'
            
            order = MarketOrder(action, qty)
            self.ib.placeOrder(position.contract, order)
            
            logging.info(f"Emergency close: {action} {qty} {position.contract.symbol}")
        
        self.running = False
    
    def is_market_hours(self):
        """Check if within trading hours"""
        now = datetime.now().time()
        market_open = dt_time(9, 30)
        market_close = dt_time(16, 0)
        
        return market_open <= now <= market_close
    
    def run(self):
        """Main trading loop"""
        if not self.initialize():
            return
        
        self.running = True
        logging.info("Trading system started")
        
        try:
            while self.running:
                # Check risk limits
                if not self.check_risk_limits():
                    break
                
                # Only trade during market hours
                if self.is_market_hours():
                    # Your trading logic here
                    self.trading_logic()
                
                # Sleep between iterations
                self.ib.sleep(60)  # Check every minute
                
        except KeyboardInterrupt:
            logging.info("Shutdown requested by user")
        except Exception as e:
            logging.critical(f"Unexpected error: {e}")
        finally:
            self.shutdown()
    
    def trading_logic(self):
        """Implement your trading strategy here"""
        pass
    
    def shutdown(self):
        """Graceful shutdown"""
        logging.info("Shutting down trading system...")
        
        if self.ib:
            # Cancel all market data
            for contract in [t.contract for t in self.ib.tickers()]:
                self.ib.cancelMktData(contract)
            
            # Disconnect
            self.ib.disconnect()
        
        logging.info("Shutdown complete")

# Run the system
if __name__ == '__main__':
    system = ProductionTradingSystem(
        host='127.0.0.1',
        port=7497,
        client_id=1
    )
    system.run()
```

> **Note:** Single example, no duplicates found

###  Events

```python
events = (
    'connectedEvent',       # Connection established
    'disconnectedEvent',    # Connection lost
    'updateEvent',          # Any state update
    'pendingTickersEvent',  # Ticker updates available
    'barUpdateEvent',       # Real-time bar update
    'newOrderEvent',        # New order created
    'orderModifyEvent',     # Order modified
    'cancelOrderEvent',     # Order cancel requested
    'openOrderEvent',       # Open order status
    'orderStatusEvent',     # Order status changed
    'execDetailsEvent',     # Trade execution details
    'commissionReportEvent',# Commission report
    'updatePortfolioEvent', # Portfolio updated
    'positionEvent',        # Position changed
    'accountValueEvent',    # Account value updated
    'accountSummaryEvent',  # Account summary updated
    'pnlEvent',            # PnL update
    'pnlSingleEvent',      # Single position PnL
    'scannerDataEvent',    # Scanner data received
    'tickNewsEvent',       # News tick
    'newsBulletinEvent',   # News bulletin
    'errorEvent',          # Error occurred
    'timeoutEvent'         # Request timeout
)
```

> **Note:** Single example, no duplicates found

###  State Properties

```python
# Access current state (auto-synced)
ib.accountValues()      # List[AccountValue]
ib.portfolio()          # List[PortfolioItem]
ib.positions()          # List[Position]
ib.trades()             # List[Trade]
ib.openTrades()         # List[Trade] - open only
ib.orders()             # List[Order]
ib.openOrders()         # List[Order] - open only
ib.fills()              # List[Fill]
ib.executions()         # List[Execution]
ib.tickers()            # List[Ticker]
ib.pendingTickers()     # Set[Ticker] - with updates
ib.reqId()              # int - next request ID
```

> **Note:** Single example, no duplicates found

###  Account Values

```python
values = ib.accountValues(account: str = '') -> List[AccountValue]

# AccountValue fields:
# .account
# .tag      - Key name (e.g., 'NetLiquidation')
# .value    - Value as string
# .currency
# .modelCode
```

> **Note:** Single example, no duplicates found

###  Portfolio

```python
portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]

# PortfolioItem fields:
# .contract
# .position        - Quantity
# .marketPrice     - Current price
# .marketValue     - Position value
# .averageCost     - Avg cost basis
# .unrealizedPNL   - Unrealized P&L
# .realizedPNL     - Realized P&L
# .account
```

> **Note:** Single example, no duplicates found

###  Positions

```python
positions = ib.positions(account: str = '') -> List[Position]

# Position fields:
# .account
# .contract
# .position       - Quantity
# .avgCost        - Average cost
```

> **Note:** Single example, no duplicates found

###  Account Events

```python
# Portfolio updates
ib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')

# Position changes
ib.positionEvent += lambda position: print(f'Position: {position}')

# Account value updates
ib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')

# PnL updates
ib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')
```

> **Note:** Single example, no duplicates found

###  Dataframe Conversion

```python
import pandas as pd

# Bars to DataFrame
df = util.df(bars)

# List of objects to DataFrame
df = util.df(ib.positions())
df = util.df(ib.accountValues())
```

> **Note:** Single example, no duplicates found

###  Pattern: Portfolio Monitor

```python
from ib_insync import *

ib = IB()
ib.connect('127.0.0.1', 7497, clientId=1)

def show_portfolio():
    print("\n=== PORTFOLIO ===")
    for item in ib.portfolio():
        symbol = item.contract.symbol
        pos = item.position
        price = item.marketPrice
        value = item.marketValue
        pnl = item.unrealizedPNL
        print(f"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}")
    
    print("\n=== ACCOUNT ===")
    values = ib.accountValues()
    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']
    for value in values:
        if value.tag in important_tags:
            print(f"{value.tag:20} | {value.value:15} {value.currency}")

def on_update(item):
    show_portfolio()

# Show initial state
show_portfolio()

# Update on changes
ib.updatePortfolioEvent += on_update

ib.run()
```

> **Note:** Single example, no duplicates found


## Real-Time

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.


## Relative_Order

### Places advanced order types in Interactive Brokers API. Covers:
1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount
2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)
3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging
4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging
5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO
Common parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.

```python
order = Order()
order.action = 'BUY'  # or 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL
# For TRAIL: set auxPrice (fixed trail amount)
# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent
# For PEG MID/PEG BEST: no additional price fields
# For REL: set lmtPrice (offset from NBBO)
order.tif = 'GTC'  # or other time in force

trade = ib.placeOrder(contract, order)
```

> **Note:** Key variations:
- TRAIL requires auxPrice (fixed $ trail)
- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)
- PEG MID/PEG BEST require no price parameters
- REL uses lmtPrice for NBBO offset
- Action (BUY/SELL) varies by use case
- All examples use GTC time-in-force but other values are possible


## Reqmarketdatatype

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.


## Spread

### Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters.

```python
buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')
sell_call = Option('SPY', '20240315', 460, 'C', 'SMART')
buy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)

combo = Contract()
combo.symbol = 'SPY'
combo.secType = 'BAG'
combo.currency = 'USD'
combo.exchange = 'SMART'

combo.comboLegs = [
    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),
    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')
]

order = LimitOrder('BUY', 10, 5.50)  # Debit spread
trade = ib.placeOrder(combo, order)
```

> **Note:** Key variations: 1) Vertical spread uses same expiration/different strikes, calendar spread uses same strike/different expirations. 2) Action ratios reverse for credit spreads (SELL then BUY). 3) Order direction ('BUY'/'SELL') depends on spread type (debit/credit). Example 2 shows calendar spread construction with reversed actions.


## Stop

### Represents stop and stop-limit order types. Stop orders become market orders when the stop price is reached. Stop-limit orders become limit orders with both a stop price (trigger) and limit price (execution constraint). Use StopOrder for basic stop-loss orders (single price trigger) and StopLimitOrder for price-controlled executions.

```python
StopLimitOrder(
    action: str,
    totalQuantity: float,
    lmtPrice: float,
    stopPrice: float,
    **kwargs
)
```

> **Note:** Key difference: StopOrder requires only stopPrice while StopLimitOrder needs both lmtPrice and stopPrice. Example 1 demonstrates a stop-loss, Example 2 shows a stop-limit with price control.


## Stop-Limit

### Represents stop and stop-limit order types. Stop orders become market orders when the stop price is reached. Stop-limit orders become limit orders with both a stop price (trigger) and limit price (execution constraint). Use StopOrder for basic stop-loss orders (single price trigger) and StopLimitOrder for price-controlled executions.

```python
StopLimitOrder(
    action: str,
    totalQuantity: float,
    lmtPrice: float,
    stopPrice: float,
    **kwargs
)
```

> **Note:** Key difference: StopOrder requires only stopPrice while StopLimitOrder needs both lmtPrice and stopPrice. Example 1 demonstrates a stop-loss, Example 2 shows a stop-limit with price control.


## Streaming

### Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.

```python
import asyncio
import ib_insync as ibi

class App:
    async def run(self):
        self.ib = ibi.IB()
        with await self.ib.connectAsync():
            contracts = [
                ibi.Stock(symbol, 'SMART', 'USD')
                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]
            for contract in contracts:
                self.ib.reqMktData(contract)
            async for tickers in self.ib.pendingTickersEvent:
                for ticker in tickers:
                    print(ticker)

    def stop(self):
        self.ib.disconnect()

app = App()
try:
    asyncio.run(app.run())
except (KeyboardInterrupt, SystemExit):
    app.stop()
```

> **Note:** Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.


## Subscription

### Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.

```python
# Market Data Types:
# 1 = Live (subscription required)
# 2 = Frozen (snapshot)
# 3 = Delayed (free, 15-min delay)
# 4 = Delayed-Frozen
ib.reqMarketDataType(3)  # Use delayed data (free)
```

> **Note:** Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.


## Trading

### Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.

```python
order.lmtPrice = 176.0
trade = ib.placeOrder(contract, order)
```

> **Note:** Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.


## Trading-Api

### Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds).

```python
class ib_insync.contract.ContractType(**kwargs)
    [Contract Type Description]

    dict()
        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.
        Return type: dict

    nonDefaults()
        For a dataclass instance get the fields that are different from the default values and return as dict.
        Return type: dict

    tuple()
        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.
        Return type: tuple

    update(*srcObjs, **kwargs)
        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.
        Return type: object

    comboLegs: List[ComboLeg]
```

> **Note:** Variations occur only in contract-specific descriptions: Bond = 'Bond.', MutualFund = 'Mutual fund.', Warrant = 'Warrant option.', Bag = 'Bag contract.'. Method implementations and comboLegs attribute are identical across all contract types. Minor formatting differences exist in source docs (asterisks/spacing) but don't affect functionality.


## Trailing_Stop

### Places advanced order types in Interactive Brokers API. Covers:
1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount
2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)
3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging
4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging
5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO
Common parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.

```python
order = Order()
order.action = 'BUY'  # or 'SELL'
order.totalQuantity = 100
order.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL
# For TRAIL: set auxPrice (fixed trail amount)
# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent
# For PEG MID/PEG BEST: no additional price fields
# For REL: set lmtPrice (offset from NBBO)
order.tif = 'GTC'  # or other time in force

trade = ib.placeOrder(contract, order)
```

> **Note:** Key variations:
- TRAIL requires auxPrice (fixed $ trail)
- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)
- PEG MID/PEG BEST require no price parameters
- REL uses lmtPrice for NBBO offset
- Action (BUY/SELL) varies by use case
- All examples use GTC time-in-force but other values are possible


## Uncategorized

###  Cancel All

```python
ib.reqGlobalCancel()
```

> **Note:** Single example, no duplicates found

###  Bar Sizes

```python
'1 secs', '5 secs', '15 secs', '30 secs'
'1 min', '5 mins', '15 mins', '30 mins'
'1 hour', '4 hours'
'1 day', '1 week', '1 month'
```

> **Note:** Single example, no duplicates found

###  What to Show

```python
'TRADES'    - Actual trades (default)
'MIDPOINT'  - Bid/ask midpoint
'BID'       - Bid prices
'ASK'       - Ask prices
```

> **Note:** Single example, no duplicates found

### For long-running operations, yield control periodically:

```python
def onTickerUpdate(ticker):
    for i in range(1000):
        process_chunk(i)
        if i % 100 == 0:
            ib.sleep(0)  # Yield every 100 iterations
```

> **Note:** Single example, no duplicates found

###  Scanner data (blocking)

```python
allParams = ib.reqScannerParameters()
print(allParams)
sub = ScannerSubscription(
instrument='FUT.US',
locationCode='FUT.CME',
scanCode='TOP_PERC_GAIN')
scanData = ib.reqScannerData(sub)
print(scanData)
```

> **Note:** Single example, no duplicates found

###  News bulletins

```python
ib.reqNewsBulletins(True)
ib.sleep(5)
print(ib.newsBulletins())
```

> **Note:** Single example, no duplicates found

###  Class Definition

```python
class IB:
    """High-level interface to Interactive Brokers"""
```

> **Note:** Single example, no duplicates found

###  Forex

```python
Forex(pair: str = 'EURUSD', exchange: str = 'IDEALPRO')

# Examples
Forex('EURUSD')
Forex('GBPUSD')
```

> **Note:** Single example, no duplicates found

###  Index

```python
Index(symbol: str = '', exchange: str = '')

# Examples
Index('SPX', 'CBOE')
Index('VIX', 'CBOE')
```

> **Note:** Single example, no duplicates found

###  CFD

```python
CFD(symbol: str = '', exchange: str = '', currency: str = '')

# Example
CFD('IBUS30')
```

> **Note:** Single example, no duplicates found

###  Commodity

```python
Commodity(
    symbol: str = '',
    exchange: str = '',
    currency: str = ''
)

# Example
Commodity('XAUUSD', 'SMART', 'USD')
```

> **Note:** Single example, no duplicates found

###  Bond

```python
Bond(secIdType: str = '', secId: str = '')

# Example
Bond(secIdType='ISIN', secId='US03076KAA60')
```

> **Note:** Single example, no duplicates found

###  Crypto

```python
Crypto(symbol: str = '', exchange: str = '', currency: str = '')

# Example
Crypto('BTC', 'PAXOS', 'USD')
```

> **Note:** Single example, no duplicates found

###  Market Data Type

```python
ib.reqMarketDataType(marketDataType: int) -> None
# 1 = Live
# 2 = Frozen
# 3 = Delayed
# 4 = Delayed-Frozen
```

> **Note:** Single example, no duplicates found

###  Bar Object

```python
@dataclass
class Bar:
    date: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    average: float
    barCount: int
```

> **Note:** Single example, no duplicates found

###  Cancel Real-Time Bars

```python
ib.cancelRealTimeBars(bars: RealTimeBarList) -> None
```

> **Note:** Single example, no duplicates found

###  Managed Accounts

```python
accounts = ib.managedAccounts() -> List[str]
# List of account codes
```

> **Note:** Single example, no duplicates found

###  Account Summary

```python
summary = ib.reqAccountSummary() -> List[AccountValue]
# Summary for all accounts

# Or filter by tags
summary = ib.reqAccountSummary(
    account: str = 'All',
    modelCode: str = '',
    tags: str = 'NetLiquidation,TotalCashValue,BuyingPower'
)
```

> **Note:** Single example, no duplicates found

###  PnL (Profit & Loss)

```python
pnl = ib.reqPnL(account: str, modelCode: str = '') -> PnL
# Start PnL subscription

# PnL fields (live-updated):
# .account
# .modelCode
# .dailyPnL
# .unrealizedPnL
# .realizedPnL

# Cancel
ib.cancelPnL(account: str, modelCode: str = '')
```

> **Note:** Single example, no duplicates found

###  PnL Single Position

```python
pnlSingle = ib.reqPnLSingle(
    account: str,
    modelCode: str,
    conId: int
) -> PnLSingle

# PnLSingle fields (live-updated):
# .account
# .modelCode
# .conId
# .dailyPnL
# .unrealizedPnL
# .realizedPnL
# .position
# .value

# Cancel
ib.cancelPnLSingle(account, modelCode, conId)
```

> **Note:** Single example, no duplicates found

###  Datetime Utilities

```python
# Format for IB
formatted = util.formatIBDatetime(dt: datetime) -> str
# Returns: 'YYYYMMDD HH:MM:SS UTC'

# Parse from IB
parsed = util.parseIBDatetime(s: str) -> Union[date, datetime]
```

> **Note:** Single example, no duplicates found

###  Logging

```python
# Log to console
util.logToConsole(level=logging.INFO)

# Log to file
util.logToFile('ib_log.txt', level=logging.DEBUG)
```

> **Note:** Single example, no duplicates found

###  Schedule Periodic Tasks

```python
def callback():
    print('Periodic task')

# Schedule every 60 seconds
handle = util.schedule(60, callback)

# Cancel scheduled task
handle.cancel()
```

> **Note:** Single example, no duplicates found

###  Time Range Iterator

```python
# Iterate over time periods
for dt in util.timeRange(
    start='20240101',
    end='20240131',
    step='1 day'
):
    print(dt)
```

> **Note:** Single example, no duplicates found

### Slow responses

```python
# Solutions:
# 1. Reduce simultaneous requests
# 2. Use batch requests where possible
# 3. Increase TWS memory allocation
# 4. Use keepUpToDate for live bars instead of repeated requests

# Increase TWS memory:
# Configuration -> Settings -> Memory Allocation -> 4096 MB
```

> **Note:** Single example, no duplicates found

