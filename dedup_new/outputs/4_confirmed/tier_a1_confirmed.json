[
  {
    "id": "merged_cluster_0003",
    "topic": "Creates a bracket order with entry, take profit, a",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "or",
      "er"
    ],
    "content": {
      "code": "parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 175.0,\n    takeProfitPrice=185.0,\n    stopLossPrice=170.0\n)\n\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0004_1edc2880",
        "ex_0278_3d95d75e"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.34,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0004",
    "topic": "Creates a trailing stop order that tracks price mo",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "or",
      "ct"
    ],
    "content": {
      "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # Trail by 2%\norder.tif = 'GTC'\n\n# Requires valid contract object\n# trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a trailing stop order that tracks price movements by percentage. Specifies SELL action, 100 shares, 2% trailing offset, and Good-Til-Canceled duration. Includes order placement example requiring a valid contract object. Suitable for percentage-based trailing stop loss strategies."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0005_a46437c8",
        "ex_0153_fcded4d3"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.13,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0006",
    "topic": "Creates a TWAP (Time-Weighted Average Price) order",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "or",
      "ct",
      "twp"
    ],
    "content": {
      "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1')\n]\n\n# Requires contract definition before placement:\n# trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0007_aba79f2a",
        "ex_0160_aae7547e"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.24,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0011",
    "topic": "Modifies an existing order by updating its limit p",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "or",
      "mdf",
      "lmt",
      "trad"
    ],
    "content": {
      "code": "order.lmtPrice = 176.0\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0012_ae79ffd3",
        "ex_0219_e7868613"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.07,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0014",
    "topic": "Creates a vertical spread (debit) or calendar spre",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "or",
      "spr",
      "ptn"
    ],
    "content": {
      "code": "buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')\n]\n\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread\ntrade = ib.placeOrder(combo, order)",
      "language": "python",
      "description": "Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0015_e4716efb",
        "ex_0166_08a5d66a"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.55,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0019",
    "topic": "Demonstrates incorrect pattern of repeatedly polli",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "da",
      "vnt"
    ],
    "content": {
      "code": "while True:\n    bars = ib.reqHistoricalData(...)  # DON'T POLL!\n    time.sleep(5)  # Also wrong - blocks event loop!",
      "language": "python",
      "description": "Demonstrates incorrect pattern of repeatedly polling historical data in a blocking loop. This approach violates API best practices by 1) Using historical requests instead of real-time streaming 2) Blocking the event loop with sleep() which prevents processing of messages and events. Use real-time market data subscriptions instead of polling historical endpoints."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0020_eb569bed",
        "ex_0267_ecb56a32"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.08,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0027",
    "topic": "Requests historical market data for a financial in",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "da",
      "pnd",
      "frx",
      "hst"
    ],
    "content": {
      "code": "contract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',          # '' = now\n    durationStr='30 D',      # 30 days\n    barSizeSetting='1 hour',\n    whatToShow='TRADES',     # Can be MIDPOINT for FX\n    useRTH=True              # Regular hours only\n)\n\n# Convert to pandas\ndf = util.df(bars)\nprint(df.head())",
      "language": "python",
      "description": "Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0028_df8dcf24",
        "ex_0237_f1541456"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.17,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0035",
    "topic": "Sets the market data type for Interactive Brokers ",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "mrk",
      "sbs",
      "dly",
      "rrr",
      "cnn",
      "rqm"
    ],
    "content": {
      "code": "# Market Data Types:\n# 1 = Live (subscription required)\n# 2 = Frozen (snapshot)\n# 3 = Delayed (free, 15-min delay)\n# 4 = Delayed-Frozen\nib.reqMarketDataType(3)  # Use delayed data (free)",
      "language": "python",
      "description": "Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0036_b007e6a8",
        "ex_0289_2973e326"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.04,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0091",
    "topic": "Requests historical bars with real-time updates. W",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "da",
      "vnt"
    ],
    "content": {
      "code": "contract = Stock('TSLA', 'SMART', 'USD')\n\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    formatDate=1,\n    keepUpToDate=True  # Enables live updates\n)",
      "language": "python",
      "description": "Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0092_27c9aee2",
        "ex_0244_39f6deda"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.13,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0129",
    "topic": "Demonstrates asynchronous streaming of real-time m",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "as",
      "co",
      "ct",
      "da",
      "vnt",
      "mrk",
      "str",
      "rl-"
    ],
    "content": {
      "code": "import asyncio\nimport ib_insync as ibi\n\nclass App:\n    async def run(self):\n        self.ib = ibi.IB()\n        with await self.ib.connectAsync():\n            contracts = [\n                ibi.Stock(symbol, 'SMART', 'USD')\n                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]\n            for contract in contracts:\n                self.ib.reqMktData(contract)\n            async for tickers in self.ib.pendingTickersEvent:\n                for ticker in tickers:\n                    print(ticker)\n\n    def stop(self):\n        self.ib.disconnect()\n\napp = App()\ntry:\n    asyncio.run(app.run())\nexcept (KeyboardInterrupt, SystemExit):\n    app.stop()",
      "language": "python",
      "description": "Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0137_80aea104",
        "ex_0147_490b705b"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.61,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok",
        "import:asyncio",
        "import:ib_insync",
        "pattern:async"
      ]
    }
  },
  {
    "id": "merged_cluster_0144",
    "topic": "Places advanced order types in Interactive Brokers",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "or",
      "ct",
      "trl",
      "pgg",
      "rlt"
    ],
    "content": {
      "code": "order = Order()\norder.action = 'BUY'  # or 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL\n# For TRAIL: set auxPrice (fixed trail amount)\n# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent\n# For PEG MID/PEG BEST: no additional price fields\n# For REL: set lmtPrice (offset from NBBO)\norder.tif = 'GTC'  # or other time in force\n\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Places advanced order types in Interactive Brokers API. Covers:\n1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount\n2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)\n3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging\n4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging\n5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO\nCommon parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract."
    },
    "stats": {
      "mentions": 5,
      "sources": [
        "ex_0154_22d3f273",
        "ex_0155_6b1a9a90",
        "ex_0156_50051a29",
        "ex_0157_92bd3785",
        "ex_0158_e5fd845a"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.15,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  },
  {
    "id": "merged_cluster_0204",
    "topic": "The whatIfOrder method tests an order without plac",
    "tier": "a1",
    "confidence": 1.0,
    "tags": [
      "ct",
      "or",
      "er",
      "mrg"
    ],
    "content": {
      "code": "orderState = ib.whatIfOrder(contract, order)\n# Test order without placing\n# Returns OrderState with commission/margin impact\n\n# OrderState fields:\n# .initMarginBefore\n# .maintMarginBefore\n# .equityWithLoanBefore\n# .initMarginAfter\n# .maintMarginAfter\n# .equityWithLoanAfter\n# .commission\n# .minCommission\n# .maxCommission\n# .commissionCurrency",
      "language": "python",
      "description": "The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis."
    },
    "stats": {
      "mentions": 2,
      "sources": [
        "ex_0223_b7055bc8",
        "ex_0291_302efcfd"
      ]
    },
    "tested": {
      "status": "pass",
      "runs": 1,
      "success_rate": "100%",
      "avg_exec_time_ms": 0.05,
      "last_tested": "2025-11-16",
      "demo_safe": false,
      "warnings": [
        "syntax:ok"
      ]
    }
  }
]