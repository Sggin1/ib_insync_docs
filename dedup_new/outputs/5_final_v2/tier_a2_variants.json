[{"id":"merged_ex_0001_73157af0","topic":" Market Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"from ib_insync import *\norder = MarketOrder('BUY', 100)","language":"python","description":" Market Order"},"stats":{"mentions":1,"sources":["ex_0001_73157af0"]}},{"id":"merged_ex_0002_8770c7ad","topic":" Limit Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"order = LimitOrder('BUY', 100, 175.50)","language":"python","description":" Limit Order"},"stats":{"mentions":1,"sources":["ex_0002_8770c7ad"]}},{"id":"merged_ex_0003_3baa2883","topic":" Stop Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"order = StopOrder('SELL', 100, 170.00)  # Stop loss","language":"python","description":" Stop Order"},"stats":{"mentions":1,"sources":["ex_0003_3baa2883"]}},{"id":"merged_ex_0006_ce50b185","topic":" Conditional Order","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Trigger when SPY hits 450\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\ntrigger_contract = ib.qualifyContracts(trigger_contract)[0]\n\ncondition = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # Above price\n    price=450.0\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]","language":"python","description":" Conditional Order"},"stats":{"mentions":1,"sources":["ex_0006_ce50b185"]}},{"id":"merged_ex_0008_d7830359","topic":" Basic Pattern","tier":"a2","confidence":1.0,"tags":["co","ct","or"],"content":{"code":"ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\norder = LimitOrder('BUY', 100, 175.0)\ntrade = ib.placeOrder(contract, order)\n\n# Wait for fill\nwhile not trade.isDone():\n    ib.sleep(0.1)\n\nprint(f\"Status: {trade.orderStatus.status}\")","language":"python","description":" Basic Pattern"},"stats":{"mentions":1,"sources":["ex_0008_d7830359"]}},{"id":"merged_ex_0009_55344dab","topic":" With Validation","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Check buying power first\norder_copy = Order(**{k: v for k, v in order.__dict__.items()})\norder_copy.whatIf = True\n\norderState = ib.whatIfOrder(contract, order_copy)\nif orderState.commission > 0:\n    trade = ib.placeOrder(contract, order)","language":"python","description":" With Validation"},"stats":{"mentions":1,"sources":["ex_0009_55344dab"]}},{"id":"merged_ex_0010_7e8f1098","topic":" Cancel Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"ib.cancelOrder(order)","language":"python","description":" Cancel Order"},"stats":{"mentions":1,"sources":["ex_0010_7e8f1098"]}},{"id":"merged_ex_0011_18b44996","topic":" Cancel All","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"ib.reqGlobalCancel()","language":"python","description":" Cancel All"},"stats":{"mentions":1,"sources":["ex_0011_18b44996"]}},{"id":"merged_ex_0013_489b83e2","topic":" Monitor Status","tier":"a2","confidence":1.0,"tags":["vnt","or"],"content":{"code":"def on_order_status(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n\nib.orderStatusEvent += on_order_status","language":"python","description":" Monitor Status"},"stats":{"mentions":1,"sources":["ex_0013_489b83e2"]}},{"id":"merged_ex_0014_cbe2f695","topic":" Single Option","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"option = Option('SPY', '20240315', 450, 'C', 'SMART')\noption = ib.qualifyContracts(option)[0]\norder = LimitOrder('BUY', 10, 5.50)\ntrade = ib.placeOrder(option, order)","language":"python","description":" Single Option"},"stats":{"mentions":1,"sources":["ex_0014_cbe2f695"]}},{"id":"merged_ex_0016_8c2fb027","topic":" Time In Force","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"'DAY'    # Day order (default)\n'GTC'    # Good till cancelled\n'IOC'    # Immediate or cancel\n'GTD'    # Good till date\n'FOK'    # Fill or kill","language":"python","description":" Time In Force"},"stats":{"mentions":1,"sources":["ex_0016_8c2fb027"]}},{"id":"merged_ex_0017_6a11bf25","topic":" Position Entry with Protection","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"# 1. Enter position\nentry = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry)\n\n# 2. Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    avg_price = entry_trade.orderStatus.avgFillPrice\n    \n    # 3. Set stop loss\n    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop\n    ib.placeOrder(contract, stop)\n    \n    # 4. Set take profit\n    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit\n    ib.placeOrder(contract, target)","language":"python","description":" Position Entry with Protection"},"stats":{"mentions":1,"sources":["ex_0017_6a11bf25"]}},{"id":"merged_ex_0018_ce1ccb8b","topic":" Scale In/Out","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Scale in\nfor qty in [25, 25, 25, 25]:\n    order = LimitOrder('BUY', qty, price)\n    ib.placeOrder(contract, order)\n    ib.sleep(300)  # 5 min between orders\n\n# Scale out\ntotal_position = 100\nfor pct in [0.25, 0.25, 0.25, 0.25]:\n    qty = int(total_position * pct)\n    order = LimitOrder('SELL', qty, price)\n    ib.placeOrder(contract, order)","language":"python","description":" Scale In/Out"},"stats":{"mentions":1,"sources":["ex_0018_ce1ccb8b"]}},{"id":"merged_ex_0019_2cc9e38b","topic":" Error Handling","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"def place_order_safe(ib, contract, order):\n    try:\n        trade = ib.placeOrder(contract, order)\n        \n        # Wait with timeout\n        timeout = 10\n        start = time.time()\n        while trade.orderStatus.status == 'PendingSubmit':\n            if time.time() - start > timeout:\n                ib.cancelOrder(order)\n                raise TimeoutError(\"Order submission timeout\")\n            ib.sleep(0.1)\n        \n        return trade\n    except Exception as e:\n        print(f\"Order failed: {e}\")\n        return None","language":"python","description":" Error Handling"},"stats":{"mentions":1,"sources":["ex_0019_2cc9e38b"]}},{"id":"merged_ex_0021_b4426143","topic":"\u2705 ALWAYS DO THIS:","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"# For ticks\nticker = ib.reqMktData(contract)\nticker.updateEvent += process_tick\n\n# For bars  \nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += process_bar","language":"python","description":"\u2705 ALWAYS DO THIS:"},"stats":{"mentions":1,"sources":["ex_0021_b4426143"]}},{"id":"merged_ex_0022_a3f0f5a9","topic":" Basic Ticker (Streaming)","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Start streaming\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data\nib.sleep(2)\n\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Last: {ticker.last}\")\nprint(f\"Volume: {ticker.volume}\")","language":"python","description":" Basic Ticker (Streaming)"},"stats":{"mentions":1,"sources":["ex_0022_a3f0f5a9"]}},{"id":"merged_ex_0023_e4cf6f06","topic":" With Event Handler","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"def on_ticker_update(ticker):\n    print(f\"{ticker.contract.symbol}: ${ticker.last:.2f}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_ticker_update","language":"python","description":" With Event Handler"},"stats":{"mentions":1,"sources":["ex_0023_e4cf6f06"]}},{"id":"merged_ex_0024_0e65c2b1","topic":" Generic Ticks (Extra Data)","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"# Request additional data\nticker = ib.reqMktData(\n    contract,\n    genericTickList='233,236',  # Volume, shortable shares\n    snapshot=False\n)\n\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}\")\nprint(f\"RT Volume: {ticker.rtVolume}\")","language":"python","description":" Generic Ticks (Extra Data)"},"stats":{"mentions":1,"sources":["ex_0024_0e65c2b1"]}},{"id":"merged_ex_0025_b431b910","topic":" Generic Tick IDs","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"100 - Option volume\n101 - Option open interest  \n104 - Historical volatility\n106 - Implied volatility\n165 - 52-week high/low\n221 - Mark price\n233 - Last, volume, VWAP\n236 - Shortable shares\n258 - Fundamental ratios","language":"python","description":" Generic Tick IDs"},"stats":{"mentions":1,"sources":["ex_0025_b431b910"]}},{"id":"merged_ex_0026_bff1f5f7","topic":" Cancel Streaming","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ib.cancelMktData(contract)","language":"python","description":" Cancel Streaming"},"stats":{"mentions":1,"sources":["ex_0026_bff1f5f7"]}},{"id":"merged_ex_0027_f3914538","topic":" Real-Time Bars (5-Second Updates)","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"bars = ib.reqRealTimeBars(\n    contract,\n    barSize=5,              # Always 5 seconds\n    whatToShow='TRADES',    # TRADES, MIDPOINT, BID, ASK\n    useRTH=False\n)\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"{bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close} V:{bar.volume}\")\n\nbars.updateEvent += on_bar_update\n\n# Cancel when done\nib.cancelRealTimeBars(bars)","language":"python","description":" Real-Time Bars (5-Second Updates)"},"stats":{"mentions":1,"sources":["ex_0027_f3914538"]}},{"id":"merged_ex_0029_6e6893b1","topic":" Duration Options","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"'60 S'  - 60 seconds\n'1 D'   - 1 day\n'2 W'   - 2 weeks\n'6 M'   - 6 months\n'1 Y'   - 1 year","language":"python","description":" Duration Options"},"stats":{"mentions":1,"sources":["ex_0029_6e6893b1"]}},{"id":"merged_ex_0030_b39d58cf","topic":" Bar Sizes","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"'1 secs', '5 secs', '15 secs', '30 secs'\n'1 min', '5 mins', '15 mins', '30 mins'\n'1 hour', '4 hours'\n'1 day', '1 week', '1 month'","language":"python","description":" Bar Sizes"},"stats":{"mentions":1,"sources":["ex_0030_b39d58cf"]}},{"id":"merged_ex_0031_809d444a","topic":" What to Show","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"'TRADES'    - Actual trades (default)\n'MIDPOINT'  - Bid/ask midpoint\n'BID'       - Bid prices\n'ASK'       - Ask prices","language":"python","description":" What to Show"},"stats":{"mentions":1,"sources":["ex_0031_809d444a"]}},{"id":"merged_ex_0032_34b0e6c2","topic":" Keep Historical Updated (Live)","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    keepUpToDate=True  # \u2190 Auto-update!\n)\n\nbars.updateEvent += lambda bars, hasNewBar: print(f\"Updated: {hasNewBar}\")","language":"python","description":" Keep Historical Updated (Live)"},"stats":{"mentions":1,"sources":["ex_0032_34b0e6c2"]}},{"id":"merged_ex_0033_b6bbded7","topic":" Tick-by-Tick Data","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"ticker = ib.reqTickByTickData(\n    contract,\n    tickType='AllLast',  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks=0,\n    ignoreSize=False\n)\n\ndef on_tick(ticker):\n    if ticker.tickByTicks:\n        tick = ticker.tickByTicks[-1]\n        print(f\"Tick: {tick.time} {tick.price} x {tick.size}\")\n\nticker.updateEvent += on_tick","language":"python","description":" Tick-by-Tick Data"},"stats":{"mentions":1,"sources":["ex_0033_b6bbded7"]}},{"id":"merged_ex_0034_785d16e2","topic":" Market Depth (Level II)","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ticker = ib.reqMktDepth(\n    contract,\n    numRows=10,\n    isSmartDepth=False\n)\n\nib.sleep(2)\n\nprint(\"Bids:\")\nfor bid in ticker.domBids:\n    print(f\"  {bid.price} x {bid.size}\")\n\nprint(\"Asks:\")\nfor ask in ticker.domAsks:\n    print(f\"  {ask.price} x {ask.size}\")\n\n# Cancel\nib.cancelMktDepth(contract)","language":"python","description":" Market Depth (Level II)"},"stats":{"mentions":1,"sources":["ex_0034_785d16e2"]}},{"id":"merged_ex_0035_c23ecc05","topic":" Multiple Tickers Pattern","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract)\n\nib.run()  # Run event loop","language":"python","description":" Multiple Tickers Pattern"},"stats":{"mentions":1,"sources":["ex_0035_c23ecc05"]}},{"id":"merged_ex_0037_86e01f21","topic":" Price Alert System","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"def price_alert(ticker, target_price, above=True):\n    \"\"\"Alert when price crosses threshold\"\"\"\n    def check_price(ticker):\n        if not ticker.last or ticker.last != ticker.last:\n            return\n        \n        if above and ticker.last >= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} above ${target_price}\")\n            ticker.updateEvent -= check_price  # Unsubscribe\n        elif not above and ticker.last <= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} below ${target_price}\")\n            ticker.updateEvent -= check_price\n    \n    ticker.updateEvent += check_price\n\n# Usage\nticker = ib.reqMktData(contract)\nprice_alert(ticker, 180.0, above=True)","language":"python","description":" Price Alert System"},"stats":{"mentions":1,"sources":["ex_0037_86e01f21"]}},{"id":"merged_ex_0038_342563ba","topic":" Moving Average Calculator","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"class MovingAverage:\n    def __init__(self, period=20):\n        self.period = period\n        self.prices = []\n    \n    def update(self, price):\n        self.prices.append(price)\n        if len(self.prices) > self.period:\n            self.prices.pop(0)\n    \n    def value(self):\n        return sum(self.prices) / len(self.prices) if self.prices else None\n\nma20 = MovingAverage(20)\n\ndef on_bar(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        ma20.update(bar.close)\n        if ma20.value():\n            print(f\"Price: {bar.close:.2f} | MA20: {ma20.value():.2f}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += on_bar","language":"python","description":" Moving Average Calculator"},"stats":{"mentions":1,"sources":["ex_0038_342563ba"]}},{"id":"merged_ex_0039_6faded7e","topic":" OHLC Tracker","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"class OHLCTracker:\n    def __init__(self):\n        self.open = None\n        self.high = None\n        self.low = None\n        self.close = None\n    \n    def update(self, price):\n        if self.open is None:\n            self.open = price\n        \n        if self.high is None or price > self.high:\n            self.high = price\n        \n        if self.low is None or price < self.low:\n            self.low = price\n        \n        self.close = price\n    \n    def reset(self):\n        self.open = self.high = self.low = self.close = None\n\ntracker = OHLCTracker()\n\ndef on_tick(ticker):\n    if ticker.last:\n        tracker.update(ticker.last)\n        print(f\"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_tick","language":"python","description":" OHLC Tracker"},"stats":{"mentions":1,"sources":["ex_0039_6faded7e"]}},{"id":"merged_ex_0040_8452a621","topic":"Every request method exists in two versions. Block","tier":"a2","confidence":1.0,"tags":["as","co","ct","da"],"content":{"code":"# Blocking interface - simple and direct\nfrom ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)  # Blocks until complete","language":"python","description":"Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout..."},"stats":{"mentions":1,"sources":["ex_0040_8452a621"]}},{"id":"merged_ex_0041_e5acebcb","topic":"ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1","tier":"a2","confidence":1.0,"tags":["as","co","ct","da"],"content":{"code":"# Asynchronous interface - non-blocking\nimport asyncio\nfrom ib_insync import *\n\nasync def main():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking\n    \nasyncio.run(main())","language":"python","description":"ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)   Blocks until complete\n"},"stats":{"mentions":1,"sources":["ex_0041_e5acebcb"]}},{"id":"merged_ex_0042_4c1e2894","topic":"The golden rule: never use time.sleep()\u2014always use","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"# WRONG - freezes everything\nimport time\nticker = ib.reqMktData(contract)\ntime.sleep(5)  # Event loop frozen, no updates processed\nprint(ticker.last)  # May be empty\n\n# CORRECT - allows message processing\nticker = ib.reqMktData(contract)\nib.sleep(5)  # Framework processes updates in background\nprint(ticker.last)  # Contains current data","language":"python","description":"The golden rule: never use time.sleep()\u2014always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields..."},"stats":{"mentions":1,"sources":["ex_0042_4c1e2894"]}},{"id":"merged_ex_0043_5d3bba14","topic":"For Jupyter notebooks and environments with existi","tier":"a2","confidence":1.0,"tags":["as","co","vnt"],"content":{"code":"# Jupyter notebook setup\nfrom ib_insync import *\n\nutil.startLoop()  # Enables nested event loops\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n# Can now use blocking methods directly in notebook cells","language":"python","description":"For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package."},"stats":{"mentions":1,"sources":["ex_0043_5d3bba14"]}},{"id":"merged_ex_0044_cff8313a","topic":"For applications that run indefinitely monitoring ","tier":"a2","confidence":1.0,"tags":["co","ct","da","vnt","prt"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef onTicker(ticker):\n    print(f\"Price update: {ticker.contract.symbol} @ {ticker.last}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTicker\n\nib.run()  # Runs event loop indefinitely","language":"python","description":"For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u..."},"stats":{"mentions":1,"sources":["ex_0044_cff8313a"]}},{"id":"merged_ex_0045_4e24d1aa","topic":"ibinsync uses the eventkit library for its event s","tier":"a2","confidence":1.0,"tags":["as","ct","vnt","or"],"content":{"code":"# Synchronous event handler\ndef onOrderStatus(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    if trade.isDone():\n        print(f\"Filled at: {trade.orderStatus.avgFillPrice}\")\n\nib.orderStatusEvent += onOrderStatus\n\n# Asynchronous event handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        print(f\"New bar: {bars[-1]}\")\n        # Can use await inside async handlers\n        await ib.qualifyContractsAsync(contract)\n\nbars.updateEvent += onBarUpdate","language":"python","description":"ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines."},"stats":{"mentions":1,"sources":["ex_0045_4e24d1aa"]}},{"id":"merged_ex_0046_d613ad24","topic":"Ticker-specific events provide fine-grained contro","tier":"a2","confidence":1.0,"tags":["as","ct","da","vnt"],"content":{"code":"contract = Forex('EURUSD')\nticker = ib.reqMktData(contract)\n\nasync def onTickerUpdate(ticker):\n    print(f\"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}\")\n    \nticker.updateEvent += onTickerUpdate","language":"python","description":"Ticker-specific events provide fine-grained control over individual market data subscriptions:"},"stats":{"mentions":1,"sources":["ex_0046_d613ad24"]}},{"id":"merged_ex_0047_02297e7d","topic":"Unsubscribe from events using the -= operator, and","tier":"a2","confidence":1.0,"tags":["as","vnt"],"content":{"code":"# Unsubscribe\nticker.updateEvent -= onTickerUpdate\n\n# One-time handler\n@ticker.updateEvent.once\ndef onFirstUpdate(ticker):\n    print(f\"First update received: {ticker.last}\")","language":"python","description":"Unsubscribe from events using the -= operator, and use the @event.once decorator for one-time handlers that automatically unsubscribe after firing."},"stats":{"mentions":1,"sources":["ex_0047_02297e7d"]}},{"id":"merged_ex_0048_4f262d22","topic":"Leverage asyncio.gather() to execute multiple requ","tier":"a2","confidence":1.0,"tags":["as","co","ct"],"content":{"code":"async def get_multiple_contracts():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    contracts = [\n        Stock('AAPL', 'SMART', 'USD'),\n        Stock('GOOGL', 'SMART', 'USD'),\n        Stock('MSFT', 'SMART', 'USD')\n    ]\n    \n    # Request all contract details concurrently\n    results = await asyncio.gather(*[\n        ib.reqContractDetailsAsync(c) for c in contracts\n    ])\n    \n    return results","language":"python","description":"Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations."},"stats":{"mentions":1,"sources":["ex_0048_4f262d22"]}},{"id":"merged_ex_0049_17c31825","topic":"Use asyncio.createtask() for truly concurrent exec","tier":"a2","confidence":1.0,"tags":["as","co","ct","da"],"content":{"code":"async def monitor_multiple_tickers():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    async def watch_ticker(contract):\n        ticker = ib.reqMktData(contract)\n        await ib.sleep(1)\n        return ticker\n    \n    # Create tasks for concurrent execution\n    tasks = [\n        asyncio.create_task(watch_ticker(Forex('EURUSD'))),\n        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),\n        asyncio.create_task(watch_ticker(Forex('USDJPY')))\n    ]\n    \n    tickers = await asyncio.gather(*tasks)\n    return tickers","language":"python","description":"Use asyncio.createtask() for truly concurrent execution of independent operations:"},"stats":{"mentions":1,"sources":["ex_0049_17c31825"]}},{"id":"merged_ex_0050_6a97af6f","topic":"Blocking callbacks: Never make blocking calls insi","tier":"a2","confidence":1.0,"tags":["as","ct","vnt"],"content":{"code":"# WRONG - blocks event loop in callback\ndef onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        ib.qualifyContracts(contract)  # Blocking!\n\n# CORRECT - use async handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        await ib.qualifyContractsAsync(contract)","language":"python","description":"Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately."},"stats":{"mentions":1,"sources":["ex_0050_6a97af6f"]}},{"id":"merged_ex_0051_76c1e159","topic":"Missing tick data with waitOnUpdate(): The waitOnU","tier":"a2","confidence":1.0,"tags":["as","vnt"],"content":{"code":"# WRONG - misses rapid ticks\nwhile True:\n    ib.waitOnUpdate()\n    print(ticker.last)\n\n# CORRECT - captures all updates\ndef onTicker(ticker):\n    print(ticker.last)\n    \nticker.updateEvent += onTicker","language":"python","description":"Missing tick data with waitOnUpdate(): The waitOnUpdate() method can miss rapid updates because ticks from the first update get cleared before processing. Always use event handlers for tick data colle..."},"stats":{"mentions":1,"sources":["ex_0051_76c1e159"]}},{"id":"merged_ex_0052_e56ea900","topic":"The IB class provides the user-facing interface, b","tier":"a2","confidence":1.0,"tags":["prt"],"content":{"code":"# Internal architecture (conceptual)\nIB Instance\n    \u2514\u2500\u2500 Wrapper Instance (single source of truth)\n        \u251c\u2500\u2500 accountValues (dict)\n        \u251c\u2500\u2500 acctSummary (dict)\n        \u251c\u2500\u2500 portfolio (defaultdict)\n        \u251c\u2500\u2500 positions (defaultdict)\n        \u251c\u2500\u2500 trades (dict)\n        \u251c\u2500\u2500 tickers (dict)\n        \u2514\u2500\u2500 [other state collections]\n    \u2514\u2500\u2500 Client Instance (network communication)","language":"python","description":"The IB class provides the user-facing interface, but internally delegates all state storage to the Wrapper. This Wrapper maintains dictionaries for account values, portfolio items, positions, trades, ..."},"stats":{"mentions":1,"sources":["ex_0052_e56ea900"]}},{"id":"merged_ex_0053_127607b2","topic":"The critical pattern: never store copies of state ","tier":"a2","confidence":1.0,"tags":["ct","prt"],"content":{"code":"# CORRECT - access live state\ndef check_positions():\n    positions = ib.positions()\n    for pos in positions:\n        print(f\"{pos.contract.symbol}: {pos.position}\")\n\n# WRONG - storing stale copies\ncached_positions = ib.positions()  # Snapshot becomes stale\n# Later...\nprint(cached_positions)  # Likely outdated","language":"python","description":"The critical pattern: never store copies of state in long-lived variables. Always call IB methods to access current state. Stored copies become stale as the Wrapper updates in the background."},"stats":{"mentions":1,"sources":["ex_0053_127607b2"]}},{"id":"merged_ex_0054_2b50dee3","topic":"The returned objects themselves\u2014Ticker, Trade, Pos","tier":"a2","confidence":1.0,"tags":["ct","da","or","prt"],"content":{"code":"# Trade object is automatically updated\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# trade.orderStatus updates automatically in background\ndef check_order_status():\n    if trade.orderStatus.status == 'Filled':\n        print(\"Order filled!\")\n    elif trade.isDone():\n        print(\"Order completed\")","language":"python","description":"The returned objects themselves\u2014Ticker, Trade, Position, Portfolio\u2014are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an..."},"stats":{"mentions":1,"sources":["ex_0054_2b50dee3"]}},{"id":"merged_ex_0055_3cb13bff","topic":"Use events for real-time updates rather than polli","tier":"a2","confidence":1.0,"tags":["ct","vnt","prt"],"content":{"code":"def onPositionUpdate(position):\n    print(f\"Position: {position.contract.symbol}: {position.position}\")\n\nib.positionEvent += onPositionUpdate\n\ndef onPortfolioUpdate(item):\n    print(f\"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}\")\n\nib.updatePortfolioEvent += onPortfolioUpdate","language":"python","description":"Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking."},"stats":{"mentions":1,"sources":["ex_0055_3cb13bff"]}},{"id":"merged_ex_0056_43a0d333","topic":"The global updateEvent fires on any state change, ","tier":"a2","confidence":1.0,"tags":["vnt","prt"],"content":{"code":"def onUpdate():\n    positions = ib.positions()\n    print(f\"Current positions: {len(positions)}\")\n\nib.updateEvent += onUpdate","language":"python","description":"The global updateEvent fires on any state change, useful for triggering comprehensive checks:"},"stats":{"mentions":1,"sources":["ex_0056_43a0d333"]}},{"id":"merged_ex_0057_0fc7542b","topic":"When performing calculations or processing that ta","tier":"a2","confidence":1.0,"tags":["vnt","prt"],"content":{"code":"def long_calculation():\n    for i in range(1000):\n        result = expensive_operation()\n        \n        # Periodically yield to allow state updates\n        if i % 100 == 0:\n            ib.sleep(0)\n        \n        # State may have changed during sleep\n        current_positions = ib.positions()","language":"python","description":"When performing calculations or processing that takes significant time, yield control to the event loop periodically using ib.sleep(0). This allows the Wrapper to process incoming messages and update ..."},"stats":{"mentions":1,"sources":["ex_0057_0fc7542b"]}},{"id":"merged_ex_0058_425a6b9f","topic":" Patterns for accessing portfolio and positions","tier":"a2","confidence":1.0,"tags":["ct","prt"],"content":{"code":"# All portfolio items across accounts\nall_portfolio = ib.portfolio()\n\n# Portfolio for specific account\naccount_portfolio = ib.portfolio(account='U1234567')\n\n# All positions\nall_positions = ib.positions()\n\n# Positions for specific account\naccount_positions = ib.positions(account='U1234567')\n\n# Iterate through positions\nfor position in ib.positions():\n    symbol = position.contract.symbol\n    qty = position.position\n    avg_cost = position.avgCost\n    print(f\"{symbol}: {qty} @ ${avg_cost}\")","language":"python","description":" Patterns for accessing portfolio and positions"},"stats":{"mentions":1,"sources":["ex_0058_425a6b9f"]}},{"id":"merged_ex_0059_7013efa0","topic":" Trade and order management state","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"# Get all open orders\nopen_orders = ib.orders()\n\n# Get all trades (open and completed from this session)\nall_trades = ib.trades()\n\n# Get all fills from this session\nfills = ib.fills()\n\n# Request all open orders including from other clients\nib.reqAllOpenOrders()","language":"python","description":" Trade and order management state"},"stats":{"mentions":1,"sources":["ex_0059_7013efa0"]}},{"id":"merged_ex_0060_374afa70","topic":"ibinsync uses asyncio and is not thread-safe. All ","tier":"a2","confidence":1.0,"tags":["as","ct","vnt","prt"],"content":{"code":"# WRONG - threading with asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nexecutor = ThreadPoolExecutor(max_workers=2)\nexecutor.submit(ib.positions)  # Will fail!\n\n# CORRECT - use asyncio tasks\nasync def fetch_multiple_contracts():\n    tasks = [\n        ib.qualifyContractsAsync(contract1),\n        ib.qualifyContractsAsync(contract2),\n        ib.qualifyContractsAsync(contract3)\n    ]\n    results = await asyncio.gather(*tasks)\n    return results","language":"python","description":"ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading."},"stats":{"mentions":1,"sources":["ex_0060_374afa70"]}},{"id":"merged_ex_0061_f269a415","topic":"Caching with incorrect invalidation: If you must c","tier":"a2","confidence":1.0,"tags":["prt"],"content":{"code":"class TradingBot:\n    def __init__(self, ib):\n        self.ib = ib\n        self._positions_cache = None\n        self._cache_time = None\n        \n    def get_positions(self, max_age=1.0):\n        \"\"\"Get positions with short-term caching\"\"\"\n        now = time.time()\n        if (self._positions_cache is None or \n            self._cache_time is None or \n            now - self._cache_time > max_age):\n            self._positions_cache = self.ib.positions()\n            self._cache_time = now\n        return self._positions_cache","language":"python","description":"Caching with incorrect invalidation: If you must cache state for performance, implement short-lived caching with explicit refresh logic."},"stats":{"mentions":1,"sources":["ex_0061_f269a415"]}},{"id":"merged_ex_0062_4ca1eb17","topic":"Not checking connection state: Always verify conne","tier":"a2","confidence":1.0,"tags":["co","ct","da","er"],"content":{"code":"def get_price():\n    if not ib.isConnected():\n        raise ConnectionError(\"Not connected to IB\")\n    ticker = ib.reqMktData(contract)\n    ib.sleep(2)\n    if ticker.last:\n        return ticker.last\n    raise ValueError(\"No price data available\")","language":"python","description":"Not checking connection state: Always verify connection before state access."},"stats":{"mentions":1,"sources":["ex_0062_4ca1eb17"]}},{"id":"merged_ex_0063_228c81f6","topic":" Production-ready state manager","tier":"a2","confidence":1.0,"tags":["co","ct","er","vnt","prt"],"content":{"code":"from ib_insync import *\nimport logging\n\nclass IBDataManager:\n    \"\"\"Demonstrates best practices for single source of truth pattern\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self._setup_logging()\n        self._setup_events()\n    \n    def _setup_logging(self):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n    \n    def _setup_events(self):\n        self.ib.connectedEvent += self._on_connected\n        self.ib.disconnectedEvent += self._on_disconnected\n        self.ib.positionEvent += self._on_position\n        self.ib.updatePortfolioEvent += self._on_portfolio\n    \n    def connect(self):\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(\"Connected to IB\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _on_connected(self):\n        self.logger.info(\"Connection established\")\n        self.ib.reqAccountSummary()\n    \n    def _on_disconnected(self):\n        self.logger.warning(\"Disconnected from IB\")\n    \n    def _on_position(self, position):\n        self.logger.info(f\"Position update: {position.contract.symbol}\")\n    \n    def _on_portfolio(self, item):\n        self.logger.info(f\"Portfolio update: {item.contract.symbol}\")\n    \n    def get_current_positions(self):\n        \"\"\"Get current positions (always fresh from single source)\"\"\"\n        if not self.ib.isConnected():\n            raise ConnectionError(\"Not connected\")\n        return self.ib.positions()\n    \n    def get_position_for_symbol(self, symbol):\n        \"\"\"Get position for specific symbol\"\"\"\n        for pos in self.get_current_positions():\n            if pos.contract.symbol == symbol:\n                return pos\n        return None","language":"python","description":" Production-ready state manager"},"stats":{"mentions":1,"sources":["ex_0063_228c81f6"]}},{"id":"merged_ex_0064_bdc1144a","topic":"Market orders execute immediately at the current m","tier":"a2","confidence":1.0,"tags":["co","ct","or"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Create and qualify contract\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Create and place market order\norder = MarketOrder('BUY', 100)\ntrade = ib.placeOrder(contract, order)\n\n# Monitor order status\nprint(f\"Order status: {trade.orderStatus.status}\")","language":"python","description":"Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets."},"stats":{"mentions":1,"sources":["ex_0064_bdc1144a"]}},{"id":"merged_ex_0065_1584a6ea","topic":"Market orders often execute so quickly that interm","tier":"a2","confidence":1.0,"tags":["ct","vnt","or"],"content":{"code":"def order_status_callback(trade):\n    if trade.orderStatus.status == 'Filled':\n        fill = trade.fills[-1]\n        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '\n              f'{fill.execution.shares} @ {fill.execution.avgPrice}')\n\ntrade.filledEvent += order_status_callback","language":"python","description":"Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders."},"stats":{"mentions":1,"sources":["ex_0065_1584a6ea"]}},{"id":"merged_ex_0066_d7c5ce88","topic":"Limit orders execute only at the specified price o","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Basic limit order\nlimit_order = LimitOrder('BUY', 100, 150.00)\ntrade = ib.placeOrder(contract, limit_order)\n\n# Limit order with time-in-force\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.tif = 'GTD'  # Good Till Date\nlimit_order.goodTillDate = '20240331 23:59:59'\ntrade = ib.placeOrder(contract, limit_order)\n\n# Allow outside regular trading hours\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.outsideRth = True\ntrade = ib.placeOrder(contract, limit_order)","language":"python","description":"Limit orders execute only at the specified price or better, providing price protection but no guarantee of execution. Set time-in-force parameters to control order lifespan."},"stats":{"mentions":1,"sources":["ex_0066_d7c5ce88"]}},{"id":"merged_ex_0067_f66f09e8","topic":"Trailing stops follow favorable price movement, ma","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Trailing stop with fixed dollar amount\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.auxPrice = 2.0  # Trail by $2\ntrailing_order.trailStopPrice = 150.0  # Initial trigger price\n\ntrade = ib.placeOrder(contract, trailing_order)\n\n# Trailing stop with percentage\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.trailingPercent = 5.0  # Trail by 5%\n\ntrade = ib.placeOrder(contract, trailing_order)","language":"python","description":"Trailing stops follow favorable price movement, maintaining a specified distance from the highest price reached (for sells) or lowest price (for buys). They protect profits while allowing continued up..."},"stats":{"mentions":1,"sources":["ex_0067_f66f09e8"]}},{"id":"merged_ex_0068_68d1eeb1","topic":"Trailing stop limit orders trigger a limit order (","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"trail_limit_order = Order()\ntrail_limit_order.orderType = 'TRAIL LIMIT'\ntrail_limit_order.totalQuantity = 100\ntrail_limit_order.action = 'SELL'\ntrail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop\ntrail_limit_order.auxPrice = 2.0  # Trail amount\ntrail_limit_order.trailStopPrice = 150.0\n\ntrade = ib.placeOrder(contract, trail_limit_order)","language":"python","description":"Trailing stop limit orders trigger a limit order (rather than market order) when the stop is hit, providing more control but risking non-execution:"},"stats":{"mentions":1,"sources":["ex_0068_68d1eeb1"]}},{"id":"merged_ex_0069_97afc54d","topic":"OCO orders link multiple orders such that when one","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Using the helper method (recommended)\norders = [\n    LimitOrder('BUY', 100, 150.00),\n    LimitOrder('BUY', 100, 149.00),\n    LimitOrder('BUY', 100, 148.00)\n]\n\noca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)\n\nfor order in oca_orders:\n    ib.placeOrder(contract, order)","language":"python","description":"OCO orders link multiple orders such that when one executes, the others automatically cancel. Use for scenarios like placing buy orders at multiple price levels where you only want one fill."},"stats":{"mentions":1,"sources":["ex_0069_97afc54d"]}},{"id":"merged_ex_0070_e2d9a68a","topic":"Manual OCO setup provides more control over indivi","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"oca_group_name = 'MyOCAGroup_123'\n\norder1 = LimitOrder('BUY', 100, 150.00)\norder1.ocaGroup = oca_group_name\norder1.ocaType = 2  # Proportional reduction with block\norder1.transmit = False\n\norder2 = LimitOrder('BUY', 100, 149.00)\norder2.ocaGroup = oca_group_name\norder2.ocaType = 2\norder2.transmit = False\n\norder3 = LimitOrder('BUY', 100, 148.00)\norder3.ocaGroup = oca_group_name\norder3.ocaType = 2\norder3.transmit = True  # Last order triggers transmission\n\nib.placeOrder(contract, order1)\nib.placeOrder(contract, order2)\nib.placeOrder(contract, order3)","language":"python","description":"Manual OCO setup provides more control over individual order parameters:"},"stats":{"mentions":1,"sources":["ex_0070_e2d9a68a"]}},{"id":"merged_ex_0071_a5aa41ea","topic":"Bracket orders combine an entry order with both pr","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"# Using the helper function (recommended)\nbracket = ib.bracketOrder(\n    'BUY',\n    quantity=100,\n    limitPrice=150.00,\n    takeProfitPrice=155.00,\n    stopLossPrice=145.00\n)\n\nfor order in bracket:\n    ib.placeOrder(contract, order)","language":"python","description":"Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af..."},"stats":{"mentions":1,"sources":["ex_0071_a5aa41ea"]}},{"id":"merged_ex_0072_20869a92","topic":"For market entry instead of limit entry, modify th","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)\nbracket[0].orderType = 'MKT'\nbracket[0].lmtPrice = 0\n\nfor order in bracket:\n    ib.placeOrder(contract, order)","language":"python","description":"For market entry instead of limit entry, modify the parent order:"},"stats":{"mentions":1,"sources":["ex_0072_20869a92"]}},{"id":"merged_ex_0073_68026665","topic":"Manual bracket construction for full control:","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"parent = Order()\nparent.orderId = ib.client.getReqId()\nparent.action = 'BUY'\nparent.orderType = 'LMT'\nparent.totalQuantity = 100\nparent.lmtPrice = 150.00\nparent.transmit = False\n\ntakeProfit = Order()\ntakeProfit.orderId = parent.orderId + 1\ntakeProfit.action = 'SELL'\ntakeProfit.orderType = 'LMT'\ntakeProfit.totalQuantity = 100\ntakeProfit.lmtPrice = 155.00\ntakeProfit.parentId = parent.orderId\ntakeProfit.transmit = False\n\nstopLoss = Order()\nstopLoss.orderId = parent.orderId + 2\nstopLoss.action = 'SELL'\nstopLoss.orderType = 'STP'\nstopLoss.auxPrice = 145.00\nstopLoss.totalQuantity = 100\nstopLoss.parentId = parent.orderId\nstopLoss.transmit = True  # Last order triggers all\n\nib.placeOrder(contract, parent)\nib.placeOrder(contract, takeProfit)\nib.placeOrder(contract, stopLoss)","language":"python","description":"Manual bracket construction for full control:"},"stats":{"mentions":1,"sources":["ex_0073_68026665"]}},{"id":"merged_ex_0074_62270345","topic":"Scale out of positions by setting multiple take-pr","tier":"a2","confidence":1.0,"tags":["ct","or","prt"],"content":{"code":"from typing import NamedTuple\n\nclass BracketOrderTwoTargets(NamedTuple):\n    parent: Order\n    takeProfit1: Order\n    takeProfit2: Order\n    stopLoss: Order\n\ndef bracket_two_targets(action, quantity, limit_price, \n                       tp_price1, tp_price2, sl_price, ib):\n    \"\"\"Create bracket with two take-profit targets\"\"\"\n    \n    parent = LimitOrder(action, quantity, limit_price)\n    parent.orderId = ib.client.getReqId()\n    parent.transmit = False\n    \n    # First take profit (half position)\n    takeProfit1 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price1\n    )\n    takeProfit1.orderId = parent.orderId + 1\n    takeProfit1.parentId = parent.orderId\n    takeProfit1.transmit = False\n    \n    # Second take profit (remaining half)\n    takeProfit2 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price2\n    )\n    takeProfit2.orderId = parent.orderId + 2\n    takeProfit2.parentId = parent.orderId\n    takeProfit2.transmit = False\n    \n    # Stop loss for full position\n    stopLoss = StopOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity,\n        sl_price\n    )\n    stopLoss.orderId = parent.orderId + 3\n    stopLoss.parentId = parent.orderId\n    stopLoss.transmit = True\n    \n    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)\n\n# Usage\nbracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)\nfor order in bracket:\n    ib.placeOrder(contract, order)","language":"python","description":"Scale out of positions by setting multiple take-profit levels:"},"stats":{"mentions":1,"sources":["ex_0074_62270345"]}},{"id":"merged_ex_0075_d96e77e8","topic":"For strategies requiring exact profit/loss ratios ","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"contract = Forex('GBPUSD')\nib.qualifyContracts(contract)\n\n# Place entry order\nparent_order = MarketOrder('BUY', 25000)\ntrade = ib.placeOrder(contract, parent_order)\n\n# Wait for fill\nib.sleep(1)\nwhile trade.orderStatus.status != 'Filled':\n    ib.waitOnUpdate()\n\n# Calculate levels based on actual fill price\nfill_price = trade.orderStatus.avgFillPrice\nstop_loss_price = fill_price - 0.0015\ntake_profit_price = fill_price + 0.0020\n\n# Place child orders\nstop_loss_order = StopOrder('SELL', 25000, stop_loss_price)\ntake_profit_order = LimitOrder('SELL', 25000, take_profit_price)\n\nib.placeOrder(contract, stop_loss_order)\nib.placeOrder(contract, take_profit_order)","language":"python","description":"For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:"},"stats":{"mentions":1,"sources":["ex_0075_d96e77e8"]}},{"id":"merged_ex_0076_c4ff8d3a","topic":" Order status monitoring","tier":"a2","confidence":1.0,"tags":["vnt","or"],"content":{"code":"# Trade object attributes\ntrade.order          # The original order\ntrade.orderStatus    # Current status object\ntrade.fills          # List of fills\ntrade.log            # Log of status changes\ntrade.isActive()     # Is order still active\ntrade.isDone()       # Is order complete\n\n# Order status values\n# PendingSubmit, PendingCancel, PreSubmitted, Submitted, \n# Filled, Cancelled, Inactive, ApiPending\n\n# Event callbacks for monitoring\ndef on_fill(trade, fill):\n    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')\n\ntrade.fillEvent += on_fill\n\ndef on_filled(trade):\n    total = sum(f.execution.shares for f in trade.fills)\n    avg_price = trade.orderStatus.avgFillPrice\n    print(f'Complete: {total} shares @ avg {avg_price}')\n\ntrade.filledEvent += on_filled\n\ndef on_status(trade):\n    print(f'Status: {trade.orderStatus.status}')\n\ntrade.statusEvent += on_status","language":"python","description":" Order status monitoring"},"stats":{"mentions":1,"sources":["ex_0076_c4ff8d3a"]}},{"id":"merged_ex_0077_85f6c0d1","topic":"The Future class provides the cleanest syntax for ","tier":"a2","confidence":1.0,"tags":["co","ct"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Recommended method\ncontract = Future('ES', '202506', 'CME')\n\n# With additional parameters\ncontract = Future(\n    symbol='ES',\n    lastTradeDateOrContractMonth='202506',\n    exchange='CME',\n    localSymbol='ESM6',\n    multiplier='50',\n    currency='USD'\n)","language":"python","description":"The Future class provides the cleanest syntax for futures contracts:"},"stats":{"mentions":1,"sources":["ex_0077_85f6c0d1"]}},{"id":"merged_ex_0078_1e17e8a5","topic":"The generic Contract class requires more verbose s","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Contract()\ncontract.secType = 'FUT'\ncontract.symbol = 'MNQ'\ncontract.exchange = 'CME'\ncontract.currency = 'USD'\ncontract.localSymbol = 'MNQZ5'","language":"python","description":"The generic Contract class requires more verbose setup:"},"stats":{"mentions":1,"sources":["ex_0078_1e17e8a5"]}},{"id":"merged_ex_0079_8c44b68b","topic":"Using conId (contract identifier) provides the mos","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Contract(conId=495512516)","language":"python","description":"Using conId (contract identifier) provides the most precise identification when known:"},"stats":{"mentions":1,"sources":["ex_0079_8c44b68b"]}},{"id":"merged_ex_0080_52d6cf6d","topic":"Qualification sends a contract details request to ","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"# Single contract\ncontract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\n# Multiple contracts concurrently\ncontracts = [\n    Future('ES', '202506', 'CME'),\n    Future('NQ', '202506', 'CME'),\n    Future('CL', '202506', 'NYMEX')\n]\nqualified = ib.qualifyContracts(*contracts)","language":"python","description":"Qualification sends a contract details request to IB servers, fills in missing fields (especially conId, localSymbol, multiplier, exact expiry date, tradingClass), and returns a list of successfully q..."},"stats":{"mentions":1,"sources":["ex_0080_52d6cf6d"]}},{"id":"merged_ex_0081_642b54b4","topic":"The method updates the contract object in-place wh","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\nif qualified:\n    contract = qualified[0]\n    print(f\"ConId: {contract.conId}\")\n    print(f\"Local Symbol: {contract.localSymbol}\")\n    print(f\"Expiry: {contract.lastTradeDateOrContractMonth}\")","language":"python","description":"The method updates the contract object in-place when successful:"},"stats":{"mentions":1,"sources":["ex_0081_642b54b4"]}},{"id":"merged_ex_0082_b5e51137","topic":"When multiple contracts match your specification, ","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"# Too vague - multiple matches\ncontract = Future('ES', exchange='CME')\nib.qualifyContracts(contract)\n# Warning: Ambiguous contract, possibles are [Future('ES', '202506'), ...]\n\n# Specific - unambiguous\ncontract = Future('ES', '202506', 'CME')\nib.qualifyContracts(contract)  # Success\n\n# Or use localSymbol\ncontract = Future('ES', exchange='CME', localSymbol='ESM6')\nib.qualifyContracts(contract)  # Success\n\n# Or use conId (most precise)\ncontract = Contract(conId=495512516)\nib.qualifyContracts(contract)  # Always unambiguous","language":"python","description":"When multiple contracts match your specification, qualifyContracts() logs a warning with possible matches. The solution: be more specific with contract details."},"stats":{"mentions":1,"sources":["ex_0082_b5e51137"]}},{"id":"merged_ex_0083_62498bd6","topic":"Always validate and handle qualification failures ","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"def validate_futures_contract(ib, contract):\n    \"\"\"Validate and qualify a futures contract\"\"\"\n    try:\n        qualified = ib.qualifyContracts(contract)\n        if not qualified:\n            print(f\"ERROR: Contract could not be qualified\")\n            return None\n        \n        contract = qualified[0]\n        print(f\"\u2713 Qualified: {contract.localSymbol}\")\n        print(f\"  ConId: {contract.conId}\")\n        print(f\"  Expiry: {contract.lastTradeDateOrContractMonth}\")\n        return contract\n    except Exception as e:\n        print(f\"ERROR: {e}\")\n        return None\n\n# Usage\ncontract = Future('ES', '202506', 'CME')\nvalidated = validate_futures_contract(ib, contract)\nif validated:\n    order = MarketOrder('BUY', 1)\n    trade = ib.placeOrder(validated, order)","language":"python","description":"Always validate and handle qualification failures before placing orders:"},"stats":{"mentions":1,"sources":["ex_0083_62498bd6"]}},{"id":"merged_ex_0084_7ced81f4","topic":"Use reqContractDetails() to get comprehensive cont","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Future('ES', '202506', 'CME')\ndetails_list = ib.reqContractDetails(contract)\n\nfor details in details_list:\n    print(f\"ConId: {details.contract.conId}\")\n    print(f\"Local Symbol: {details.contract.localSymbol}\")\n    print(f\"Expiry: {details.contract.lastTradeDateOrContractMonth}\")\n    print(f\"Multiplier: {details.contract.multiplier}\")\n    print(f\"Min Tick: {details.minTick}\")\n    print(f\"Market Name: {details.marketName}\")","language":"python","description":"Use reqContractDetails() to get comprehensive contract information beyond basic qualification:"},"stats":{"mentions":1,"sources":["ex_0084_7ced81f4"]}},{"id":"merged_ex_0085_ff9da4c6","topic":"The includeExpired flag enables access to expired ","tier":"a2","confidence":1.0,"tags":["ct","da","or"],"content":{"code":"# Request data for expired contract\ncontract = Future('ES', '202012', 'CME')\ncontract.includeExpired = True\n\nqualified = ib.qualifyContracts(contract)\nif qualified:\n    bars = ib.reqHistoricalData(\n        qualified[0],\n        endDateTime='',\n        durationStr='1 Y',\n        barSizeSetting='1 day',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    print(f\"Retrieved {len(bars)} bars\")","language":"python","description":"The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl..."},"stats":{"mentions":1,"sources":["ex_0085_ff9da4c6"]}},{"id":"merged_ex_0086_5032bbea","topic":"Implement automatic front month detection to handl","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"from datetime import datetime\n\ndef get_front_month_contract(ib, symbol, exchange):\n    \"\"\"Get the front month futures contract\"\"\"\n    contract = Future(symbol, exchange=exchange)\n    contract_details = ib.reqContractDetails(contract)\n    \n    if not contract_details:\n        return None\n    \n    now = datetime.now()\n    active_contracts = []\n    \n    for details in contract_details:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(expiry_str, '%Y%m')\n        \n        if expiry > now:\n            active_contracts.append((expiry, details.contract))\n    \n    if not active_contracts:\n        return None\n    \n    # Sort and return front month\n    active_contracts.sort(key=lambda x: x[0])\n    front_month = active_contracts[0][1]\n    \n    qualified = ib.qualifyContracts(front_month)\n    return qualified[0] if qualified else None\n\n# Usage\nes_front = get_front_month_contract(ib, 'ES', 'CME')\nprint(f\"Front month: {es_front.localSymbol}\")","language":"python","description":"Implement automatic front month detection to handle contract rollovers:"},"stats":{"mentions":1,"sources":["ex_0086_5032bbea"]}},{"id":"merged_ex_0087_bdec6e72","topic":"Check if rollover is needed based on days to expir","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"def check_rollover_needed(contract, days_before=5):\n    \"\"\"Check if rollover needed\"\"\"\n    expiry_str = contract.lastTradeDateOrContractMonth\n    if len(expiry_str) == 8:\n        expiry = datetime.strptime(expiry_str, '%Y%m%d')\n    else:\n        expiry = datetime.strptime(expiry_str + '01', '%Y%m%d')\n    \n    days_to_expiry = (expiry - datetime.now()).days\n    return days_to_expiry <= days_before","language":"python","description":"Check if rollover is needed based on days to expiry:"},"stats":{"mentions":1,"sources":["ex_0087_bdec6e72"]}},{"id":"merged_ex_0088_0333ca26","topic":"ContFuture provides rolled contract data for backt","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"# Continuous futures (historical data only)\ncont_future = ContFuture('ES', 'CME')\nib.qualifyContracts(cont_future)\n\nbars = ib.reqHistoricalData(\n    cont_future,\n    endDateTime='',\n    durationStr='2 Y',\n    barSizeSetting='1 day',\n    whatToShow='TRADES',\n    useRTH=True\n)","language":"python","description":"ContFuture provides rolled contract data for backtesting but has significant limitations:"},"stats":{"mentions":1,"sources":["ex_0088_0333ca26"]}},{"id":"merged_ex_0089_aa3f4ca5","topic":"The most common method for real-time tick data, re","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Subscribe to market data\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data to populate\nib.sleep(2)\n\n# Access real-time data\nprint(f\"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}\")","language":"python","description":"The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:"},"stats":{"mentions":1,"sources":["ex_0089_aa3f4ca5"]}},{"id":"merged_ex_0090_63eb797f","topic":"The genericTickList parameter requests specific da","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"# Request time & sales data\nticker = ib.reqMktData(contract, '233', False, False)\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}\")","language":"python","description":"The genericTickList parameter requests specific data fields using tick IDs: 100 (options volume), 101 (options open interest), 106 (implied volatility), 165 (52-week high/low), 233 (time & sales with ..."},"stats":{"mentions":1,"sources":["ex_0090_63eb797f"]}},{"id":"merged_ex_0091_57100ddd","topic":"Provides 5-second aggregated bars, the only bar si","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Forex('EURUSD')\n\n# Request 5-second bars\nbars = ib.reqRealTimeBars(\n    contract,\n    5,              # Bar size (only 5 seconds supported)\n    'MIDPOINT',     # Can be TRADES, MIDPOINT, BID, or ASK\n    False           # useRTH\n)\n\n# Access bars list\nprint(bars[-1])  # Most recent bar","language":"python","description":"Provides 5-second aggregated bars, the only bar size supported by Interactive Brokers for real-time bar streaming:"},"stats":{"mentions":1,"sources":["ex_0091_57100ddd"]}},{"id":"merged_ex_0093_43b2c4bd","topic":"The most granular data stream, providing every ind","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"contract = Forex('EURUSD')\n\nticker = ib.reqTickByTickData(\n    contract,\n    'BidAsk',  # Can be Last, AllLast, BidAsk, or MidPoint\n    0,         # numberOfTicks (0 = unlimited)\n    False      # ignoreSize\n)\n\n# Access tick-by-tick data\nprint(ticker.tickByTicks)","language":"python","description":"The most granular data stream, providing every individual tick from the exchange. Limited to 3 simultaneous subscriptions per client:"},"stats":{"mentions":1,"sources":["ex_0093_43b2c4bd"]}},{"id":"merged_ex_0094_b590c4c9","topic":"Order book (Level II) data showing bid and ask dep","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"contract = Forex('EURUSD')\n\nticker = ib.reqMktDepth(contract)\nib.sleep(2)\n\n# Access order book\nprint(\"Bids:\", [(d.price, d.size) for d in ticker.domBids[:5]])\nprint(\"Asks:\", [(d.price, d.size) for d in ticker.domAsks[:5]])","language":"python","description":"Order book (Level II) data showing bid and ask depth. Requires Level II market data subscription:"},"stats":{"mentions":1,"sources":["ex_0094_b590c4c9"]}},{"id":"merged_ex_0095_c4cd43da","topic":"Individual ticker events for ticker-specific logic","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"def onTickerUpdate(ticker):\n    print(f\"{ticker.contract.symbol}: Last {ticker.last}\")\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTickerUpdate\n\nib.run()","language":"python","description":"Individual ticker events for ticker-specific logic:"},"stats":{"mentions":1,"sources":["ex_0095_c4cd43da"]}},{"id":"merged_ex_0096_ed4bca13","topic":"Global pendingTickersEvent for monitoring multiple","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\ndef onPendingTickers(tickers):\n    \"\"\"Called when any subscribed ticker has new data\"\"\"\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.last}\")\n\nib.pendingTickersEvent += onPendingTickers\nib.run()","language":"python","description":"Global pendingTickersEvent for monitoring multiple tickers efficiently:"},"stats":{"mentions":1,"sources":["ex_0096_ed4bca13"]}},{"id":"merged_ex_0097_3e1b5da3","topic":"Bar update events for streaming bar data:","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"def onBarUpdate(bars, hasNewBar):\n    \"\"\"\n    bars: BarDataList containing all bars\n    hasNewBar: Boolean indicating if a new bar was added\n    \"\"\"\n    if hasNewBar:\n        latest = bars[-1]\n        print(f\"New bar: O={latest.open}, H={latest.high}, \"\n              f\"L={latest.low}, C={latest.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += onBarUpdate\nib.run()","language":"python","description":"Bar update events for streaming bar data:"},"stats":{"mentions":1,"sources":["ex_0097_3e1b5da3"]}},{"id":"merged_ex_0098_3c54380f","topic":"Combine ibinsync with pandas for structured data h","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"import pandas as pd\n\ncontracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\n# Create DataFrame\ndf = pd.DataFrame(\n    index=[c.pair() for c in contracts],\n    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']\n)\n\ndef onPendingTickers(tickers):\n    for t in tickers:\n        df.loc[t.contract.pair()] = (\n            t.bidSize, t.bid, t.ask, t.askSize, \n            t.high, t.low, t.close\n        )\n    print(df)\n\nib.pendingTickersEvent += onPendingTickers\nib.sleep(30)","language":"python","description":"Combine ibinsync with pandas for structured data handling:"},"stats":{"mentions":1,"sources":["ex_0098_3c54380f"]}},{"id":"merged_ex_0099_24d7046c","topic":"Never use time.sleep() in callbacks or main code\u2014i","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"# WRONG - blocks everything\nimport time\n\ndef onTickerUpdate(ticker):\n    time.sleep(5)  # Frozen!\n    process(ticker)\n\n# CORRECT - yields control\ndef onTickerUpdate(ticker):\n    ib.sleep(0)  # Yields to allow message processing\n    process(ticker)","language":"python","description":"Never use time.sleep() in callbacks or main code\u2014it freezes the event loop and prevents message processing. Always use ib.sleep() to yield control."},"stats":{"mentions":1,"sources":["ex_0099_24d7046c"]}},{"id":"merged_ex_0100_bd27cf80","topic":"For long-running operations, yield control periodi","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"def onTickerUpdate(ticker):\n    for i in range(1000):\n        process_chunk(i)\n        if i % 100 == 0:\n            ib.sleep(0)  # Yield every 100 iterations","language":"python","description":"For long-running operations, yield control periodically:"},"stats":{"mentions":1,"sources":["ex_0100_bd27cf80"]}},{"id":"merged_ex_0101_46f5524b","topic":"ibinsync automatically throttles requests to 45 re","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"for contract in large_contract_list:\n    ticker = ib.reqMktData(contract)\n    ib.sleep(0.02)  # Small delay between requests","language":"python","description":"ibinsync automatically throttles requests to 45 requests per second, compatible with TWS/Gateway 974+. No manual intervention needed for individual requests, but spread out batch operations:"},"stats":{"mentions":1,"sources":["ex_0101_46f5524b"]}},{"id":"merged_ex_0102_2681b27b","topic":"Interactive Brokers limits concurrent subscription","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"active_subscriptions = set()\nMAX_SUBSCRIPTIONS = 95  # Leave margin\n\ndef subscribe_with_limit(contract):\n    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:\n        # Unsubscribe oldest\n        oldest = active_subscriptions.pop()\n        ib.cancelMktData(oldest)\n    \n    ticker = ib.reqMktData(contract)\n    active_subscriptions.add(contract)\n    return ticker","language":"python","description":"Interactive Brokers limits concurrent subscriptions: typically 100 for market data lines, only 3 for tick-by-tick data."},"stats":{"mentions":1,"sources":["ex_0102_2681b27b"]}},{"id":"merged_ex_0103_922900ca","topic":"Encapsulate subscription management in a reusable ","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"class TickerManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.contracts = {}\n        \n    def subscribe(self, symbol, exchange='SMART', currency='USD'):\n        contract = Stock(symbol, exchange, currency)\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract)\n        ticker.updateEvent += self.onUpdate\n        \n        self.tickers[symbol] = ticker\n        self.contracts[symbol] = contract\n        return ticker\n    \n    def unsubscribe(self, symbol):\n        if symbol in self.tickers:\n            self.ib.cancelMktData(self.contracts[symbol])\n            del self.tickers[symbol]\n            del self.contracts[symbol]\n    \n    def onUpdate(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n\n# Usage\nmanager = TickerManager(ib)\nmanager.subscribe('AAPL')\nmanager.subscribe('GOOGL')","language":"python","description":"Encapsulate subscription management in a reusable class:"},"stats":{"mentions":1,"sources":["ex_0103_922900ca"]}},{"id":"merged_ex_0104_14f4249a","topic":"Critical: Use the same contract object for cancell","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"# WRONG\ncontract1 = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract1)\n\ncontract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!\nib.cancelMktData(contract2)  # Won't work\n\n# CORRECT\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nib.cancelMktData(contract)  # Use same object","language":"python","description":"Critical: Use the same contract object for cancellation that you used for subscription. Creating a new identical contract won't work\u2014object identity matters."},"stats":{"mentions":1,"sources":["ex_0104_14f4249a"]}},{"id":"merged_ex_0105_d552e908","topic":"Cancel different data types with specific methods:","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ib.cancelMktData(contract)\nib.cancelRealTimeBars(bars)\nib.cancelHistoricalData(bars)\nib.cancelTickByTickData(contract, 'BidAsk')\nib.cancelMktDepth(contract)","language":"python","description":"Cancel different data types with specific methods:"},"stats":{"mentions":1,"sources":["ex_0105_d552e908"]}},{"id":"merged_ex_0106_f97028f9","topic":"Remove event handlers before unsubscribing to prev","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"ticker.updateEvent += handler\n# Later...\nticker.updateEvent -= handler\nib.cancelMktData(contract)","language":"python","description":"Remove event handlers before unsubscribing to prevent memory leaks:"},"stats":{"mentions":1,"sources":["ex_0106_f97028f9"]}},{"id":"merged_ex_0107_7cda9f41","topic":"Proper shutdown procedure:","tier":"a2","confidence":1.0,"tags":["co","ct","er"],"content":{"code":"def shutdown():\n    # Cancel all subscriptions\n    for contract in active_contracts:\n        ib.cancelMktData(contract)\n    \n    # Allow cancellations to process\n    ib.sleep(1)\n    \n    # Disconnect\n    ib.disconnect()\n\ntry:\n    ib.run()\nfinally:\n    shutdown()","language":"python","description":"Proper shutdown procedure:"},"stats":{"mentions":1,"sources":["ex_0107_7cda9f41"]}},{"id":"merged_ex_0108_aa9a9920","topic":"Not processing ticks immediately: The ticker.ticks","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"# WRONG - ticks cleared before checking\nticker = ib.reqMktData(contract)\nib.sleep(5)\nprint(ticker.ticks)  # Likely empty\n\n# CORRECT - process in event\ndef onUpdate(ticker):\n    for tick in ticker.ticks:\n        process_tick(tick)\n\nticker.updateEvent += onUpdate","language":"python","description":"Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update\u2014process ticks in event handlers when they arrive."},"stats":{"mentions":1,"sources":["ex_0108_aa9a9920"]}},{"id":"merged_ex_0109_76fc649a","topic":"Accumulating historical bars: When using keepUpToD","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"def onBarUpdate(bars, hasNewBar):\n    if len(bars) > 1000:\n        # Keep only last 1000 bars\n        del bars[:len(bars)-1000]","language":"python","description":"Accumulating historical bars: When using keepUpToDate=True, limit buffer size to prevent unbounded memory growth."},"stats":{"mentions":1,"sources":["ex_0109_76fc649a"]}},{"id":"merged_ex_0110_385aac72","topic":" Production-ready streaming system","tier":"a2","confidence":1.0,"tags":["co","ct","da","er","vnt"],"content":{"code":"from ib_insync import *\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nclass TradingSystem:\n    def __init__(self):\n        self.ib = IB()\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def connect(self):\n        self.ib.connect('127.0.0.1', 7497, clientId=1)\n        self.ib.errorEvent += self.onError\n        self.ib.pendingTickersEvent += self.onPendingTickers\n        \n    def subscribe(self, symbol):\n        contract = Stock(symbol, 'SMART', 'USD')\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract, '', False, False)\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n    def onPendingTickers(self, tickers):\n        for ticker in tickers:\n            self.process_ticker(ticker)\n            \n    def process_ticker(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n        \n        # Always yield control in callbacks\n        self.ib.sleep(0)\n        \n    def onError(self, reqId, errorCode, errorString, contract):\n        logging.error(f\"Error {errorCode}: {errorString}\")\n        \n    def shutdown(self):\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n        self.ib.sleep(1)\n        self.ib.disconnect()\n        \n    def run(self):\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            print(\"Shutting down...\")\n        finally:\n            self.shutdown()\n\n# Usage\nif __name__ == '__main__':\n    system = TradingSystem()\n    system.connect()\n    system.subscribe('AAPL')\n    system.subscribe('GOOGL')\n    system.run()","language":"python","description":" Production-ready streaming system"},"stats":{"mentions":1,"sources":["ex_0110_385aac72"]}},{"id":"merged_ex_0111_6bf39739","topic":"When working with futures contracts in ibinsync, a","tier":"a2","confidence":1.0,"tags":["co","ct"],"content":{"code":"from ib_insync import *\n\n# Connect to IB\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Correct approach for E-mini S&P 500 futures\nes_contract = Future(symbol='ES', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Micro E-mini Nasdaq-100 futures\nmnq_contract = Future(symbol='MNQ', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Crude Oil futures\ncl_contract = Future(symbol='CL', lastTradeDateOrContractMonth='202506', exchange='NYMEX')\n\n# Qualify the contracts\nqualified_contracts = ib.qualifyContracts(es_contract, mnq_contract, cl_contract)","language":"python","description":"When working with futures contracts in ibinsync, accurate exchange specification is critical. Here's the current correct approach:"},"stats":{"mentions":1,"sources":["ex_0111_6bf39739"]}},{"id":"merged_ex_0112_0d08872d","topic":"For real-time futures trading, always fully qualif","tier":"a2","confidence":1.0,"tags":["ct","er"],"content":{"code":"def get_qualified_futures_contract(ib, symbol, expiry, exchange):\n    \"\"\"Get a fully qualified futures contract ready for trading\"\"\"\n    contract = Future(symbol=symbol, \n                     lastTradeDateOrContractMonth=expiry,\n                     exchange=exchange)\n    \n    # Request complete contract details\n    qualified = ib.qualifyContracts(contract)\n    \n    if not qualified:\n        print(f\"ERROR: Could not qualify {symbol} contract\")\n        return None\n        \n    # Return the fully qualified contract\n    return qualified[0]\n\n# Example usage\nes_contract = get_qualified_futures_contract(ib, 'ES', '202506', 'CME')\nprint(f\"ConId: {es_contract.conId}, LocalSymbol: {es_contract.localSymbol}\")","language":"python","description":"For real-time futures trading, always fully qualify your contracts to ensure proper execution:"},"stats":{"mentions":1,"sources":["ex_0112_0d08872d"]}},{"id":"merged_ex_0113_777eef12","topic":"| Month | Code | Example |\n|-------|------|-------","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"def get_contract_by_symbol(ib, local_symbol):\n    \"\"\"Get contract using local symbol (e.g., 'ESM6')\"\"\"\n    # Parse the local symbol\n    root = ''.join([c for c in local_symbol if c.isalpha()])\n    suffix = ''.join([c for c in local_symbol if not c.isalpha()])\n    \n    # Extract month code and year\n    month_code = suffix[0] if len(suffix) > 0 else ''\n    year_code = suffix[1:] if len(suffix) > 1 else ''\n    \n    # Create generic contract\n    contract = Contract()\n    contract.secType = 'FUT'\n    contract.symbol = root\n    contract.exchange = get_exchange_for_symbol(root)  # Helper function\n    contract.localSymbol = local_symbol\n    \n    # Qualify the contract\n    qualified = ib.qualifyContracts(contract)\n    return qualified[0] if qualified else None\n\ndef get_exchange_for_symbol(symbol):\n    \"\"\"Get correct exchange for common futures symbols\"\"\"\n    exchanges = {\n        'ES': 'CME', 'MES': 'CME', 'NQ': 'CME', 'MNQ': 'CME',\n        'RTY': 'CME', 'M2K': 'CME', 'YM': 'CBOT', 'MYM': 'CBOT',\n        'CL': 'NYMEX', 'GC': 'NYMEX', 'SI': 'NYMEX', 'HG': 'NYMEX',\n        'ZB': 'CBOT', 'ZN': 'CBOT', 'ZF': 'CBOT', 'ZT': 'CBOT',\n        '6E': 'CME', '6A': 'CME', '6B': 'CME', '6J': 'CME'\n    }\n    return exchanges.get(symbol, 'SMART')","language":"python","description":"| Month | Code | Example |\n|-------|------|---------|\n| January | F | ESF6 (ES Jan 2026) |\n| February | G | ESG6 (ES Feb 2026) |\n| March | H | ESH6 (ES Mar 2026) |\n| April | J | ESJ6 (ES Apr 2026) |\n|..."},"stats":{"mentions":1,"sources":["ex_0113_777eef12"]}},{"id":"merged_ex_0114_dcf476f2","topic":"For futures trading, complex order types like OCO ","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Trailing stop for ES futures\ndef place_es_trailing_stop(ib, action, quantity, trail_amount):\n    \"\"\"Place a trailing stop order for ES futures\"\"\"\n    # Get current front month ES contract\n    es = get_front_month_contract(ib, 'ES', 'CME')\n    \n    # Create trailing stop order\n    order = Order()\n    order.action = action  # 'BUY' or 'SELL'\n    order.orderType = 'TRAIL'\n    order.totalQuantity = quantity\n    order.auxPrice = trail_amount  # Trail amount in points\n    \n    # Place the order\n    trade = ib.placeOrder(es, order)\n    return trade\n\n# Market-Limit OCO for MNQ futures\ndef place_mnq_market_limit_oco(ib, action, quantity, limit_price):\n    \"\"\"Place a market-limit OCO order for MNQ futures\"\"\"\n    # Get current front month MNQ contract\n    mnq = get_front_month_contract(ib, 'MNQ', 'CME')\n    \n    # Create OCO orders\n    market_order = MarketOrder(action, quantity)\n    limit_order = LimitOrder(action, quantity, limit_price)\n    \n    # Set up OCO group\n    oca_group = f\"MNQ_OCO_{int(time.time())}\"  # Unique group ID\n    \n    market_order.ocaGroup = oca_group\n    market_order.ocaType = 2  # Proportional\n    \n    limit_order.ocaGroup = oca_group\n    limit_order.ocaType = 2\n    \n    # Place orders\n    trade1 = ib.placeOrder(mnq, market_order)\n    trade2 = ib.placeOrder(mnq, limit_order)\n    \n    return [trade1, trade2]","language":"python","description":"For futures trading, complex order types like OCO and trailing stops require careful setup:"},"stats":{"mentions":1,"sources":["ex_0114_dcf476f2"]}},{"id":"merged_ex_0115_e6c51488","topic":"For live futures data, proper subscription managem","tier":"a2","confidence":1.0,"tags":["ct","da","er"],"content":{"code":"class FuturesDataManager:\n    \"\"\"Manage real-time data for multiple futures contracts\"\"\"\n    \n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def subscribe(self, symbol, exchange='CME'):\n        \"\"\"Subscribe to real-time market data for a futures contract\"\"\"\n        # Get front month contract\n        contract = get_front_month_contract(self.ib, symbol, exchange)\n        \n        if not contract:\n            print(f\"Error: Could not find front month contract for {symbol}\")\n            return None\n            \n        # Request market data\n        ticker = self.ib.reqMktData(contract, '', False, False)\n        \n        # Store references\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n        return ticker\n        \n    def get_price(self, symbol):\n        \"\"\"Get current price for a subscribed symbol\"\"\"\n        if symbol not in self.tickers:\n            return None\n            \n        ticker = self.tickers[symbol]\n        \n        # Use last or midpoint price\n        if ticker.last:\n            return ticker.last\n        elif ticker.bid and ticker.ask:\n            return (ticker.bid + ticker.ask) / 2\n        else:\n            return None\n    \n    def get_contracts_expiring_soon(self, days_threshold=10):\n        \"\"\"Get list of contracts expiring soon\"\"\"\n        expiring_soon = []\n        now = datetime.now()\n        \n        for contract in self.active_contracts:\n            expiry_str = contract.lastTradeDateOrContractMonth\n            \n            if len(expiry_str) == 8:  # YYYYMMDD format\n                expiry = datetime.strptime(expiry_str, '%Y%m%d')\n            else:  # YYYYMM format\n                expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n                \n            days_to_expiry = (expiry - now).days\n            \n            if days_to_expiry <= days_threshold:\n                expiring_soon.append((contract, days_to_expiry))\n                \n        return expiring_soon\n        \n    def cleanup(self):\n        \"\"\"Unsubscribe from all market data\"\"\"\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n            \n        self.tickers.clear()\n        self.active_contracts.clear()","language":"python","description":"For live futures data, proper subscription management is essential:"},"stats":{"mentions":1,"sources":["ex_0115_e6c51488"]}},{"id":"merged_ex_0116_d1d3b777","topic":"For continuous futures analysis, use a combination","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"def get_continuous_futures_data(ib, symbol, exchange, duration='1 Y', bar_size='1 day'):\n    \"\"\"Get historical data for continuous futures contract\"\"\"\n    # Create a ContFuture for historical data\n    contract = ContFuture(symbol, exchange)\n    ib.qualifyContracts(contract)\n    \n    # Request historical data\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=bar_size,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    \n    return bars\n\n# Get front month based on volume/open interest\ndef get_most_liquid_contract(ib, symbol, exchange):\n    \"\"\"Get the most liquid contract based on volume and open interest\"\"\"\n    # Get all active contracts for this symbol\n    contract = Future(symbol, exchange=exchange)\n    details_list = ib.reqContractDetails(contract)\n    \n    if not details_list:\n        return None\n    \n    # Filter out expired contracts\n    now = datetime.now()\n    active_contracts = []\n    \n    for details in details_list:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        \n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n            \n        if expiry > now:\n            active_contracts.append(details.contract)\n    \n    if not active_contracts:\n        return None\n    \n    # Get volume data for each contract\n    contract_data = []\n    \n    for contract in active_contracts:\n        ticker = ib.reqMktData(contract, '100,101', False, False)  # Request volume and OI\n        ib.sleep(1)  # Allow data to populate\n        \n        contract_data.append({\n            'contract': contract,\n            'volume': ticker.volume or 0,\n            'openInterest': ticker.openInterest or 0\n        })\n        \n        # Cancel the market data request\n        ib.cancelMktData(contract)\n    \n    # Sort by combined volume and open interest\n    contract_data.sort(key=lambda x: x['volume'] + x['openInterest'], reverse=True)\n    \n    # Return the most liquid contract\n    return contract_data[0]['contract'] if contract_data else None","language":"python","description":"For continuous futures analysis, use a combination of reqHistoricalData and dynamic front-month tracking:"},"stats":{"mentions":1,"sources":["ex_0116_d1d3b777"]}},{"id":"merged_ex_0117_03a78138","topic":"Here's a more comprehensive structure for a future","tier":"a2","confidence":1.0,"tags":["co","ct","er","vnt","or","prt"],"content":{"code":"class FuturesTradingSystem:\n    \"\"\"Complete futures trading system with proper state management\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        \n        self.active_contracts = {}  # symbol -> contract\n        self.active_orders = {}     # orderId -> order\n        self.active_positions = {}  # symbol -> position\n        \n        # Setup logger\n        self.logger = self._setup_logger()\n        \n    def _setup_logger(self):\n        logger = logging.getLogger('FuturesTradingSystem')\n        logger.setLevel(logging.INFO)\n        \n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        \n        return logger\n        \n    def connect(self):\n        \"\"\"Connect to IB and initialize state\"\"\"\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(f\"Connected to IB ({self.host}:{self.port})\")\n            \n            # Setup event handlers\n            self.ib.errorEvent += self._handle_error\n            self.ib.positionEvent += self._handle_position\n            self.ib.orderStatusEvent += self._handle_order_status\n            \n            # Initialize positions\n            self._update_positions()\n            \n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _update_positions(self):\n        \"\"\"Update current positions\"\"\"\n        positions = self.ib.positions()\n        \n        for position in positions:\n            if position.contract.secType == 'FUT':\n                symbol = position.contract.symbol\n                self.active_positions[symbol] = position\n                self.logger.info(f\"Current position: {symbol}: {position.position}\")\n    \n    def _handle_position(self, position):\n        \"\"\"Handle position updates\"\"\"\n        if position.contract.secType == 'FUT':\n            symbol = position.contract.symbol\n            self.active_positions[symbol] = position\n            self.logger.info(f\"Position update: {symbol}: {position.position}\")\n    \n    def _handle_order_status(self, trade):\n        \"\"\"Handle order status updates\"\"\"\n        orderId = trade.order.orderId\n        status = trade.orderStatus.status\n        \n        self.logger.info(f\"Order {orderId} status: {status}\")\n        \n        # Store active orders\n        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:\n            self.active_orders[orderId] = trade\n        # Remove completed orders\n        elif status in ['Filled', 'Cancelled', 'Inactive']:\n            if orderId in self.active_orders:\n                del self.active_orders[orderId]\n    \n    def _handle_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle error events\"\"\"\n        self.logger.error(f\"Error {errorCode}: {errorString}\")\n        \n        # Handle connection issues\n        if errorCode in [1100, 1101, 1102]:\n            self.logger.critical(\"Connection issue detected!\")\n    \n    def get_contract(self, symbol, expiry, exchange):\n        \"\"\"Get a fully qualified futures contract\"\"\"\n        contract_key = f\"{symbol}_{expiry}_{exchange}\"\n        \n        # Use cached contract if available\n        if contract_key in self.active_contracts:\n            return self.active_contracts[contract_key]\n            \n        # Otherwise qualify a new one\n        contract = Future(symbol=symbol, \n                         lastTradeDateOrContractMonth=expiry,\n                         exchange=exchange)\n        \n        qualified = self.ib.qualifyContracts(contract)\n        \n        if not qualified:\n            self.logger.error(f\"Failed to qualify contract: {symbol} {expiry}\")\n            return None\n            \n        qualified_contract = qualified[0]\n        self.active_contracts[contract_key] = qualified_contract\n        \n        return qualified_contract\n    \n    def place_market_order(self, symbol, expiry, exchange, action, quantity):\n        \"\"\"Place market order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = MarketOrder(action, quantity)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} market order for {quantity} {symbol}\")\n        return trade\n    \n    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):\n        \"\"\"Place limit order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = LimitOrder(action, quantity, price)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} limit order for {quantity} {symbol} @ {price}\")\n        return trade\n    \n    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, \n                          entry_price, profit_price, stop_price):\n        \"\"\"Place bracket order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        # Create bracket orders\n        bracket = self.ib.bracketOrder(\n            action,\n            quantity,\n            entry_price,\n            profit_price,\n            stop_price\n        )\n        \n        # Place all orders\n        trades = []\n        for order in bracket:\n            trade = self.ib.placeOrder(contract, order)\n            trades.append(trade)\n        \n        self.logger.info(f\"Placed bracket order for {quantity} {symbol}\")\n        return trades\n    \n    def cancel_all_orders(self):\n        \"\"\"Cancel all open orders\"\"\"\n        open_trades = self.ib.openTrades()\n        for trade in open_trades:\n            if not trade.isDone():\n                self.ib.cancelOrder(trade.order)\n                self.logger.info(f\"Cancelled order {trade.order.orderId}\")\n    \n    def get_position(self, symbol):\n        \"\"\"Get current position for symbol\"\"\"\n        return self.active_positions.get(symbol)\n    \n    def close_position(self, symbol):\n        \"\"\"Close position for symbol\"\"\"\n        position = self.get_position(symbol)\n        \n        if not position or position.position == 0:\n            self.logger.info(f\"No position to close for {symbol}\")\n            return None\n        \n        # Create closing order\n        action = 'SELL' if position.position > 0 else 'BUY'\n        quantity = abs(position.position)\n        \n        return self.place_market_order(\n            symbol,\n            position.contract.lastTradeDateOrContractMonth,\n            position.contract.exchange,\n            action,\n            quantity\n        )\n    \n    def run(self):\n        \"\"\"Run the system indefinitely\"\"\"\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            self.logger.info(\"Shutting down...\")\n        finally:\n            # Cleanup on exit\n            self.cancel_all_orders()\n            self.ib.disconnect()\n            self.logger.info(\"Disconnected from IB\")","language":"python","description":"Here's a more comprehensive structure for a futures trading system:"},"stats":{"mentions":1,"sources":["ex_0117_03a78138"]}},{"id":"merged_ex_0118_9050e9e9","topic":" Code Examples\n- Fetching consecutive historical d","tier":"a2","confidence":1.0,"tags":["as","co","ct","da","or"],"content":{"code":"pip install ib_insync\n\n\nfrom ib_insync import *\n# util.startLoop() # uncomment this line when in a notebook\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\ncontract, endDateTime='', durationStr='30 D',\nbarSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)\n\n# convert to pandas dataframe:\ndf = util.df(bars)\nprint(df)","language":"python","description":" Code Examples\n- Fetching consecutive historical data\n- Async streaming ticks\n- Scanner data (blocking)\n- Scanner data (streaming)\n- Option calculations\n- Order book\n- Minimum price increments\n- News ..."},"stats":{"mentions":1,"sources":["ex_0118_9050e9e9"]}},{"id":"merged_ex_0119_672d75df","topic":"Note: It is not advisable to place new requests in","tier":"a2","confidence":1.0,"tags":["as","co","ct","da","er","vnt","or","prt"],"content":{"code":"events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',\n          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',\n          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',\n          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',\n          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',\n          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',\n          'timeoutEvent')\n\nRequestTimeout: float = 0\nRaiseRequestErrors: bool = False\nMaxSyncedSubAccounts: int = 50\nTimezoneTWS = None\n\n#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\nConnect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.\n**This method is blocking.**\n**Parameters:**\n- **host** (str) - Host name or IP address.\n- **port** (int) - Port number.\n- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.\n- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n- **readonly** (bool) - Set to True when API is in read-only mode.\n- **account** (str) - Main account to receive updates for.\n- \n#### disconnect()\nDisconnect from a TWS or IB gateway application. This will clear all session state.\n\n#### isConnected()\nIs there an API connection to TWS or IB gateway?\n**Return type:** bool\n\n#### static run(*, timeout=None)\nBy default run the event loop forever.\nWhen awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.\nAn optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.\n\n#### static schedule(callback, *args)\nSchedule the callback to be run at the given time with the given arguments. This will return the Event Handle.\n**Parameters:**\n- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.\n- **callback** (Callable) - Callable scheduled to run.\n- **args** - Arguments for to call callback with.\n\n#### static sleep()\nWait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.\n**Parameters:**\n- **secs** (float) - Time in seconds to wait.\n**Return type:** bool\n\n#### static timeRange(end, step)\nIterator that waits periodically until certain time points are reached while yielding those time points.\n**Parameters:**\n- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **step** (float) - The number of seconds of each period\n**Return type:** Iterator[datetime]\n\n#### static timeRangeAsync(end, step)\nAsync version of timeRange().\n**Return type:** AsyncIterator[datetime]\n\n#### static waitUntil()\nWait until the given time t is reached.\n**Parameters:**\n- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.\n**Return type:** bool\n\n#### waitOnUpdate(timeout=0)\nWait on any new update to arrive from the network.\n**Parameters:**\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used\n**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.\n**Return type:** bool\n**Returns:** True if not timed-out, False otherwise.\n\n#### loopUntil(condition=None, timeout=0)\nIterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.\n**Parameters:**\n- **condition** - Predicate function that is tested after every network update.\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.\n**Return type:** Iterator[object]\n\n#### setTimeout(timeout=60)\nSet a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.\nThe timeout fires once per connected session but can be set again after firing or after a reconnect.\n**Parameters:**\n- **timeout** (float) - Timeout in seconds.\n\n#### managedAccounts()\nList of account names.\n**Return type:** List[str]\n\n#### accountValues(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### accountSummary(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**This method is blocking on first run, non-blocking after that.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### portfolio()\nList of portfolio items of the default account.\n**Return type:** List[PortfolioItem]\n\n#### positions(account='')\nList of positions for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[Position]\n\n#### pnl(account='', modelCode='')\nList of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.\n**Parameters:**\n- **account** - If specified, filter for this account name.\n- **modelCode** - If specified, filter for this account model.\n**Return type:** List[PnL]\n\n#### pnlSingle(account='', modelCode='', conId=0)\nList of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n- **conId** (int) - If specified, filter for this contract ID.\n**Return type:** List[PnLSingle]\n\n#### trades()\nList of all order trades from this session.\n**Return type:** List[Trade]\n\n#### openTrades()\nList of all open order trades.\n**Return type:** List[Trade]\n\n#### orders()\nList of all orders from this session.\n**Return type:** List[Order]\n\n#### openOrders()\nList of all open orders.\n**Return type:** List[Order]\n\n#### fills()\nList of all fills from this session.\n**Return type:** List[Fill]\n\n#### executions()\nList of all executions from this session.\n**Return type:** List[Execution]\n\n#### ticker(contract)\nGet ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().\n**Parameters:**\n- **contract** (Contract) - Contract to get ticker for.\n**Return type:** Ticker\n\n#### tickers()\nGet a list of all tickers.\n**Return type:** List[Ticker]\n\n#### pendingTickers()\nGet a list of all tickers that have pending ticks or domTicks.\n**Return type:** List[Ticker]\n\n#### realtimeBars()\nGet a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.\n**Return type:** List[Union[BarDataList, RealTimeBarList]]\n\n#### newsTicks()\nList of ticks with headline news. The article itself can be retrieved with reqNewsArticle().\n**Return type:** List[NewsTick]\n\n#### newsBulletins()\nList of IB news bulletins.\n**Return type:** List[NewsBulletin]\n\n#### reqTickers(*contracts, regulatorySnapshot=False)\nRequest and return a list of snapshot tickers. The list is returned when all tickers are ready.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to get tickers for.\n- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).\n**Return type:** List[Ticker]\n\n#### qualifyContracts(*contracts)\nFully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to qualify.\n**Return type:** List[Contract]\n\n#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)\nCreate a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:\n\nfor o in bracket:\n    ib.placeOrder(contract, o)\n**Parameters:**\n- **action** (str) - 'BUY' or 'SELL'.\n- **quantity** (float) - Size of order.\n- **limitPrice** (float) - Limit price of entry order.\n- **takeProfitPrice** (float) - Limit price of profit order.\n- **stopLossPrice** (float) - Stop price of loss order.\n**Return type:** BracketOrder\n\n#### static oneCancelsAll(orders, ocaGroup, ocaType)\nPlace the trades in the same One Cancels All (OCA) group.\nhttps://interactivebrokers.github.io/tws-api/oca.html\n**Parameters:**\n- **orders** (List[Order]) - The orders that are to be placed together.\n**Return type:** List[Order]\n\n#### whatIfOrder(contract, order)\nRetrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.\n**This method is blocking.**\n**Parameters:**\n- **contract** (Contract) - Contract to test.\n- **order** (Order) - Order to test.\n**Return type:** OrderState\n\n#### placeOrder(contract, order)\nPlace a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.\n**Parameters:**\n- **contract** (Contract) - Contract to use for order.\n- **order** (Order) - The order to be placed.\n**Return type:** Trade\n\n#### cancelOrder(order, manualCancelOrderTime='')\nCancel the order and return the Trade it belongs to.\n**Parameters:**\n- **order** (Order) - The order to be canceled.\n- **manualCancelOrderTime** (str) - For audit trail.\n**Return type:** Trade\n\n#### reqGlobalCancel()\nCancel all active trades including those placed by other clients or TWS/IB gateway.\n\n#### reqCurrentTime()\nRequest TWS current time.\n**This method is blocking.**\n**Return type:** datetime\n\n#### reqAccountUpdates(account='')\nThis is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n\n#### reqAccountUpdatesMulti(account='', modelCode='')\nIt is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n\n#### reqAccountSummary()\nIt is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.\n**This method is blocking.**\n\n#### reqAutoOpenOrders(autoBind=True)\nBind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting \"Use negative numbers to bind automatic orders\" must be checked. This request is automatically called when clientId=0.\nhttps://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html\n\n**Parameters:**\n- **autoBind** (bool) - Set binding on or off.\n\n#### reqOpenOrders()\nRequest and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.\n**This method is blocking.**\n**Return type:** List[Order]\n\n#### reqAllOpenOrders()\nRequest and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.\n**Return type:** List[Order]\n\n#### reqCompletedOrders(apiOnly)\nRequest and return a list of completed trades.\n**Parameters:**\n- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).\n**Return type:** List[Trade]\n\n#### reqExecutions(execFilter=None)\nIt is recommended to use fills() or executions() instead. Request and return a list of fills.\n**This method is blocking.**\n**Parameters:**\n- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.\n**Return type:** List[Fill]\n\n#### reqPositions()\nIt is recommended to use positions() instead. Request and return a list of positions for all accounts.\n**This method is blocking.**\n**Return type:** List[Position]\n\n#### reqPnL(account, modelCode='')\nStart a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - If specified, filter for this account model.\n**Return type:** PnL\n\n#### cancelPnL(account, modelCode='')\nCancel PnL subscription.\n**Parameters:**\n- **account** - Cancel for this account.\n- **modelCode** (str) - If specified, cancel for this account model.\n\n#### reqPnLSingle(account, modelCode, conId)\nStart a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - Filter for this account model.\n- **conId** (int) - Filter for this contract ID.\n**Return type:** PnLSingle\n\n#### cancelPnLSingle(account, modelCode, conId)\nCancel PnLSingle subscription for the given account, modelCode and conId.\n**Parameters:**\n- **account** (str) - Cancel for this account name.\n- **modelCode** (str) - Cancel for this account model.\n- **conId** (int) - Cancel for this contract ID.\n\n#### reqContractDetails(contract)\nGet a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/contract_details.html\n**Parameters:**\n- **contract** (Contract) - The contract to get details for.\n**Return type:** List[ContractDetails]\n\n#### reqMatchingSymbols(pattern)\nRequest contract descriptions of contracts that match a pattern.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/matching_symbols.html\n**Parameters:**\npattern (str) -The first few letters of the ticker symbol, or for longer strings a character\nsequence matching a word in the security name.\nReturn type\nList[ContractDescription]\n\n#### reqMarketRule(marketRuleId)\nRequest price increments rule.\nhttps://interactivebrokers.github.io/tws-api/minimum_increment.html\nParameters\nmarketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-\ntained via reqContractDetails() from ContractDetails.marketRuleIds, which con-\ntains a comma separated string of market rule IDs.\nReturn type\nPriceIncrement\n\n#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])\nRequest realtime 5 second bars.\nhttps://interactivebrokers.github.io/tws-api/realtime_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-barSize (int) -Must be 5.\n-whatToShow (str) -Specifies the source for constructing bars. Can be \u2018TRADES\u2019, \u2018MID-\nPOINT\u2019, \u2018BID\u2019 or \u2018ASK\u2019.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-realTimeBarsOptions (List[TagValue]) -Unknown.\nReturn type\nRealTimeBarList\n\n#### cancelRealTimeBars(bars)\nCancel the realtime bars subscription.\nParameters\nbars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.\n\n#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)\nRequest historical bar data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-durationStr (str) -Time span of all the bars. Examples: \u201860 S\u2019, \u201830 D\u2019, \u201813 W\u2019, \u20186 M\u2019,\n\u201810 Y\u2019.\n-barSizeSetting (str) -Time period of one bar. Must be one of: \u20181 secs\u2019, \u20185 secs\u2019, \u201810\nsecs\u2019 15 secs\u2019, \u201830 secs\u2019, \u20181 min\u2019, \u20182 mins\u2019, \u20183 mins\u2019, \u20185 mins\u2019, \u201810 mins\u2019, \u201815 mins\u2019, \u201820\nmins\u2019, \u201830 mins\u2019, \u20181 hour\u2019, \u20182 hours\u2019, \u20183 hours\u2019, \u20184 hours\u2019, \u20188 hours\u2019, \u20181 day\u2019, \u20181 week\u2019, \u20181\nmonth\u2019.\n-whatToShow (str) -Specifies the source for constructing bars. Must be one\nof: \u2018TRADES\u2019, \u2018MIDPOINT\u2019, \u2018BID\u2019, \u2018ASK\u2019, \u2018BID_ASK\u2019, \u2018ADJUSTED_LAST\u2019, \u2018HIS-\nTORICAL_VOLATILITY\u2019, \u2018OPTION_IMPLIED_VOLATILITY\u2019, \u2018REBATE_RATE\u2019,\n\u2018FEE_RATE\u2019, \u2018YIELD_BID\u2019, \u2018YIELD_ASK\u2019, \u2018YIELD_BID_ASK\u2019, \u2018YIELD_LAST\u2019. For\n\u2018SCHEDULE\u2019 use reqHistoricalSchedule().\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields\nto be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as\nused by TWS.\n-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars\nupdated; endDateTime must be set empty (\u2018\u2019) then.\n-chartOptions (List[TagValue]) -Unknown.\n-timeout (float) -Timeout in seconds after which to cancel the request and return an\nempty bar series. Set to 0 to wait indefinitely.\nReturn type\nBarDataList\n\n#### cancelHistoricalData(bars)\nCancel the update subscription for the historical bars.\nParameters\nbars (BarDataList) -The bar list that was obtained from reqHistoricalData with a\nkeepUpToDate subscription.\n\n\n#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)\nRequest historical schedule.\nThis method is blocking.\nParameters\n-contract (Contract) -Contract of interest.\n-numDays (int) -Number of days.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for\nextended hours.\nReturn type\nHistoricalSchedule\n\n#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nRequest historical ticks. The time resolution of the ticks is one second.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_time_and_sales.html\nParameters\n-contract (Contract) -Contract to query.\n-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-\ntime.datetime, or it can be given as a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no\ntimezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be\ngiven, the other must be blank.\n-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can\ncontain a bit more to accommodate all ticks in the latest second.\n-whatToShow (str) -One of \u2018Bid_Ask\u2019, \u2018Midpoint\u2019 or \u2018Trades\u2019.\n-useRTH -If True then only show data from within Regular Trading Hours, if False then\nshow all data.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\n-miscOptions (List[TagValue]) -Unknown.\nReturn type\nList\n\n#### reqMarketDataType(marketDataType)\nSet the market data type used for reqMktData().\nParameters\nmarketDataType (int) -One of:\n-1 = Live\n-2 = Frozen\n-3 = Delayed\n-4 = Delayed frozen\nhttps://interactivebrokers.github.io/tws-api/market_data_type.html\nreqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)\nGet the datetime of earliest available historical data for the contract.\nParameters\n-contract (Contract) -Contract of interest.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-\ntime.datetime with UTC timezone.\nReturn type\ndatetime\n\n#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,\nmktDataOptions=None)\nSubscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will\ninitially be empty and gradually (after a couple of seconds) be filled.\nhttps://interactivebrokers.github.io/tws-api/md_request.html\nParameters\n-contract (Contract) -Contract of interest.\n-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause\ncorresponding Ticker fields to be filled:\n\nID  Ticker fields\n100 putVolume, callVolume (for options)\n101 putOpenInterest, callOpenInterest (for options)\n104 histVolatility (for options)\n105 avOptionVolume (for options)\n106 impliedVolatility (for options)\n162 indexFuturePremium\n165 low13week, high13week, low26week, high26week, low52week,\nhigh52week, avVolume\n221 markPrice\n225 auctionVolume, auctionPrice, auctionImbalance\n233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 shortableShares\n258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)\n293 tradeCount\n294 tradeRate\n295 volumeRate\n375 rtTradeVolume\n411 rtHistVolatility\n456 dividends (of type ib_insync.objects.Dividends)\n588 futuresOpenInterest\n\n-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a\nstream of realtime tick data.\n-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).\n-mktDataOptions (Optional[List[TagValue]]) -Unknown\nReturn type\nTicker\n\n#### cancelMktData(contract)\nUnsubscribe from realtime streaming tick data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\nreqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)\nSubscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.\nhttps://interactivebrokers.github.io/tws-api/tick_data.html\nParameters\n-contract (Contract) -Contract of interest.\n-tickType (str) -One of \u2018Last\u2019, \u2018AllLast\u2019, \u2018BidAsk\u2019 or \u2018MidPoint\u2019.\n-numberOfTicks (int) -Number of ticks or 0 for unlimited.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\nReturn type\nTicker\n\n#### cancelTickByTickData(contract, tickType)\nUnsubscribe from tick-by-tick data\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqSmartComponents(bboExchange)\nObtain mapping from single letter codes to exchange names.\nNote: The exchanges must be open when using this request, otherwise an empty list is returned.\nReturn type\nList[SmartComponent]\n\n#### reqMktDepthExchanges()\nGet those exchanges that have have multiple market makers (and have ticks returned with marketMaker\ninfo).\nReturn type\nList[DepthMktDataDescription]\n\n#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)\nSubscribe to market depth data (a.k.a. DOM, L2 or order book).\nhttps://interactivebrokers.github.io/tws-api/market_depth.html\nParameters\n-contract (Contract) -Contract of interest.\n-numRows (int) -Number of depth level on each side of the order book (5 max).\n-isSmartDepth (bool) -Consolidate the order book across exchanges.\n-mktDepthOptions -Unknown.\nReturn type\nTicker\nReturns\nThe Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the\nlist of MktDepthData in ticker.domTicks.\n\n#### cancelMktDepth(contract, isSmartDepth=False)\nUnsubscribe from market depth data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqHistogramData(contract, useRTH, period)\nRequest histogram data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/histograms.html\nParameters\n-contract (Contract) -Contract to query.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-period (str) -Period of which data is being requested, for example \u20183 days\u2019.\nReturn type\nList[HistogramData]\n\n#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])\nGet fundamental data of a contract in XML format.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/fundamentals.html\nParameters\n-contract (Contract) -Contract to query.\n-reportType (str) \u2013\n\u2013 \u2018ReportsFinSummary\u2019: Financial summary\n\u2013 \u2019ReportsOwnership\u2019: Company\u2019s ownership\n\u2013 \u2019ReportSnapshot\u2019: Company\u2019s financial overview\n\u2013 \u2019ReportsFinStatements\u2019: Financial Statements\n\u2013 \u2019RESC\u2019: Analyst Estimates\n\u2013 \u2019CalendarReport\u2019: Company\u2019s calendar\n-fundamentalDataOptions (List[TagValue]) -Unknown\nReturn type\nstr\n\n#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])\nDo a blocking market scan by starting a subscription and canceling it after the initial list of results are in.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -Basic filters.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.\nReturn type\nScanDataList\n\n#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nSubscribe to market scan data.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -What to scan for.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.\nReturn type\nScanDataList\n\n#### cancelScannerSubscription(dataList)\nCancel market data subscription.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\ndataList (ScanDataList) -The scan data list that was obtained from\nreqScannerSubscription().\n\n#### reqScannerParameters()\nRequests an XML list of scanner parameters.\nThis method is blocking.\nReturn type\nstr\n\n#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])\nCalculate the volatility given the option price.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-optionPrice (float) -Option price to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions (List[TagValue]) -Unknown\nReturn type\nOptionComputation\n\n#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])\nCalculate the option price given the volatility.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-volatility (float) -Option volatility to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions -Unknown\nReturn type\nOptionComputation\n\n#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nGet the option chain.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-underlyingSymbol (str) -Symbol of underlier contract.\n-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).\n-underlyingSecType (str) -The type of the underlying security, like \u2018STK\u2019 or \u2018FUT\u2019.\n-underlyingConId (int) -conId of the underlying contract.\nReturn type\nList[OptionChain]\n\n#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)\nExercise an options contract.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-contract (Contract) -The option contract to be exercised.\n-exerciseAction (int) \u2013\n\u2013 1 = exercise the option\n\u2013 2 = let the option lapse\n-exerciseQuantity (int) -Number of contracts to be exercised.\n-account (str) -Destination account.\n-override (int) \u2013\n\u2013 0 = no override\n\u2013 1 = override the system\u2019s natural action\n\n#### reqNewsProviders()\nGet a list of news providers.\nThis method is blocking.\nReturn type\nList[NewsProvider]\n\n#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)\nGet the body of a news article.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\n-providerCode (str) -Code indicating news provider, like \u2018BZ\u2019 or \u2018FLY\u2019.\n-articleId (str) -ID of the specific article.\n-newsArticleOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nNewsArticle\n\n#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nGet historical news headline.\nhttps://interactivebrokers.github.io/tws-api/news.html\nThis method is blocking.\nParameters\n-conId (int) -Search news articles for contract with this conId.\n-providerCodes (str) -A \u2018+\u2019-separated list of provider codes, like \u2018BZ+FLY\u2019.\n-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be\ngiven as a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given\nas a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-totalResults (int) -Maximum number of headlines to fetch (300 max).\n-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nHistoricalNews\n\n#### reqNewsBulletins(allMessages)\nSubscribe to IB news bulletins.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\nallMessages (bool) -If True then fetch all messages for the day.\n\n#### cancelNewsBulletins()\nCancel subscription to IB news bulletins.\n\n#### requestFA(faDataType)\nRequests to change the FA configuration.\nThis method is blocking.\nParameters\nfaDataType (int) \u2013\n-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation\nmethod to all accounts in the group.\n-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined\ncalculation value.\n-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than\naccount numbers.\n\n#### replaceFA(faDataType, xml)\nReplaces Financial Advisor\u2019s settings.\nParameters\n-faDataType (int) -See requestFA().\n-xml (str) -The XML-formatted configuration string.\n\n#### reqUserInfo()\nGet the White Branding ID of the user.\nReturn type\nstr\n\n#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\n\n#### async qualifyContractsAsync(*contracts)\nReturn type\nList[Contract]\n\n#### async reqTickersAsync(*contracts, regulatorySnapshot=False)\nReturn type\nList[Ticker]\n\n#### whatIfOrderAsync(contract, order)\nReturn type\nAwaitable[OrderState]\n\n#### reqCurrentTimeAsync()\nReturn type\nAwaitable[datetime]\n\n#### reqAccountUpdatesAsync(account)\nReturn type\nAwaitable[None]\n\n#### reqAccountUpdatesMultiAsync(account, modelCode='')\nReturn type\nAwaitable[None]\n\n#### async accountSummaryAsync(account='')\nReturn type\nList[AccountValue]\n\n#### reqAccountSummaryAsync()\nReturn type\nAwaitable[None]\n\n#### reqOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqAllOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqCompletedOrdersAsync(apiOnly)\nReturn type\nAwaitable[List[Trade]]\n\n#### reqExecutionsAsync(execFilter=None)\nReturn type\nAwaitable[List[Fill]]\n\n#### reqPositionsAsync()\nReturn type\nAwaitable[List[Position]]\n\n#### reqContractDetailsAsync(contract)\nReturn type\nAwaitable[List[ContractDetails]]\n\n#### async reqMatchingSymbolsAsync(pattern)\nReturn type\nOptional[List[ContractDescription]]\n\n#### async reqMarketRuleAsync(marketRuleId)\nReturn type\nOptional[List[PriceIncrement]]\n\n#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,\nuseRTH, formatDate=1, keepUpToDate=False, chartOptions=[],\ntimeout=60)\nReturn type\nBarDataList\n\n#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)\nReturn type\nAwaitable[HistoricalSchedule]\n\n#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nReturn type\nAwaitable[List]\n\n#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)\nReturn type\nAwaitable[datetime]\n\n#### reqSmartComponentsAsync(bboExchange)\n\n#### reqMktDepthExchangesAsync()\nReturn type\nAwaitable[List[DepthMktDataDescription]]\n\n#### reqHistogramDataAsync(contract, useRTH, period)\nReturn type\nAwaitable[List[HistogramData]]\n\n#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])\nReturn type\nAwaitable[str]\n\n#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nReturn type\nScanDataList\n\n#### reqScannerParametersAsync()\nReturn type\nAwaitable[str]\n\n#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nReturn type\nAwaitable[List[OptionChain]]\n\n#### reqNewsProvidersAsync()\nReturn type\nAwaitable[List[NewsProvider]]\n\n#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)\nReturn type\nAwaitable[NewsArticle\n\n#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nReturn type\nOptional[HistoricalNews]\n\n#### async requestFAAsync(faDataType)\nreqUserInfoAsync()","language":"python","description":"Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion."},"stats":{"mentions":1,"sources":["ex_0119_672d75df"]}},{"id":"merged_ex_0120_61a75e07","topic":"\nClient","tier":"a2","confidence":1.0,"tags":["as","co","ct","da","er","vnt","or","prt"],"content":{"code":"Socket client for communicating with Interactive Brokers.\n\n#### class ib_insync.client.Client(wrapper)\nReplacement for ibapi.client.EClient that uses asyncio.\nThe client is fully asynchronous and has its own event-driven networking code that replaces the networking code\nof the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can\nbe used as a drop-in replacement for the standard EClient as provided by IBAPI.\nCompared to the standard EClient this client has the following additional features:\n-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for\nnextValidId to start requests as the client has already done that. The reqId is directly available with\ngetReqId().\n-client.connectAsync() is a coroutine for connecting asynchronously.\n-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-\nonds).\n-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size\ninstead of the two wrapper methods priceTick and sizeTick.\n-Automatic request throttling.\n-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after\na network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.\n-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the\nnetwork packet\u2019s data has been handled. A possible use is to write or evaluate the newly arrived data in one\nbatch instead of item by item.\nParameters\n-MaxRequests (int) -Throttle the number of requests to MaxRequests per\nRequestsInterval seconds. Set to 0 to disable throttling.\n-RequestsInterval (float) -Time interval (in seconds) for request throttling.\n-MinClientVersion (int) -Client protocol version.\n-MaxClientVersion (int) -Client protocol version\n\nEvents:\n-apiStart ()\n-apiEnd ()\n-apiError (errorMsg: str)\n-throttleStart ()\n-throttleEnd ()\nevents = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')\nMaxRequests = 45\nRequestsInterval = 1\nMinClientVersion = 157\nMaxClientVersion = 176\nDISCONNECTED = 0\nCONNECTING = 1\nCONNECTED = 2\nreset()\nserverVersion()\nReturn type\nint\nrun()\nisConnected()\nisReady()\nIs the API connection up and running?\nReturn type\nbool\nconnectionStats()\nGet statistics about the connection.\nReturn type\nConnectionStats\ngetReqId()\nGet new request ID.\nReturn type\nint\nupdateReqId(minReqId)\nUpdate the next reqId to be at least minReqId.\ngetAccounts()\nGet the list of account names that are under management.\nReturn type\nList[str]\n\nsetConnectOptions(connectOptions)\nSet additional connect options.\nParameters\nconnectOptions (str) -Use \u201c+PACEAPI\u201d to use request-pacing built into TWS/gateway\n974+.\n\nconnect(host, port, clientId, timeout=2.0)\nConnect to a running TWS or IB gateway application.\nParameters\n-host (str) -Host name or IP address.\n-port (int) -Port number.\n-clientId (int) -ID number to use for this client; must be unique per connection.\n-timeout (Optional[float]) -If establishing the connection takes longer than timeout\nseconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n\nasync connectAsync(host, port, clientId, timeout=2.0)\n\ndisconnect()\nDisconnect from IB connection.\n\nsend(*fields)\nSerialize and send the given fields using the IB socket protocol.\n\nsendMsg(msg)\n\nreqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)\n\ncancelMktData(reqId)\n\nplaceOrder(orderId, contract, order)\n\ncancelOrder(orderId, manualCancelOrderTime='')\n\nreqOpenOrders()\n\nreqAccountUpdates(subscribe, acctCode)\n\nreqExecutions(reqId, execFilter)\n\nreqIds(numIds)\n\nreqContractDetails(reqId, contract)\n\nreqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)\n\ncancelMktDepth(reqId, isSmartDepth)\n\nreqNewsBulletins(allMsgs)\n\ncancelNewsBulletins()\n\nsetServerLogLevel(logLevel)\n\nreqAutoOpenOrders(bAutoBind)\n\nreqAllOpenOrders()\n\nreqManagedAccts()\n\nrequestFA(faData)\n\nreplaceFA(reqId, faData, cxml)\n\nreqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate, keepUpToDate, chartOptions)\n\nexerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)\n\nreqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,\nscannerSubscriptionFilterOptions)\n\ncancelScannerSubscription(reqId)\n\nreqScannerParameters()\n\ncancelHistoricalData(reqId)\n\nreqCurrentTime()\n\nreqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)\n\ncancelRealTimeBars(reqId)\n\nreqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)\n\ncancelFundamentalData(reqId)\n\ncalculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)\n\ncalculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)\n\ncancelCalculateImpliedVolatility(reqId)\n\ncancelCalculateOptionPrice(reqId)\n\nreqGlobalCancel()\n\nreqMarketDataType(marketDataType)\n\nreqPositions()\n\nreqAccountSummary(reqId, groupName, tags)\n\ncancelAccountSummary(reqId)\n\ncancelPositions()\n\nverifyRequest(apiName, apiVersion)\n\nverifyMessage(apiData)\n\nqueryDisplayGroups(reqId)\n\nsubscribeToGroupEvents(reqId, groupId)\n\nupdateDisplayGroup(reqId, contractInfo)\n\nunsubscribeFromGroupEvents(reqId)\n\nstartApi()\n\nverifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)\n\nverifyAndAuthMessage(apiData, xyzResponse)\n\nreqPositionsMulti(reqId, account, modelCode)\n\ncancelPositionsMulti(reqId)\n\nreqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )\n\ncancelAccountUpdatesMulti(reqId)\n\nreqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\n\nreqSoftDollarTiers(reqId)\n\nreqFamilyCodes()\n\nreqMatchingSymbols(reqId, pattern)\n\nreqMktDepthExchanges()\n\nreqSmartComponents(reqId, bboExchange)\n\nreqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)\n\nreqNewsProviders()\n\nreqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions)\n\nreqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)\n\nreqHistogramData(tickerId, contract, useRTH, timePeriod)\n\ncancelHistogramData(tickerId)\n\ncancelHeadTimeStamp(reqId)\n\nreqMarketRule(marketRuleId)\n\nreqPnL(reqId, account, modelCode)\n\ncancelPnL(reqId)\n\nreqPnLSingle(reqId, account, modelCode, conid)\n\ncancelPnLSingle(reqId)\n\nreqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize, miscOptions)\n\nreqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)\n\ncancelTickByTickData(reqId)\n\nreqCompletedOrders(apiOnly)\n\nreqWshMetaData(reqId)\n\ncancelWshMetaData(reqId)\n\nreqWshEventData(reqId, data)\n\ncancelWshEventData(reqId)\n\nreqUserInfo(reqId)","language":"python","description":"\nClient"},"stats":{"mentions":1,"sources":["ex_0120_61a75e07"]}},{"id":"merged_ex_0121_fda0b06a","topic":"\nOrder","tier":"a2","confidence":1.0,"tags":["ct","er","vnt","or"],"content":{"code":"#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',\ntotalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =\n1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:\nstr = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',\nocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,\nblockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,\ntriggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,\ngoodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:\nbool = False, minQty: int = 2147483647, percentOffset: float =\n1.7976931348623157e+308, overridePercentageConstraints: bool = False,\ntrailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =\n1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str\n= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',\norigin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:\nfloat = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,\nnbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool\n= False, auctionStrategy: int = 0, startingPrice: float =\n1.7976931348623157e+308, stockRefPrice: float =\n1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,\nstockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float\n= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:\nbool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int\n= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =\n1.7976931348623157e+308, deltaNeutralConId: int = 0,\ndeltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',\ndeltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',\ndeltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,\ndeltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,\nreferencePriceType: int = 2147483647, basisPoints: float =\n1.7976931348623157e+308, basisPointsType: int = 2147483647,\nscaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,\nscalePriceIncrement: float = 1.7976931348623157e+308,\nscalePriceAdjustValue: float = 1.7976931348623157e+308,\nscalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =\n1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:\nint = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:\nbool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',\naccount: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:\nstr = '', algoStrategy: str = '', algoParams:\n~typing.List[~ib_insync.contract.TagValue] = <factory>,\nsmartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =\n<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,\nsolicited: bool = False, modelCode: str = '', orderComboLegs:\n~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,\norderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,\nreferenceContractId: int = 0, peggedChangeAmount: float = 0.0,\nisPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float\n= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:\nfloat = 1.7976931348623157e+308, adjustedStopPrice: float =\n1.7976931348623157e+308, adjustedStopLimitPrice: float =\n1.7976931348623157e+308, adjustedTrailingAmount: float =\n1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:\nfloat = 1.7976931348623157e+308, conditions:\n~typing.List[~ib_insync.order.OrderCondition] = <factory>,\nconditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,\nextOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =\n<factory>, cashQty: float = 1.7976931348623157e+308,\nmifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',\nmifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',\ndontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,\n\nOrder for trading contracts.\nhttps://interactivebrokers.github.io/tws-api/available_orders.html\norderId: int = 0\nclientId: int = 0\npermId: int = 0\naction: str = ''\ntotalQuantity: float = 0.0\norderType: str = ''\nlmtPrice: float = 1.7976931348623157e+308\nauxPrice: float = 1.7976931348623157e+308\ntif: str = ''\nactiveStartTime: str = ''\nactiveStopTime: str = ''\nocaGroup: str = ''\nocaType: int = 0\norderRef: str = ''\ntransmit: bool = True\nparentId: int = 0\nblockOrder: bool = False\nsweepToFill: bool = False\ndisplaySize: int = 0\ntriggerMethod: int = 0\noutsideRth: bool = False\nhidden: bool = False\ngoodAfterTime: str = ''\ngoodTillDate: str = ''\nrule80A: str = ''\nallOrNone: bool = False\nminQty: int = 2147483647\npercentOffset: float = 1.7976931348623157e+308\noverridePercentageConstraints: bool = False\ntrailStopPrice: float = 1.7976931348623157e+308\ntrailingPercent: float = 1.7976931348623157e+308\nfaGroup: str = ''\nfaProfile: str = ''\nfaMethod: str = ''\nfaPercentage: str = ''\ndesignatedLocation: str = ''\nopenClose: str = 'O'\norigin: int = 0\nshortSaleSlot: int = 0\nexemptCode: int = -1\ndiscretionaryAmt: float = 0.0\neTradeOnly: bool = False\nfirmQuoteOnly: bool = False\nnbboPriceCap: float = 1.7976931348623157e+308\noptOutSmartRouting: bool = False\nauctionStrategy: int = 0\nstartingPrice: float = 1.7976931348623157e+308\nstockRefPrice: float = 1.7976931348623157e+308\ndelta: float = 1.7976931348623157e+308\nstockRangeLower: float = 1.7976931348623157e+308\nstockRangeUpper: float = 1.7976931348623157e+308\nrandomizePrice: bool = False\nrandomizeSize: bool = False\nvolatility: float = 1.7976931348623157e+308\nvolatilityType: int = 2147483647\ndeltaNeutralOrderType: str = ''\ndeltaNeutralAuxPrice: float = 1.7976931348623157e+308\ndeltaNeutralConId: int = 0\ndeltaNeutralSettlingFirm: str = ''\ndeltaNeutralClearingAccount: str = ''\ndeltaNeutralClearingIntent: str = ''\ndeltaNeutralOpenClose: str = ''\ndeltaNeutralShortSale: bool = False\ndeltaNeutralShortSaleSlot: int = 0\ndeltaNeutralDesignatedLocation: str = ''\ncontinuousUpdate: bool = False\nreferencePriceType: int = 2147483647\nbasisPoints: float = 1.7976931348623157e+308\nbasisPointsType: int = 2147483647\nscaleInitLevelSize: int = 2147483647\nscaleSubsLevelSize: int = 2147483647\nscalePriceIncrement: float = 1.7976931348623157e+308\nscalePriceAdjustValue: float = 1.7976931348623157e+308\nscalePriceAdjustInterval: int = 2147483647\nscaleProfitOffset: float = 1.7976931348623157e+308\nscaleAutoReset: bool = False\nscaleInitPosition: int = 2147483647\nscaleInitFillQty: int = 2147483647\nscaleRandomPercent: bool = False\nscaleTable: str = ''\nhedgeType: str = ''\nhedgeParam: str = ''\naccount: str = ''\nsettlingFirm: str = ''\nclearingAccount: str = ''\nclearingIntent: str = ''\nalgoStrategy: str = ''\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\nalgoId: str = ''\nwhatIf: bool = False\nnotHeld: bool = False\nsolicited: bool = False\nmodelCode: str = ''\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nreferenceContractId: int = 0\npeggedChangeAmount: float = 0.0\nisPeggedChangeAmountDecrease: bool = False\nreferenceChangeAmount: float = 0.0\nreferenceExchangeId: str = ''\nadjustedOrderType: str = ''\ntriggerPrice: float = 1.7976931348623157e+308\nadjustedStopPrice: float = 1.7976931348623157e+308\nadjustedStopLimitPrice: float = 1.7976931348623157e+308\nadjustedTrailingAmount: float = 1.7976931348623157e+308\nadjustableTrailingUnit: int = 0\nlmtPriceOffset: float = 1.7976931348623157e+308\nconditions: List[OrderCondition]\nconditionsCancelOrder: bool = False\nconditionsIgnoreRth: bool = False\nextOperator: str = ''\nsoftDollarTier: SoftDollarTier\ncashQty: float = 1.7976931348623157e+308\nmifid2DecisionMaker: str = ''\nmifid2DecisionAlgo: str = ''\nmifid2ExecutionTrader: str = ''\nmifid2ExecutionAlgo: str = ''\ndontUseAutoPriceForHedge: bool = False\nisOmsContainer: bool = False\ndiscretionaryUpToLimitPrice: bool = False\nautoCancelDate: str = ''\nfilledQuantity: float = 1.7976931348623157e+308\nrefFuturesConId: int = 0\nautoCancelParent: bool = False\nshareholder: str = ''\nimbalanceOnly: bool = False\nrouteMarketableToBbo: bool = False\nparentPermId: int = 0\nusePriceMgmtAlgo: bool = False\nduration: int = 2147483647\npostToAts: int = 2147483647\nadvancedErrorOverride: str = ''\nmanualOrderTime: str = ''\nminTradeQty: int = 2147483647\nminCompeteSize: int = 2147483647\ncompeteAgainstBestOffset: float = 1.7976931348623157e+308\nmidOffsetAtWhole: float = 1.7976931348623157e+308\nmidOffsetAtHalf: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =\n0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,\nlastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',\nmktCapPrice: float = 0.0)\n\norderId: int = 0\nstatus: str = ''\nfilled: float = 0.0\nremaining: float = 0.0\navgFillPrice: float = 0.0\npermId: int = 0\nparentId: int = 0\nlastFillPrice: float = 0.0\nclientId: int = 0\nwhyHeld: str = ''\nmktCapPrice: float = 0.0\nPendingSubmit: ClassVar[str] = 'PendingSubmit'\nPendingCancel: ClassVar[str] = 'PendingCancel'\nPreSubmitted: ClassVar[str] = 'PreSubmitted'\nSubmitted: ClassVar[str] = 'Submitted'\nApiPending: ClassVar[str] = 'ApiPending'\nApiCancelled: ClassVar[str] = 'ApiCancelled'\nCancelled: ClassVar[str] = 'Cancelled'\nFilled: ClassVar[str] = 'Filled'\nInactive: ClassVar[str] = 'Inactive'\nDoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}\nActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',\n'Submitted'}\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',\nequityWithLoanBefore: str = '', initMarginChange: str = '',\nmaintMarginChange: str = '', equityWithLoanChange: str = '',\ninitMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:\nstr = '', commission: float = 1.7976931348623157e+308,\nminCommission: float = 1.7976931348623157e+308, maxCommission:\nfloat = 1.7976931348623157e+308, commissionCurrency: str = '',\nwarningText: str = '', completedTime: str = '', completedStatus: str = '')\n\nstatus: str = ''\ninitMarginBefore: str = ''\nmaintMarginBefore: str = ''\nequityWithLoanBefore: str = ''\ninitMarginChange: str = ''\nmaintMarginChange: str = ''\nequityWithLoanChange: str = ''\ninitMarginAfter: str = ''\nmaintMarginAfter: str = ''\nequityWithLoanAfter: str = ''\ncommission: float = 1.7976931348623157e+308\nminCommission: float = 1.7976931348623157e+308\nmaxCommission: float = 1.7976931348623157e+308\ncommissionCurrency: str = ''\nwarningText: str = ''\ncompletedTime: str = ''\ncompletedStatus: str = ''\ndict()\n\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)\n\nprice: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:\n~ib_insync.order.Order = <factory>, orderStatus:\n~ib_insync.order.OrderStatus = <factory>, fills:\n~typing.List[~ib_insync.objects.Fill] = <factory>, log:\n~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:\nstr = '')\nTrade keeps track of an order, its status and all its fills.\nEvents:\n-statusEvent (trade: Trade)\n-modifyEvent (trade: Trade)\n-fillEvent (trade: Trade, fill: Fill)\n-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)\n-filledEvent (trade: Trade)\n-cancelEvent (trade: Trade)\n-cancelledEvent (trade: Trade)\nevents: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',\n'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')\ncontract: Contract\norder: Order\norderStatus: OrderStatus\nfills: List[Fill]\nlog: List[TradeLogEntry]\nadvancedError: str = ''\nisActive()\nTrue if eligible for execution, false otherwise.\nisDone()\nTrue if completely filled or cancelled, false otherwise.\nfilled()\nNumber of shares filled.\nremaining()\nNumber of shares remaining to be filled.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)\nCreate new instance of BracketOrder(parent, takeProfit, stopLoss)\nproperty parent\nproperty takeProfit\nproperty stopLoss\n\n#### class ib_insync.order.OrderCondition\nstatic createClass(condType)\nAnd()\nOr()\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,\nprice: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =\n0)\ncondType: int = 1\nconjunction: str = 'a'\nisMore: bool = True\nprice: float = 0.0\nconId: int = 0\nexch: str = ''\ntriggerMethod: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:\nstr = '')\ncondType: int = 3\nconjunction: str = 'a'\nisMore: bool = True\ntime: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,\npercent: int = 0)\ncondType: int = 4\nconjunction: str = 'a'\nisMore: bool = True\npercent: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',\nexch: str = '', symbol: str = '')\ncondType: int = 5\nconjunction: str = 'a'\nsecType: str = ''\nexch: str = ''\nsymbol: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,\nvolume: int = 0, conId: int = 0, exch: str = '')\ncondType: int = 6\nconjunction: str = 'a'\nisMore: bool = True\nvolume: int = 0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =\nTrue, changePercent: float = 0.0, conId: int = 0, exch: str\n= '')\ncondType: int = 7\nconjunction: str = 'a'\nisMore: bool = True\nchangePercent: float = 0.0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject","language":"python","description":"\nOrder"},"stats":{"mentions":1,"sources":["ex_0121_fda0b06a"]}},{"id":"merged_ex_0122_bbbc6522","topic":"\nContract","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"Financial instrument types used by Interactive Brokers\n\nclass ib_insync.contract.Contract(secType: str = '', conId: int = 0, symbol: str = '',\nlastTradeDateOrContractMonth: str = '', strike: float = 0.0, right: str =\n'', multiplier: str = '', exchange: str = '', primaryExchange: str = '',\ncurrency: str = '', localSymbol: str = '', tradingClass: str = '',\nincludeExpired: bool = False, secIdType: str = '', secId: str = '',\ndescription: str = '', issuerId: str = '', comboLegsDescrip: str = '',\ncomboLegs: ~typing.List[~ib_insync.contract.ComboLeg] = <factory>,\ndeltaNeutralContract:\n~typing.Optional[~ib_insync.contract.DeltaNeutralContract] = None)\nContract(**kwargs) can create any contract using keyword arguments. To simplify working with contracts,\nthere are also more specialized contracts that take optional positional arguments. Some examples:\n\n\nContract(conId=270639)\nStock('AMD', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nForex('EURUSD')\nCFD('IBUS30')\nFuture('ES', '20180921', 'CME')\nOption('SPY', '20170721', 240, 'C', 'SMART')\nBond(secIdType='ISIN', secId='US03076KAA60')\nCrypto('BTC', 'PAXOS', 'USD')\n\nParameters\n-conId (int) -The unique IB contract identifier.\n-symbol (str) -The contract (or its underlying) symbol.\n-secType (str) -The security type:\n\u2013 \u2019STK\u2019 = Stock (or ETF)\n\u2013 \u2019OPT\u2019 = Option\n\u2013 \u2019FUT\u2019 = Future\n\u2013 \u2019IND\u2019 = Index\n\u2013 \u2019FOP\u2019 = Futures option\n\u2013 \u2019CASH\u2019 = Forex pair\n\u2013 \u2019CFD\u2019 = CFD\n\u2013 \u2019BAG\u2019 = Combo\n\u2013 \u2019WAR\u2019 = Warrant\n\u2013 \u2019BOND\u2019 = Bond\n\u2013 \u2019CMDTY\u2019 = Commodity\n\u2013 \u2019NEWS\u2019 = News\n\u2013 \u2019FUND\u2019 = Mutual fund\n\u2013 \u2019CRYPTO\u2019 = Crypto currency\n-lastTradeDateOrContractMonth (str) -The contract\u2019s last trading day or contract\nmonth (for Options and Futures). Strings with format YYYYMM will be interpreted as\nthe Contract Month whereas YYYYMMDD will be interpreted as Last Trading Day.\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or Call. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019, \u2018CALL\u2019, or \u2018\u2019 for non-options.\n-multiplier (str) -he instrument\u2019s multiplier (i.e. options, futures).\n-exchange (str) -The destination exchange.\n-currency (str) -The underlying\u2019s currency.\n-localSymbol (str) -The contract\u2019s symbol within its primary exchange. For options, this\nwill be the OCC symbol.\n-primaryExchange (str) -The contract\u2019s primary exchange. For smart routed contracts,\nused to define contract in case of ambiguity. Should be defined as native exchange of contract,\ne.g. ISLAND for MSFT. For exchanges which contain a period in name, will only be part of\nexchange name prior to period, i.e. ENEXT for ENEXT.BE.\n-tradingClass (str) -The trading class name for this contract. Available in TWS contract\ndescription window as well. For example, GBL Dec \u201813 future\u2019s trading class is \u201cFGBL\u201d.\n-includeExpired (bool) -If set to true, contract details requests and historical data queries\ncan be performed pertaining to expired futures contracts. Expired options or other instrument\ntypes are not available.\n-secIdType (str) -Security identifier type. Examples for Apple:\n\u2013 secIdType=\u2019ISIN\u2019, secId=\u2019US0378331005\u2019\n\u2013 secIdType=\u2019CUSIP\u2019, secId=\u2019037833100\u2019\n-secId (str) -Security identifier.\n-comboLegsDescription (str) -Description of the combo legs.\n-comboLegs (List[ComboLeg]) -The legs of a combined contract definition.\n-deltaNeutralContract (DeltaNeutralContract) -Delta and underlying price for\nDelta-Neutral combo orders.\nsecType: str = ''\nconId: int = 0\nsymbol: str = ''\nlastTradeDateOrContractMonth: str = ''\nstrike: float = 0.0\nright: str = ''\nmultiplier: str = ''\nexchange: str = ''\nprimaryExchange: str = ''\ncurrency: str = ''\nlocalSymbol: str = ''\ntradingClass: str = ''\nincludeExpired: bool = False\nsecIdType: str = ''\nsecId: str = ''\ndescription: str = ''\nissuerId: str = ''\ncomboLegsDescrip: str = ''\ncomboLegs: List[ComboLeg]\ndeltaNeutralContract: Optional[DeltaNeutralContract] = None\n\nstatic create(**kwargs)\nCreate and a return a specialized contract based on the given secType, or a general Contract if secType is\nnot given.\nReturn type\nContract\n\nisHashable()\nSee if this contract can be hashed by conId.\nNote: Bag contracts always get conId=28812380, so they\u2019re not hashable.\nReturn type\nbool\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.contract.Stock(symbol='', exchange='', currency='', **kwargs)\nStock contract.\nParameters\n-symbol (str) -Symbol name.\n-exchange (str) -Destination exchange.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\ncomboLegs: List[ComboLeg]\n\n#### class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',\nexchange='', multiplier='', currency='', **kwargs)\nOption contract.\nParameters\n-symbol (str) -Symbol name.\n-lastTradeDateOrContractMonth (str) -The option\u2019s last trading day or contract month.\n\u2013 YYYYMM format: To specify last month\n\u2013 YYYYMMDD format: To specify last trading day\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or call option. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019 or \u2018CALL\u2019.\n-exchange (str) -Destination exchange.\n-multiplier (str) -The contract multiplier.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type\nobject\n\ncomboLegs: List[ComboLeg]","language":"python","description":"\nContract"},"stats":{"mentions":1,"sources":["ex_0122_bbbc6522"]}},{"id":"merged_ex_0123_bc6f8975","topic":"\nFuture","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"#### class ib_insync.contract.Future(symbol='', lastTradeDateOrContractMonth='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\n\nFuture contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]\n\n\n#### class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\nContinuous future contract.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type:dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\n*Return type: object\n\ncomboLegs: List[ComboLeg]","language":"python","description":"\nFuture"},"stats":{"mentions":1,"sources":["ex_0123_bc6f8975"]}},{"id":"merged_ex_0129_0c947e3f","topic":"\nFuturesOption","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"class ib_insync.contract.FuturesOption(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='', exchange='', multiplier='', currency='', **kwargs)\n\nOption on a futures contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **strike** (float) - The option's strike price.\n- **right** (str) - Put or call option. Valid values are 'P', 'PUT', 'C' or 'CALL'.\n- **exchange** (str) - Destination exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type:** dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]","language":"python","description":"\nFuturesOption"},"stats":{"mentions":1,"sources":["ex_0129_0c947e3f"]}},{"id":"merged_ex_0134_4bae9046","topic":"\n TagValue","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"class ib_insync.contract.TagValue(tag, value)\n\nCreate new instance of TagValue(tag, value)","language":"python","description":"\n TagValue"},"stats":{"mentions":1,"sources":["ex_0134_4bae9046"]}},{"id":"merged_ex_0135_71282853","topic":"class ibinsync.ibcontroller.Watchdog(controller: U","tier":"a2","confidence":1.0,"tags":["co","vnt","prt"],"content":{"code":"def onConnected():\n    print(ib.accountValues())\n\nibc = IBC(974, gateway=True, tradingMode='paper')\nib = IB()\nib.connectedEvent += onConnected\nwatchdog = Watchdog(ibc, ib, port=4002)\nwatchdog.start()\nib.run()","language":"python","description":"class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =\n'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:\nfloat = 2, appStartupTime: float = 30, ..."},"stats":{"mentions":1,"sources":["ex_0135_71282853"]}},{"id":"merged_ex_0136_1556d437","topic":" Fetching consecutive historical data","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"import datetime\nfrom ib_insync import *\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\ncontract = Stock('TSLA', 'SMART', 'USD')\ndt = ''\nbarsList = []\nwhile True:\nbars = ib.reqHistoricalData(\ncontract,\nendDateTime=dt,\ndurationStr='10 D',\nbarSizeSetting='1 min',\nwhatToShow='MIDPOINT',\nuseRTH=True,\nformatDate=1)\nif not bars:\nbreak\nbarsList.append(bars)\ndt = bars[0].date\nprint(dt)\n# save to CSV file\nallBars = [b for bars in reversed(barsList) for b in bars]\ndf = util.df(allBars)\ndf.to_csv(contract.symbol + '.csv', index=False)","language":"python","description":" Fetching consecutive historical data"},"stats":{"mentions":1,"sources":["ex_0136_1556d437"]}},{"id":"merged_ex_0138_fbdce807","topic":" Scanner data (blocking)","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"allParams = ib.reqScannerParameters()\nprint(allParams)\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerData(sub)\nprint(scanData)","language":"python","description":" Scanner data (blocking)"},"stats":{"mentions":1,"sources":["ex_0138_fbdce807"]}},{"id":"merged_ex_0139_0058769e","topic":" Scanner data (streaming)","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"def onScanData(scanData):\nprint(scanData[0])\nprint(len(scanData))\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerSubscription(sub)\nscanData.updateEvent += onScanData\nib.sleep(60)\nib.cancelScannerSubscription(scanData)","language":"python","description":" Scanner data (streaming)"},"stats":{"mentions":1,"sources":["ex_0139_0058769e"]}},{"id":"merged_ex_0140_c87a4a2c","topic":" Option calculations","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"option = Option('EOE', '20171215', 490, 'P', 'FTA', multiplier=100)\ncalc = ib.calculateImpliedVolatility(\noption, optionPrice=6.1, underPrice=525)\nprint(calc)\ncalc = ib.calculateOptionPrice(\noption, volatility=0.14, underPrice=525)\nprint(calc)","language":"python","description":" Option calculations"},"stats":{"mentions":1,"sources":["ex_0140_c87a4a2c"]}},{"id":"merged_ex_0141_8522063f","topic":" Order book","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"eurusd = Forex('EURUSD')\nticker = ib.reqMktDepth(eurusd)\nwhile ib.sleep(5):\nprint(\n[d.price for d in ticker.domBids],\n[d.price for d in ticker.domAsks])","language":"python","description":" Order book"},"stats":{"mentions":1,"sources":["ex_0141_8522063f"]}},{"id":"merged_ex_0142_c7128665","topic":" Minimum price increments","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"usdjpy = Forex('USDJPY')\ncd = ib.reqContractDetails(usdjpy)[0]\nprint(cd.marketRuleIds)\nrules = [\nib.reqMarketRule(ruleId)\nfor ruleId in cd.marketRuleIds.split(',')]\nprint(rules)","language":"python","description":" Minimum price increments"},"stats":{"mentions":1,"sources":["ex_0142_c7128665"]}},{"id":"merged_ex_0143_2e49e4f1","topic":" News articles","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"newsProviders = ib.reqNewsProviders()\nprint(newsProviders)\ncodes = '+'.join(np.code for np in newsProviders)\namd = Stock('AMD', 'SMART', 'USD')\nib.qualifyContracts(amd)\nheadlines = ib.reqHistoricalNews(amd.conId, codes, '', '', 10)\nlatest = headlines[0]\nprint(latest)\narticle = ib.reqNewsArticle(latest.providerCode, latest.articleId)\nprint(article","language":"python","description":" News articles"},"stats":{"mentions":1,"sources":["ex_0143_2e49e4f1"]}},{"id":"merged_ex_0144_a855e3c4","topic":" News bulletins","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"ib.reqNewsBulletins(True)\nib.sleep(5)\nprint(ib.newsBulletins())","language":"python","description":" News bulletins"},"stats":{"mentions":1,"sources":["ex_0144_a855e3c4"]}},{"id":"merged_ex_0145_6124bc35","topic":" Dividends","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"contract = Stock('INTC', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '456')\nib.sleep(2)\nprint(ticker.dividends)\nOutput:\nDividends(past12Months=1.2, next12Months=1.2, nextDate=datetime.date(2019, 2, 6),\u2423\nnextAmount=0.3)","language":"python","description":" Dividends"},"stats":{"mentions":1,"sources":["ex_0145_6124bc35"]}},{"id":"merged_ex_0146_ac20163f","topic":" Fundamental ratios","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"contract = Stock('IBM', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '258')\nib.sleep(2)\nprint(ticker.fundamentalRatios)","language":"python","description":" Fundamental ratios"},"stats":{"mentions":1,"sources":["ex_0146_ac20163f"]}},{"id":"merged_ex_0148_f2fd5bf4","topic":" Integration with Tkinter","tier":"a2","confidence":1.0,"tags":["co","ct","er"],"content":{"code":"class TkApp:\n    \"\"\"\n    Example of integrating with Tkinter.\n    \"\"\"\n    def __init__(self):\n        self.ib = IB().connect()\n        self.root = tk.Tk()\n        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)\n        self.entry = tk.Entry(self.root, width=50)\n        self.entry.insert(0, \"Stock('TSLA', 'SMART', 'USD')\")\n        self.entry.grid()\n        self.button = tk.Button(\n            self.root, text='Get details', command=self.onButtonClick)\n        self.button.grid()\n        self.text = tk.Text(self.root)\n        self.text.grid()\n        self.loop = util.getLoop()\n\n    def onButtonClick(self):\n        contract = eval(self.entry.get())\n        cds = self.ib.reqContractDetails(contract)\n        self.text.delete(1.0, tk.END)\n        self.text.insert(tk.END, str(cds))\n\n    def run(self):\n        self._onTimeout()\n        self.loop.run_forever()\n\n    def _onTimeout(self):\n        self.root.update()\n        self.loop.call_later(0.03, self._onTimeout)\n\n    def _onDeleteWindow(self):\n        self.loop.stop()\n\n\napp = TkApp()\napp.run()","language":"python","description":" Integration with Tkinter"},"stats":{"mentions":1,"sources":["ex_0148_f2fd5bf4"]}},{"id":"merged_ex_0149_9e42986f","topic":" Price-Based Condition","tier":"a2","confidence":1.0,"tags":["co","ct","or"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Order triggers when SPY hits 450\ncontract = Stock('AAPL', 'SMART', 'USD')\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\n\n# Qualify both\ncontract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)\n\n# Create price condition\ncondition = PriceCondition(\n    condType=1,  # Price\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # True = above, False = below\n    price=450.0\n)\n\n# Create order with condition\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False\n\ntrade = ib.placeOrder(contract, order)\nprint(f\"Conditional order placed: {trade.order.orderId}\")","language":"python","description":" Price-Based Condition"},"stats":{"mentions":1,"sources":["ex_0149_9e42986f"]}},{"id":"merged_ex_0150_43324d28","topic":" Time-Based Condition","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"from datetime import datetime, timedelta\n\n# Order triggers at specific time\ntime_condition = TimeCondition(\n    condType=3,  # Time\n    isMore=True,\n    time=datetime.now() + timedelta(hours=1)\n)\n\norder = MarketOrder('BUY', 100)\norder.conditions = [time_condition]\ntrade = ib.placeOrder(contract, order)","language":"python","description":" Time-Based Condition"},"stats":{"mentions":1,"sources":["ex_0150_43324d28"]}},{"id":"merged_ex_0151_5d2c3705","topic":" Volume-Based Condition","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Trigger when daily volume exceeds threshold\nvolume_condition = VolumeCondition(\n    condType=4,  # Volume\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=10000000  # 10M shares\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [volume_condition]\ntrade = ib.placeOrder(contract, order)","language":"python","description":" Volume-Based Condition"},"stats":{"mentions":1,"sources":["ex_0151_5d2c3705"]}},{"id":"merged_ex_0152_4ec34ae3","topic":" Multiple Conditions (AND/OR)","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"# Order triggers when BOTH conditions met\nprice_cond = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,\n    price=450.0\n)\n\nvolume_cond = VolumeCondition(\n    condType=4,\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=5000000\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [price_cond, volume_cond]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False  # False = AND, True = OR\n\ntrade = ib.placeOrder(contract, order)","language":"python","description":" Multiple Conditions (AND/OR)"},"stats":{"mentions":1,"sources":["ex_0152_4ec34ae3"]}},{"id":"merged_ex_0159_02a55978","topic":" Multiple Exits from Same Entry","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"# Buy at market, then set multiple exit strategies\nentry_order = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry_order)\n\n# Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    # Create OCA group for exits\n    oca_group = f\"OCA_{int(time.time())}\"\n    \n    # Exit 1: Take profit at +5%\n    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)\n    exit1.ocaGroup = oca_group\n    exit1.ocaType = 1  # Cancel all on fill\n    \n    # Exit 2: Stop loss at -2%\n    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)\n    exit2.ocaGroup = oca_group\n    exit2.ocaType = 1\n    \n    # Exit 3: Trailing stop\n    exit3 = Order()\n    exit3.action = 'SELL'\n    exit3.totalQuantity = 100\n    exit3.orderType = 'TRAIL'\n    exit3.trailingPercent = 3.0\n    exit3.ocaGroup = oca_group\n    exit3.ocaType = 1\n    \n    for order in [exit1, exit2, exit3]:\n        ib.placeOrder(contract, order)","language":"python","description":" Multiple Exits from Same Entry"},"stats":{"mentions":1,"sources":["ex_0159_02a55978"]}},{"id":"merged_ex_0161_c633d4e2","topic":" VWAP (Volume-Weighted Average Price)","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Vwap'\norder.algoParams = [\n    TagValue('maxPctVol', '0.1'),  # Max 10% of volume\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1'),\n    TagValue('noTakeLiq', '1')\n]\n\ntrade = ib.placeOrder(contract, order)","language":"python","description":" VWAP (Volume-Weighted Average Price)"},"stats":{"mentions":1,"sources":["ex_0161_c633d4e2"]}},{"id":"merged_ex_0162_40a89498","topic":" Adaptive (IB's Smart Routing)","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"order = Order()\norder.action = 'BUY'\norder.totalQuantity = 1000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Adaptive'\norder.algoParams = [\n    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient\n]\n\ntrade = ib.placeOrder(contract, order)","language":"python","description":" Adaptive (IB's Smart Routing)"},"stats":{"mentions":1,"sources":["ex_0162_40a89498"]}},{"id":"merged_ex_0163_f6b52c88","topic":" Vertical Spread (Bull Call Spread)","tier":"a2","confidence":1.0,"tags":["co","ct","or"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Define legs\nbuy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\n# Qualify\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\n# Create combo contract\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\n# Define legs\nleg1 = ComboLeg()\nleg1.conId = buy_call.conId\nleg1.ratio = 1\nleg1.action = 'BUY'\nleg1.exchange = 'SMART'\n\nleg2 = ComboLeg()\nleg2.conId = sell_call.conId\nleg2.ratio = 1\nleg2.action = 'SELL'\nleg2.exchange = 'SMART'\n\ncombo.comboLegs = [leg1, leg2]\n\n# Place order\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50\ntrade = ib.placeOrder(combo, order)","language":"python","description":" Vertical Spread (Bull Call Spread)"},"stats":{"mentions":1,"sources":["ex_0163_f6b52c88"]}},{"id":"merged_cluster_0149","topic":" Iron Condor","tier":"a2","confidence":0.6,"tags":["ct","or"],"content":{"code":"# Four-leg strategy: sell OTM call spread + sell OTM put spread\nbuy_call = Option('SPY', '20240315', 470, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 465, 'C', 'SMART')\nbuy_put = Option('SPY', '20240315', 430, 'P', 'SMART')\nsell_put = Option('SPY', '20240315', 435, 'P', 'SMART')\n\n# Qualify all\ncontracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)\n\n# Create BAG\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put\n    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put\n]\n\n# Place as credit spread\norder = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit\ntrade = ib.placeOrder(combo, order)","language":"python","description":" Iron Condor"},"stats":{"mentions":2,"sources":["ex_0164_57cd3283","ex_0165_ccb0bf34"]}},{"id":"merged_ex_0167_405955a3","topic":" Delta Hedging Pattern","tier":"a2","confidence":1.0,"tags":["ct","da","or","prt"],"content":{"code":"# Dynamic delta hedging for options position\ndef calculate_position_delta(portfolio):\n    \"\"\"Calculate total portfolio delta\"\"\"\n    total_delta = 0.0\n    \n    for item in portfolio:\n        if item.contract.secType == 'OPT':\n            # Request option computations\n            ticker = ib.reqMktData(item.contract, '', False, False)\n            ib.sleep(1)\n            \n            if ticker.modelGreeks:\n                delta = ticker.modelGreeks.delta\n                total_delta += delta * item.position\n            \n            ib.cancelMktData(item.contract)\n    \n    return total_delta\n\ndef hedge_delta(underlying_contract, target_delta=0.0):\n    \"\"\"Adjust underlying position to achieve target delta\"\"\"\n    portfolio = ib.portfolio()\n    current_delta = calculate_position_delta(portfolio)\n    \n    delta_to_hedge = current_delta - target_delta\n    \n    if abs(delta_to_hedge) > 0.1:  # Threshold\n        # Delta of stock is 1.0\n        shares_to_trade = int(delta_to_hedge * 100)  # Per contract\n        \n        if shares_to_trade > 0:\n            order = MarketOrder('SELL', abs(shares_to_trade))\n        else:\n            order = MarketOrder('BUY', abs(shares_to_trade))\n        \n        trade = ib.placeOrder(underlying_contract, order)\n        print(f\"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}\")\n        \n        return trade\n    else:\n        print(f\"Delta within tolerance: {current_delta:.2f}\")\n        return None\n\n# Run periodically\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\nwhile True:\n    hedge_delta(underlying, target_delta=0.0)\n    ib.sleep(300)  # Every 5 minutes","language":"python","description":" Delta Hedging Pattern"},"stats":{"mentions":1,"sources":["ex_0167_405955a3"]}},{"id":"merged_ex_0168_01a3894d","topic":" Comprehensive Error Handler","tier":"a2","confidence":1.0,"tags":["co","ct","er","vnt","or"],"content":{"code":"from ib_insync import *\nimport logging\n\nclass IBErrorHandler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.error_log = []\n        self.ib.errorEvent += self.on_error\n        \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Centralized error handling\"\"\"\n        error_info = {\n            'time': datetime.now(),\n            'reqId': reqId,\n            'code': errorCode,\n            'message': errorString,\n            'contract': contract\n        }\n        self.error_log.append(error_info)\n        \n        # Categorize and handle\n        if errorCode in [502, 503, 504]:\n            self.handle_connection_error(errorCode, errorString)\n        elif errorCode in [200, 201, 202]:\n            self.handle_order_error(errorCode, errorString, contract)\n        elif errorCode == 162:\n            self.handle_data_error(errorCode, errorString, contract)\n        elif errorCode == 354:\n            self.handle_market_data_subscription_error(errorCode, errorString)\n        elif errorCode in [2104, 2106, 2158]:\n            # Info messages - ignore\n            pass\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def handle_connection_error(self, code, message):\n        \"\"\"Handle connection failures\"\"\"\n        logging.critical(f\"Connection error {code}: {message}\")\n        # Trigger reconnection\n        self.schedule_reconnect()\n    \n    def handle_order_error(self, code, message, contract):\n        \"\"\"Handle order rejections\"\"\"\n        logging.error(f\"Order error {code}: {message} for {contract}\")\n        # Could retry with modified params\n        # Or alert user\n    \n    def handle_data_error(self, code, message, contract):\n        \"\"\"Handle data request failures\"\"\"\n        logging.warning(f\"Data error {code}: {message} for {contract}\")\n        # Retry with different params\n    \n    def handle_market_data_subscription_error(self, code, message):\n        \"\"\"Handle market data subscription issues\"\"\"\n        logging.warning(f\"Market data error {code}: {message}\")\n        # Fall back to delayed data\n        self.ib.reqMarketDataType(3)  # Delayed\n    \n    def schedule_reconnect(self):\n        \"\"\"Schedule reconnection attempt\"\"\"\n        # Implementation in reconnection section\n        pass\n\n# Usage\nib = IB()\nerror_handler = IBErrorHandler(ib)\nib.connect('127.0.0.1', 7497, clientId=1)","language":"python","description":" Comprehensive Error Handler"},"stats":{"mentions":1,"sources":["ex_0168_01a3894d"]}},{"id":"merged_ex_0169_53f05d1d","topic":" Order Validation Before Submission","tier":"a2","confidence":1.0,"tags":["ct","da","er","or","prt"],"content":{"code":"def validate_order(ib, contract, order):\n    \"\"\"Validate order before placing\"\"\"\n    errors = []\n    \n    # 1. Check contract is qualified\n    if contract.conId == 0:\n        errors.append(\"Contract not qualified\")\n    \n    # 2. Check buying power\n    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}\n    \n    if order.action == 'BUY':\n        # Estimate cost\n        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot\n        ib.sleep(1)\n        \n        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN\n            estimated_cost = ticker.ask * order.totalQuantity\n            if estimated_cost > account_values.get('BuyingPower', 0):\n                errors.append(f\"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}\")\n        \n        ib.cancelMktData(contract)\n    \n    # 3. What-if order check\n    try:\n        order_copy = Order(**{k: v for k, v in order.__dict__.items()})\n        order_copy.whatIf = True\n        \n        orderState = ib.whatIfOrder(contract, order_copy)\n        \n        if orderState.commission and orderState.commission > 0:\n            # Valid response\n            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):\n                errors.append(\"Insufficient margin\")\n        else:\n            errors.append(\"What-if order returned invalid state\")\n            \n    except Exception as e:\n        errors.append(f\"What-if validation failed: {e}\")\n    \n    # 4. Check trading hours\n    details = ib.reqContractDetails(contract)\n    if details:\n        # Parse trading hours (simplified)\n        # Would need full implementation\n        pass\n    \n    return errors\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\norder = LimitOrder('BUY', 1000, 175.0)\n\nvalidation_errors = validate_order(ib, contract, order)\nif validation_errors:\n    print(\"Order validation failed:\")\n    for error in validation_errors:\n        print(f\"  - {error}\")\nelse:\n    trade = ib.placeOrder(contract, order)\n    print(\"Order placed successfully\")","language":"python","description":" Order Validation Before Submission"},"stats":{"mentions":1,"sources":["ex_0169_53f05d1d"]}},{"id":"merged_ex_0170_11393855","topic":" Retry Logic with Exponential Backoff","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"import time\nfrom functools import wraps\n\ndef retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):\n    \"\"\"Decorator for retrying failed operations\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            retries = 0\n            delay = base_delay\n            \n            while retries < max_retries:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    retries += 1\n                    if retries >= max_retries:\n                        logging.error(f\"{func.__name__} failed after {max_retries} retries: {e}\")\n                        raise\n                    \n                    logging.warning(f\"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n                    delay = min(delay * 2, max_delay)  # Exponential backoff\n            \n        return wrapper\n    return decorator\n\n# Usage\n@retry_with_backoff(max_retries=3, base_delay=2.0)\ndef place_order_with_retry(ib, contract, order):\n    \"\"\"Place order with automatic retry\"\"\"\n    trade = ib.placeOrder(contract, order)\n    \n    # Wait for submission\n    timeout = 10\n    start = time.time()\n    while trade.orderStatus.status in ['PendingSubmit', '']:\n        if time.time() - start > timeout:\n            raise TimeoutError(\"Order submission timeout\")\n        ib.sleep(0.1)\n    \n    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:\n        raise Exception(f\"Order cancelled: {trade.orderStatus.status}\")\n    \n    return trade\n\n# Usage\ntry:\n    trade = place_order_with_retry(ib, contract, order)\n    print(f\"Order placed: {trade.order.orderId}\")\nexcept Exception as e:\n    print(f\"Order failed: {e}\")","language":"python","description":" Retry Logic with Exponential Backoff"},"stats":{"mentions":1,"sources":["ex_0170_11393855"]}},{"id":"merged_ex_0171_130315a8","topic":" Position Reconciliation","tier":"a2","confidence":1.0,"tags":["ct","vnt","or","prt"],"content":{"code":"class PositionManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.expected_positions = {}  # conId -> quantity\n        \n    def record_trade(self, trade):\n        \"\"\"Record expected position change\"\"\"\n        if trade.orderStatus.status == 'Filled':\n            conId = trade.contract.conId\n            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()\n            \n            if conId in self.expected_positions:\n                self.expected_positions[conId] += qty\n            else:\n                self.expected_positions[conId] = qty\n    \n    def reconcile(self):\n        \"\"\"Check actual vs expected positions\"\"\"\n        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}\n        \n        discrepancies = []\n        \n        # Check expected positions\n        for conId, expected_qty in self.expected_positions.items():\n            actual_qty = actual_positions.get(conId, 0)\n            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': expected_qty,\n                    'actual': actual_qty,\n                    'diff': actual_qty - expected_qty\n                })\n        \n        # Check for unexpected positions\n        for conId, actual_qty in actual_positions.items():\n            if conId not in self.expected_positions and abs(actual_qty) > 0.01:\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': 0,\n                    'actual': actual_qty,\n                    'diff': actual_qty\n                })\n        \n        if discrepancies:\n            logging.warning(f\"Position discrepancies found: {discrepancies}\")\n        \n        return discrepancies\n    \n    def reset_tracking(self):\n        \"\"\"Reset to current positions\"\"\"\n        self.expected_positions = {\n            p.contract.conId: p.position \n            for p in self.ib.positions()\n        }\n\n# Usage\npm = PositionManager(ib)\npm.reset_tracking()\n\n# Track trades\nib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)\n\n# Periodic reconciliation\nwhile True:\n    discrepancies = pm.reconcile()\n    if discrepancies:\n        # Alert or take action\n        pass\n    ib.sleep(60)","language":"python","description":" Position Reconciliation"},"stats":{"mentions":1,"sources":["ex_0171_130315a8"]}},{"id":"merged_ex_0172_de7fe994","topic":" Close All Positions","tier":"a2","confidence":1.0,"tags":["ct","er","or","prt"],"content":{"code":"def close_all_positions(ib, exclude_symbols=None):\n    \"\"\"Emergency position closer\"\"\"\n    exclude_symbols = exclude_symbols or []\n    \n    positions = ib.positions()\n    trades = []\n    \n    for position in positions:\n        symbol = position.contract.symbol\n        \n        if symbol in exclude_symbols:\n            continue\n        \n        qty = abs(position.position)\n        action = 'SELL' if position.position > 0 else 'BUY'\n        \n        order = MarketOrder(action, qty)\n        trade = ib.placeOrder(position.contract, order)\n        trades.append(trade)\n        \n        print(f\"Closing {action} {qty} {symbol}\")\n    \n    # Wait for all to fill\n    timeout = 30\n    start = time.time()\n    \n    while any(not t.isDone() for t in trades):\n        if time.time() - start > timeout:\n            logging.error(\"Timeout waiting for position closures\")\n            break\n        ib.sleep(0.5)\n    \n    return trades\n\n# Usage - emergency exit\nif emergency_condition:\n    close_all_positions(ib)","language":"python","description":" Close All Positions"},"stats":{"mentions":1,"sources":["ex_0172_de7fe994"]}},{"id":"merged_ex_0173_6fdd48c4","topic":" Position Size Calculator","tier":"a2","confidence":1.0,"tags":["ct","da","er","or","prt"],"content":{"code":"def calculate_position_size(\n    ib,\n    contract,\n    risk_per_trade_pct=0.02,  # 2% risk\n    stop_loss_pct=0.05         # 5% stop\n):\n    \"\"\"Calculate position size based on risk\"\"\"\n    \n    # Get account value\n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    # Calculate dollar risk\n    dollar_risk = net_liq * risk_per_trade_pct\n    \n    # Get current price\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if not ticker.last or ticker.last != ticker.last:  # NaN check\n        logging.error(\"Unable to get price for position sizing\")\n        return 0\n    \n    price = ticker.last\n    ib.cancelMktData(contract)\n    \n    # Calculate shares\n    # dollar_risk = shares * price * stop_loss_pct\n    shares = dollar_risk / (price * stop_loss_pct)\n    \n    # Round to nearest tradeable lot\n    if contract.secType == 'OPT':\n        shares = int(shares / 100) * 100  # Options in contracts (100 shares)\n    else:\n        shares = int(shares)\n    \n    print(f\"Position size for {contract.symbol}: {shares} shares\")\n    print(f\"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})\")\n    \n    return shares\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nshares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)\n\nif shares > 0:\n    order = LimitOrder('BUY', shares, 175.0)\n    trade = ib.placeOrder(contract, order)","language":"python","description":" Position Size Calculator"},"stats":{"mentions":1,"sources":["ex_0173_6fdd48c4"]}},{"id":"merged_ex_0174_7b2a453d","topic":" Daily Loss Limit","tier":"a2","confidence":1.0,"tags":["or","prt"],"content":{"code":"class DailyLossLimiter:\n    def __init__(self, ib, max_daily_loss_pct=0.05):\n        self.ib = ib\n        self.max_daily_loss_pct = max_daily_loss_pct\n        self.start_equity = None\n        self.breached = False\n        \n    def initialize(self):\n        \"\"\"Set starting equity for the day\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        self.breached = False\n        print(f\"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}\")\n    \n    def check_limit(self):\n        \"\"\"Check if daily loss limit breached\"\"\"\n        if self.breached:\n            return True\n        \n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            self.breached = True\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)\")\n            return True\n        \n        return False\n    \n    def enforce(self):\n        \"\"\"Close all positions and cancel all orders\"\"\"\n        if not self.breached:\n            return\n        \n        print(\"Enforcing daily loss limit...\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        close_all_positions(self.ib)\n        \n        print(\"All positions closed. Trading halted for the day.\")\n\n# Usage\nlimiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit\nlimiter.initialize()\n\n# Check periodically\nwhile True:\n    if limiter.check_limit():\n        limiter.enforce()\n        break\n    ib.sleep(60)","language":"python","description":" Daily Loss Limit"},"stats":{"mentions":1,"sources":["ex_0174_7b2a453d"]}},{"id":"merged_ex_0175_d2cf5153","topic":" Max Position Concentration","tier":"a2","confidence":1.0,"tags":["ct","da","er","or","prt"],"content":{"code":"def check_position_concentration(ib, max_position_pct=0.20):\n    \"\"\"Ensure no single position exceeds % of portfolio\"\"\"\n    \n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    violations = []\n    \n    for item in ib.portfolio():\n        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0\n        \n        if position_pct > max_position_pct:\n            violations.append({\n                'symbol': item.contract.symbol,\n                'value': item.marketValue,\n                'pct': position_pct,\n                'limit': max_position_pct\n            })\n    \n    if violations:\n        logging.warning(f\"Position concentration violations: {violations}\")\n    \n    return violations\n\n# Check before placing order\ndef place_order_with_concentration_check(ib, contract, order, max_pct=0.20):\n    \"\"\"Place order only if it doesn't violate concentration\"\"\"\n    \n    # Estimate new position value\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if ticker.ask:\n        estimated_value = ticker.ask * order.totalQuantity\n        \n        account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        # Get current position\n        current_position = next(\n            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),\n            0\n        )\n        \n        new_position_value = abs(current_position + estimated_value)\n        new_pct = new_position_value / net_liq if net_liq > 0 else 0\n        \n        if new_pct > max_pct:\n            logging.error(f\"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%\")\n            ib.cancelMktData(contract)\n            return None\n    \n    ib.cancelMktData(contract)\n    return ib.placeOrder(contract, order)","language":"python","description":" Max Position Concentration"},"stats":{"mentions":1,"sources":["ex_0175_d2cf5153"]}},{"id":"merged_ex_0176_65541a5c","topic":" Correlation-Based Risk","tier":"a2","confidence":1.0,"tags":["ct","da","prt"],"content":{"code":"import numpy as np\nimport pandas as pd\n\ndef calculate_portfolio_correlation_risk(ib, lookback_days=30):\n    \"\"\"Calculate portfolio correlation matrix\"\"\"\n    \n    portfolio = ib.portfolio()\n    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']\n    \n    # Get historical data for all positions\n    price_data = {}\n    \n    for symbol in symbols:\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = ib.qualifyContracts(contract)[0]\n        \n        bars = ib.reqHistoricalData(\n            contract,\n            endDateTime='',\n            durationStr=f'{lookback_days} D',\n            barSizeSetting='1 day',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if bars:\n            price_data[symbol] = [bar.close for bar in bars]\n    \n    # Create DataFrame\n    df = pd.DataFrame(price_data)\n    \n    # Calculate returns\n    returns = df.pct_change().dropna()\n    \n    # Correlation matrix\n    corr_matrix = returns.corr()\n    \n    # Identify highly correlated pairs\n    high_corr_threshold = 0.7\n    high_corr_pairs = []\n    \n    for i in range(len(corr_matrix.columns)):\n        for j in range(i+1, len(corr_matrix.columns)):\n            corr = corr_matrix.iloc[i, j]\n            if abs(corr) > high_corr_threshold:\n                high_corr_pairs.append({\n                    'symbol1': corr_matrix.columns[i],\n                    'symbol2': corr_matrix.columns[j],\n                    'correlation': corr\n                })\n    \n    if high_corr_pairs:\n        logging.warning(f\"High correlation detected: {high_corr_pairs}\")\n    \n    return corr_matrix, high_corr_pairs\n\n# Usage\ncorr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)\nprint(\"Portfolio Correlation Matrix:\")\nprint(corr_matrix)","language":"python","description":" Correlation-Based Risk"},"stats":{"mentions":1,"sources":["ex_0176_65541a5c"]}},{"id":"merged_ex_0177_8748cfe5","topic":" Auto-Reconnect Manager","tier":"a2","confidence":1.0,"tags":["co","ct","da","er","vnt","prt"],"content":{"code":"class ReconnectionManager:\n    def __init__(self, host='127.0.0.1', port=7497, clientId=1):\n        self.host = host\n        self.port = port\n        self.clientId = clientId\n        self.ib = None\n        self.reconnect_attempts = 0\n        self.max_reconnect_attempts = 10\n        self.reconnect_delay = 5\n        self.is_connected = False\n        \n    def connect(self):\n        \"\"\"Initial connection with reconnect logic\"\"\"\n        while self.reconnect_attempts < self.max_reconnect_attempts:\n            try:\n                self.ib = IB()\n                self.ib.disconnectedEvent += self.on_disconnect\n                self.ib.errorEvent += self.on_error\n                \n                self.ib.connect(\n                    self.host,\n                    self.port,\n                    self.clientId,\n                    timeout=10\n                )\n                \n                self.is_connected = True\n                self.reconnect_attempts = 0\n                logging.info(f\"Connected to TWS at {self.host}:{self.port}\")\n                \n                # Restore subscriptions\n                self.restore_state()\n                \n                return self.ib\n                \n            except Exception as e:\n                self.reconnect_attempts += 1\n                logging.error(f\"Connection attempt {self.reconnect_attempts} failed: {e}\")\n                \n                if self.reconnect_attempts >= self.max_reconnect_attempts:\n                    logging.critical(\"Max reconnection attempts reached. Giving up.\")\n                    raise\n                \n                logging.info(f\"Retrying in {self.reconnect_delay} seconds...\")\n                time.sleep(self.reconnect_delay)\n                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        self.is_connected = False\n        logging.warning(\"Disconnected from TWS. Attempting reconnect...\")\n        \n        # Save current state\n        self.save_state()\n        \n        # Attempt reconnection\n        self.connect()\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle connection errors\"\"\"\n        if errorCode in [502, 503, 504, 1100, 1101, 1102]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n            if not self.is_connected:\n                self.on_disconnect()\n    \n    def save_state(self):\n        \"\"\"Save subscriptions and state before disconnect\"\"\"\n        if not self.ib:\n            return\n        \n        # Save tickers\n        self.saved_tickers = [\n            (ticker.contract, ticker.genericTickList) \n            for ticker in self.ib.tickers()\n        ]\n        \n        # Save positions (for monitoring)\n        self.saved_positions = [\n            (p.contract, p.position) \n            for p in self.ib.positions()\n        ]\n        \n        logging.info(f\"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions\")\n    \n    def restore_state(self):\n        \"\"\"Restore subscriptions after reconnect\"\"\"\n        if not hasattr(self, 'saved_tickers'):\n            return\n        \n        logging.info(\"Restoring market data subscriptions...\")\n        \n        # Resubscribe to tickers\n        for contract, genericTickList in self.saved_tickers:\n            try:\n                self.ib.reqMktData(contract, genericTickList, False, False)\n            except Exception as e:\n                logging.error(f\"Failed to restore ticker {contract.symbol}: {e}\")\n        \n        logging.info(\"State restored\")\n\n# Usage\nconn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)\nib = conn_mgr.connect()\n\n# Normal trading operations\n# Connection will auto-reconnect on failure","language":"python","description":" Auto-Reconnect Manager"},"stats":{"mentions":1,"sources":["ex_0177_8748cfe5"]}},{"id":"merged_ex_0178_7a9e424a","topic":" Heartbeat Monitor","tier":"a2","confidence":1.0,"tags":["as","co","er","vnt"],"content":{"code":"class HeartbeatMonitor:\n    def __init__(self, ib, timeout=60):\n        self.ib = ib\n        self.timeout = timeout\n        self.last_update = time.time()\n        self.ib.updateEvent += self.on_update\n        \n    def on_update(self):\n        \"\"\"Reset timer on any update\"\"\"\n        self.last_update = time.time()\n    \n    def check(self):\n        \"\"\"Check if connection is alive\"\"\"\n        elapsed = time.time() - self.last_update\n        \n        if elapsed > self.timeout:\n            logging.warning(f\"No updates for {elapsed:.0f}s. Connection may be dead.\")\n            return False\n        \n        return True\n    \n    def run(self):\n        \"\"\"Run heartbeat check loop\"\"\"\n        while True:\n            if not self.check():\n                logging.error(\"Heartbeat timeout. Triggering reconnect...\")\n                # Trigger reconnection\n                break\n            \n            time.sleep(10)\n\n# Usage\nheartbeat = HeartbeatMonitor(ib, timeout=60)\n# Run in separate thread or async task","language":"python","description":" Heartbeat Monitor"},"stats":{"mentions":1,"sources":["ex_0178_7a9e424a"]}},{"id":"merged_ex_0179_0c5a4c2d","topic":" Target Allocation Rebalancer","tier":"a2","confidence":1.0,"tags":["ct","da","er","or","prt"],"content":{"code":"class PortfolioRebalancer:\n    def __init__(self, ib):\n        self.ib = ib\n        \n    def rebalance_to_target(self, target_allocations, tolerance=0.05):\n        \"\"\"\n        Rebalance portfolio to target allocations\n        \n        Args:\n            target_allocations: Dict[symbol: str, target_pct: float]\n                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}\n            tolerance: Rebalance threshold (0.05 = 5%)\n        \"\"\"\n        \n        # Validate target allocations\n        total = sum(target_allocations.values())\n        if abs(total - 1.0) > 0.01:\n            raise ValueError(f\"Target allocations must sum to 1.0, got {total}\")\n        \n        # Get current portfolio\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}\n        \n        # Calculate current allocations\n        current_allocations = {\n            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)\n            for symbol, item in portfolio.items()\n        }\n        \n        # Determine needed trades\n        trades_needed = []\n        \n        for symbol, target_pct in target_allocations.items():\n            current_pct = current_allocations.get(symbol, 0)\n            diff = target_pct - current_pct\n            \n            if abs(diff) > tolerance:\n                target_value = net_liq * target_pct\n                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0\n                value_change = target_value - current_value\n                \n                # Get current price\n                contract = Stock(symbol, 'SMART', 'USD')\n                contract = self.ib.qualifyContracts(contract)[0]\n                \n                ticker = self.ib.reqMktData(contract, '', True, False)\n                self.ib.sleep(1)\n                \n                if ticker.last and ticker.last == ticker.last:\n                    price = ticker.last\n                    shares_change = int(value_change / price)\n                    \n                    if shares_change != 0:\n                        trades_needed.append({\n                            'symbol': symbol,\n                            'contract': contract,\n                            'current_pct': current_pct,\n                            'target_pct': target_pct,\n                            'shares': shares_change,\n                            'action': 'BUY' if shares_change > 0 else 'SELL'\n                        })\n                \n                self.ib.cancelMktData(contract)\n        \n        # Execute trades\n        if not trades_needed:\n            logging.info(\"Portfolio within tolerance. No rebalancing needed.\")\n            return []\n        \n        logging.info(f\"Rebalancing {len(trades_needed)} positions...\")\n        placed_trades = []\n        \n        for trade_info in trades_needed:\n            logging.info(f\"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} \"\n                        f\"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)\")\n            \n            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))\n            trade = self.ib.placeOrder(trade_info['contract'], order)\n            placed_trades.append(trade)\n        \n        return placed_trades\n\n# Usage\ntarget = {\n    'AAPL': 0.30,\n    'GOOGL': 0.30,\n    'MSFT': 0.40\n}\n\nrebalancer = PortfolioRebalancer(ib)\ntrades = rebalancer.rebalance_to_target(target, tolerance=0.03)\n\n# Monitor fills\nfor trade in trades:\n    while not trade.isDone():\n        ib.sleep(1)\n    print(f\"{trade.contract.symbol}: {trade.orderStatus.status}\")","language":"python","description":" Target Allocation Rebalancer"},"stats":{"mentions":1,"sources":["ex_0179_0c5a4c2d"]}},{"id":"merged_ex_0180_c93de700","topic":" Dollar-Cost Averaging","tier":"a2","confidence":1.0,"tags":["ct","da","or"],"content":{"code":"class DCAScheduler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.schedules = []\n        \n    def add_schedule(self, symbol, amount_per_period, frequency_days):\n        \"\"\"\n        Add DCA schedule\n        \n        Args:\n            symbol: Stock symbol\n            amount_per_period: Dollar amount to invest\n            frequency_days: Days between purchases\n        \"\"\"\n        self.schedules.append({\n            'symbol': symbol,\n            'amount': amount_per_period,\n            'frequency': frequency_days,\n            'last_purchase': None\n        })\n    \n    def check_and_execute(self):\n        \"\"\"Check if any DCA purchases are due\"\"\"\n        from datetime import datetime, timedelta\n        \n        now = datetime.now()\n        \n        for schedule in self.schedules:\n            last = schedule['last_purchase']\n            \n            # Check if purchase is due\n            if last is None or (now - last).days >= schedule['frequency']:\n                self.execute_dca(schedule)\n                schedule['last_purchase'] = now\n    \n    def execute_dca(self, schedule):\n        \"\"\"Execute DCA purchase\"\"\"\n        symbol = schedule['symbol']\n        amount = schedule['amount']\n        \n        # Create contract\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = self.ib.qualifyContracts(contract)[0]\n        \n        # Get current price\n        ticker = self.ib.reqMktData(contract, '', True, False)\n        self.ib.sleep(1)\n        \n        if ticker.last and ticker.last == ticker.last:\n            price = ticker.last\n            shares = int(amount / price)\n            \n            if shares > 0:\n                logging.info(f\"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})\")\n                order = MarketOrder('BUY', shares)\n                trade = self.ib.placeOrder(contract, order)\n                return trade\n        \n        self.ib.cancelMktData(contract)\n        return None\n\n# Usage\ndca = DCAScheduler(ib)\ndca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days\ndca.add_schedule('VTI', 500, 14)   # $500 every 14 days\n\n# Run daily check\nwhile True:\n    dca.check_and_execute()\n    ib.sleep(86400)  # Check daily","language":"python","description":" Dollar-Cost Averaging"},"stats":{"mentions":1,"sources":["ex_0180_c93de700"]}},{"id":"merged_ex_0181_61f34a96","topic":" Tick-by-Tick with Filtering","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"class TickFilter:\n    def __init__(self, ib, contract, min_size=100):\n        self.ib = ib\n        self.contract = contract\n        self.min_size = min_size\n        self.large_trades = []\n        \n    def start(self):\n        \"\"\"Start tick-by-tick subscription with filtering\"\"\"\n        self.ticker = self.ib.reqTickByTickData(\n            self.contract,\n            'AllLast',  # All trades\n            0,\n            False\n        )\n        self.ticker.updateEvent += self.on_tick\n    \n    def on_tick(self, ticker):\n        \"\"\"Filter and process ticks\"\"\"\n        if not ticker.tickByTicks:\n            return\n        \n        latest_tick = ticker.tickByTicks[-1]\n        \n        # Filter by size\n        if latest_tick.size >= self.min_size:\n            self.large_trades.append({\n                'time': latest_tick.time,\n                'price': latest_tick.price,\n                'size': latest_tick.size\n            })\n            \n            logging.info(f\"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}\")\n    \n    def stop(self):\n        \"\"\"Stop subscription\"\"\"\n        self.ib.cancelTickByTickData(self.contract)\n    \n    def get_stats(self):\n        \"\"\"Get statistics on large trades\"\"\"\n        if not self.large_trades:\n            return None\n        \n        total_volume = sum(t['size'] for t in self.large_trades)\n        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume\n        \n        return {\n            'num_trades': len(self.large_trades),\n            'total_volume': total_volume,\n            'vwap': avg_price\n        }\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nfilter = TickFilter(ib, contract, min_size=1000)\nfilter.start()\n\n# Run for period\nib.sleep(3600)  # 1 hour\n\nfilter.stop()\nstats = filter.get_stats()\nprint(f\"Large trades: {stats}\")","language":"python","description":" Tick-by-Tick with Filtering"},"stats":{"mentions":1,"sources":["ex_0181_61f34a96"]}},{"id":"merged_ex_0182_36544bcc","topic":" Volume Profile Builder","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"class VolumeProfile:\n    def __init__(self, ib, contract, num_bins=20):\n        self.ib = ib\n        self.contract = contract\n        self.num_bins = num_bins\n        self.profile = {}\n        \n    def build_from_historical(self, days=1):\n        \"\"\"Build volume profile from historical data\"\"\"\n        bars = self.ib.reqHistoricalData(\n            self.contract,\n            endDateTime='',\n            durationStr=f'{days} D',\n            barSizeSetting='5 mins',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if not bars:\n            return None\n        \n        # Get price range\n        prices = [bar.close for bar in bars]\n        min_price = min(prices)\n        max_price = max(prices)\n        \n        # Create bins\n        bin_size = (max_price - min_price) / self.num_bins\n        \n        # Accumulate volume in bins\n        for bar in bars:\n            bin_idx = int((bar.close - min_price) / bin_size)\n            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max\n            \n            bin_price = min_price + (bin_idx * bin_size)\n            \n            if bin_price not in self.profile:\n                self.profile[bin_price] = 0\n            \n            self.profile[bin_price] += bar.volume\n        \n        return self.profile\n    \n    def get_poc(self):\n        \"\"\"Get Point of Control (price with highest volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        return max(self.profile.items(), key=lambda x: x[1])\n    \n    def get_value_area(self, percent=0.70):\n        \"\"\"Get value area (prices containing X% of volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        total_volume = sum(self.profile.values())\n        target_volume = total_volume * percent\n        \n        # Sort by volume\n        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)\n        \n        accumulated_volume = 0\n        value_area_prices = []\n        \n        for price, volume in sorted_profile:\n            accumulated_volume += volume\n            value_area_prices.append(price)\n            \n            if accumulated_volume >= target_volume:\n                break\n        \n        return min(value_area_prices), max(value_area_prices)\n\n# Usage\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nvp = VolumeProfile(ib, contract, num_bins=30)\nprofile = vp.build_from_historical(days=5)\n\npoc_price, poc_volume = vp.get_poc()\nprint(f\"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume\")\n\nva_low, va_high = vp.get_value_area(percent=0.70)\nprint(f\"Value Area: ${va_low:.2f} - ${va_high:.2f}\")","language":"python","description":" Volume Profile Builder"},"stats":{"mentions":1,"sources":["ex_0182_36544bcc"]}},{"id":"merged_ex_0183_3e821cf7","topic":" Multi-Account Order Router","tier":"a2","confidence":1.0,"tags":["co","ct","er","or","prt"],"content":{"code":"class MultiAccountRouter:\n    def __init__(self, host='127.0.0.1', port=7497):\n        self.connections = {}\n        self.host = host\n        self.port = port\n        \n    def add_account(self, account_name, client_id):\n        \"\"\"Add account connection\"\"\"\n        ib = IB()\n        ib.connect(self.host, self.port, client_id)\n        self.connections[account_name] = ib\n        logging.info(f\"Connected account {account_name} with clientId {client_id}\")\n    \n    def place_order_all(self, contract, order_template, quantities):\n        \"\"\"\n        Place orders across multiple accounts\n        \n        Args:\n            contract: Contract to trade\n            order_template: Base order\n            quantities: Dict[account_name, quantity]\n        \"\"\"\n        trades = {}\n        \n        for account_name, quantity in quantities.items():\n            if account_name not in self.connections:\n                logging.error(f\"Account {account_name} not connected\")\n                continue\n            \n            ib = self.connections[account_name]\n            \n            # Clone order\n            order = Order(**{k: v for k, v in order_template.__dict__.items()})\n            order.totalQuantity = quantity\n            order.account = account_name\n            \n            # Place order\n            trade = ib.placeOrder(contract, order)\n            trades[account_name] = trade\n            \n            logging.info(f\"Placed {order.action} {quantity} {contract.symbol} for {account_name}\")\n        \n        return trades\n    \n    def get_combined_portfolio(self):\n        \"\"\"Get combined portfolio across all accounts\"\"\"\n        combined = {}\n        \n        for account_name, ib in self.connections.items():\n            for item in ib.portfolio():\n                symbol = item.contract.symbol\n                \n                if symbol not in combined:\n                    combined[symbol] = {\n                        'position': 0,\n                        'market_value': 0,\n                        'unrealized_pnl': 0,\n                        'accounts': {}\n                    }\n                \n                combined[symbol]['position'] += item.position\n                combined[symbol]['market_value'] += item.marketValue\n                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL\n                combined[symbol]['accounts'][account_name] = item.position\n        \n        return combined\n    \n    def disconnect_all(self):\n        \"\"\"Disconnect all accounts\"\"\"\n        for account_name, ib in self.connections.items():\n            ib.disconnect()\n            logging.info(f\"Disconnected {account_name}\")\n\n# Usage\nrouter = MultiAccountRouter()\nrouter.add_account('Account1', client_id=1)\nrouter.add_account('Account2', client_id=2)\nrouter.add_account('Account3', client_id=3)\n\n# Place order across all accounts\ncontract = Stock('AAPL', 'SMART', 'USD')\norder_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account\n\nquantities = {\n    'Account1': 100,\n    'Account2': 200,\n    'Account3': 150\n}\n\ntrades = router.place_order_all(contract, order_template, quantities)\n\n# Monitor combined portfolio\ncombined = router.get_combined_portfolio()\nfor symbol, data in combined.items():\n    print(f\"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts\")","language":"python","description":" Multi-Account Order Router"},"stats":{"mentions":1,"sources":["ex_0183_3e821cf7"]}},{"id":"merged_ex_0184_caee834a","topic":" Batch Contract Qualification","tier":"a2","confidence":1.0,"tags":["ct","er"],"content":{"code":"def qualify_contracts_batch(ib, contracts, batch_size=50):\n    \"\"\"Qualify contracts in batches to avoid rate limits\"\"\"\n    qualified = []\n    \n    for i in range(0, len(contracts), batch_size):\n        batch = contracts[i:i+batch_size]\n        \n        try:\n            qualified_batch = ib.qualifyContracts(*batch)\n            qualified.extend(qualified_batch)\n        except Exception as e:\n            logging.error(f\"Batch qualification failed: {e}\")\n        \n        # Respect rate limits\n        ib.sleep(1)\n    \n    return qualified","language":"python","description":" Batch Contract Qualification"},"stats":{"mentions":1,"sources":["ex_0184_caee834a"]}},{"id":"merged_ex_0185_3be9f3a2","topic":" Request Queue Manager","tier":"a2","confidence":1.0,"tags":["ct","da","er"],"content":{"code":"from collections import deque\nimport threading\n\nclass RequestQueue:\n    def __init__(self, ib, max_per_second=40):\n        self.ib = ib\n        self.queue = deque()\n        self.max_per_second = max_per_second\n        self.running = False\n        \n    def add(self, func, *args, **kwargs):\n        \"\"\"Add request to queue\"\"\"\n        self.queue.append((func, args, kwargs))\n    \n    def start(self):\n        \"\"\"Start processing queue\"\"\"\n        self.running = True\n        thread = threading.Thread(target=self._process)\n        thread.daemon = True\n        thread.start()\n    \n    def _process(self):\n        \"\"\"Process queue with rate limiting\"\"\"\n        delay = 1.0 / self.max_per_second\n        \n        while self.running:\n            if self.queue:\n                func, args, kwargs = self.queue.popleft()\n                \n                try:\n                    func(*args, **kwargs)\n                except Exception as e:\n                    logging.error(f\"Request failed: {e}\")\n                \n                time.sleep(delay)\n            else:\n                time.sleep(0.1)\n    \n    def stop(self):\n        \"\"\"Stop processing\"\"\"\n        self.running = False\n\n# Usage\nqueue = RequestQueue(ib, max_per_second=40)\nqueue.start()\n\n# Queue many requests\nfor contract in large_contract_list:\n    queue.add(ib.reqMktData, contract, '', False, False)","language":"python","description":" Request Queue Manager"},"stats":{"mentions":1,"sources":["ex_0185_3be9f3a2"]}},{"id":"merged_ex_0186_740a3bd3","topic":" Complete Production Trading System Template","tier":"a2","confidence":1.0,"tags":["co","ct","er","vnt","or","prt"],"content":{"code":"\"\"\"\nProduction Trading System Template\nFeatures: Auto-reconnect, error handling, risk management, logging\n\"\"\"\n\nimport logging\nfrom datetime import datetime, time as dt_time\nfrom ib_insync import *\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s',\n    handlers=[\n        logging.FileHandler(f'trading_{datetime.now().strftime(\"%Y%m%d\")}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass ProductionTradingSystem:\n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self.ib = None\n        self.running = False\n        \n        # Risk parameters\n        self.max_daily_loss_pct = 0.03\n        self.max_position_pct = 0.20\n        self.daily_loss_breached = False\n        \n        # State tracking\n        self.start_equity = 0\n        self.trades_today = []\n        \n    def initialize(self):\n        \"\"\"Initialize system\"\"\"\n        logging.info(\"Initializing trading system...\")\n        \n        # Connect\n        self.ib = IB()\n        self.ib.errorEvent += self.on_error\n        self.ib.disconnectedEvent += self.on_disconnect\n        \n        try:\n            self.ib.connect(self.host, self.port, self.client_id, timeout=10)\n            logging.info(\"Connected to TWS\")\n        except Exception as e:\n            logging.critical(f\"Failed to connect: {e}\")\n            return False\n        \n        # Get starting equity\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        logging.info(f\"Starting equity: ${self.start_equity:,.2f}\")\n        \n        # Setup event handlers\n        self.ib.orderStatusEvent += self.on_order_status\n        self.ib.execDetailsEvent += self.on_execution\n        \n        return True\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle errors\"\"\"\n        if errorCode in [502, 503, 504]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n        elif errorCode >= 2000:\n            # Warnings\n            logging.warning(f\"Warning {errorCode}: {errorString}\")\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        logging.warning(\"Disconnected from TWS\")\n        # Attempt reconnection logic here\n    \n    def on_order_status(self, trade):\n        \"\"\"Track order status\"\"\"\n        logging.info(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    \n    def on_execution(self, trade, fill):\n        \"\"\"Track executions\"\"\"\n        self.trades_today.append(trade)\n        logging.info(f\"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}\")\n    \n    def check_risk_limits(self):\n        \"\"\"Check if risk limits breached\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        # Daily loss check\n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%\")\n            self.daily_loss_breached = True\n            self.emergency_shutdown()\n            return False\n        \n        return True\n    \n    def emergency_shutdown(self):\n        \"\"\"Emergency shutdown - close all positions\"\"\"\n        logging.critical(\"EMERGENCY SHUTDOWN INITIATED\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        for position in self.ib.positions():\n            qty = abs(position.position)\n            action = 'SELL' if position.position > 0 else 'BUY'\n            \n            order = MarketOrder(action, qty)\n            self.ib.placeOrder(position.contract, order)\n            \n            logging.info(f\"Emergency close: {action} {qty} {position.contract.symbol}\")\n        \n        self.running = False\n    \n    def is_market_hours(self):\n        \"\"\"Check if within trading hours\"\"\"\n        now = datetime.now().time()\n        market_open = dt_time(9, 30)\n        market_close = dt_time(16, 0)\n        \n        return market_open <= now <= market_close\n    \n    def run(self):\n        \"\"\"Main trading loop\"\"\"\n        if not self.initialize():\n            return\n        \n        self.running = True\n        logging.info(\"Trading system started\")\n        \n        try:\n            while self.running:\n                # Check risk limits\n                if not self.check_risk_limits():\n                    break\n                \n                # Only trade during market hours\n                if self.is_market_hours():\n                    # Your trading logic here\n                    self.trading_logic()\n                \n                # Sleep between iterations\n                self.ib.sleep(60)  # Check every minute\n                \n        except KeyboardInterrupt:\n            logging.info(\"Shutdown requested by user\")\n        except Exception as e:\n            logging.critical(f\"Unexpected error: {e}\")\n        finally:\n            self.shutdown()\n    \n    def trading_logic(self):\n        \"\"\"Implement your trading strategy here\"\"\"\n        pass\n    \n    def shutdown(self):\n        \"\"\"Graceful shutdown\"\"\"\n        logging.info(\"Shutting down trading system...\")\n        \n        if self.ib:\n            # Cancel all market data\n            for contract in [t.contract for t in self.ib.tickers()]:\n                self.ib.cancelMktData(contract)\n            \n            # Disconnect\n            self.ib.disconnect()\n        \n        logging.info(\"Shutdown complete\")\n\n# Run the system\nif __name__ == '__main__':\n    system = ProductionTradingSystem(\n        host='127.0.0.1',\n        port=7497,\n        client_id=1\n    )\n    system.run()","language":"python","description":" Complete Production Trading System Template"},"stats":{"mentions":1,"sources":["ex_0186_740a3bd3"]}},{"id":"merged_ex_0187_9c1600a8","topic":" Minimal Example","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"from ib_insync import *\n\n# Jupyter notebook? Uncomment:\n# util.startLoop()\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Get account info\naccount = ib.managedAccounts()[0]\nprint(f\"Connected to account: {account}\")\n\n# Create contract\ncontract = Stock('AAPL', 'SMART', 'USD')\n\n# Get market data\nticker = ib.reqMktData(contract)\nib.sleep(2)  # Wait for data\nprint(ticker.marketPrice())\n\nib.disconnect()","language":"python","description":" Minimal Example"},"stats":{"mentions":1,"sources":["ex_0187_9c1600a8"]}},{"id":"merged_ex_0188_8e7796b2","topic":" Class Definition","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"class IB:\n    \"\"\"High-level interface to Interactive Brokers\"\"\"","language":"python","description":" Class Definition"},"stats":{"mentions":1,"sources":["ex_0188_8e7796b2"]}},{"id":"merged_ex_0189_91b1ed12","topic":" Class Attributes","tier":"a2","confidence":1.0,"tags":["er"],"content":{"code":"RequestTimeout: float = 0        # Request timeout (0 = infinite)\nRaiseRequestErrors: bool = False # Raise errors vs silent fail\nMaxSyncedSubAccounts: int = 50   # Max sub-accounts to sync","language":"python","description":" Class Attributes"},"stats":{"mentions":1,"sources":["ex_0189_91b1ed12"]}},{"id":"merged_ex_0190_1da11b26","topic":" Events","tier":"a2","confidence":1.0,"tags":["co","er","vnt","or","prt"],"content":{"code":"events = (\n    'connectedEvent',       # Connection established\n    'disconnectedEvent',    # Connection lost\n    'updateEvent',          # Any state update\n    'pendingTickersEvent',  # Ticker updates available\n    'barUpdateEvent',       # Real-time bar update\n    'newOrderEvent',        # New order created\n    'orderModifyEvent',     # Order modified\n    'cancelOrderEvent',     # Order cancel requested\n    'openOrderEvent',       # Open order status\n    'orderStatusEvent',     # Order status changed\n    'execDetailsEvent',     # Trade execution details\n    'commissionReportEvent',# Commission report\n    'updatePortfolioEvent', # Portfolio updated\n    'positionEvent',        # Position changed\n    'accountValueEvent',    # Account value updated\n    'accountSummaryEvent',  # Account summary updated\n    'pnlEvent',            # PnL update\n    'pnlSingleEvent',      # Single position PnL\n    'scannerDataEvent',    # Scanner data received\n    'tickNewsEvent',       # News tick\n    'newsBulletinEvent',   # News bulletin\n    'errorEvent',          # Error occurred\n    'timeoutEvent'         # Request timeout\n)","language":"python","description":" Events"},"stats":{"mentions":1,"sources":["ex_0190_1da11b26"]}},{"id":"merged_ex_0191_a0a2d809","topic":" State Properties","tier":"a2","confidence":1.0,"tags":["or","prt"],"content":{"code":"# Access current state (auto-synced)\nib.accountValues()      # List[AccountValue]\nib.portfolio()          # List[PortfolioItem]\nib.positions()          # List[Position]\nib.trades()             # List[Trade]\nib.openTrades()         # List[Trade] - open only\nib.orders()             # List[Order]\nib.openOrders()         # List[Order] - open only\nib.fills()              # List[Fill]\nib.executions()         # List[Execution]\nib.tickers()            # List[Ticker]\nib.pendingTickers()     # Set[Ticker] - with updates\nib.reqId()              # int - next request ID","language":"python","description":" State Properties"},"stats":{"mentions":1,"sources":["ex_0191_a0a2d809"]}},{"id":"merged_ex_0192_1c37caad","topic":" Connect (Blocking)","tier":"a2","confidence":1.0,"tags":["co","er"],"content":{"code":"ib.connect(\n    host: str = '127.0.0.1',\n    port: int = 7497,           # 7497=TWS, 4001=Gateway\n    clientId: int = 1,          # Unique per connection\n    timeout: float = 2.0,       # Connection timeout (0=no limit)\n    readonly: bool = False,     # Read-only mode\n    account: str = '',          # Main account for updates\n    raiseSyncErrors: bool = True # Raise sync errors\n) -> None","language":"python","description":" Connect (Blocking)"},"stats":{"mentions":1,"sources":["ex_0192_1c37caad"]}},{"id":"merged_ex_0193_8372747c","topic":" Connect (Async)","tier":"a2","confidence":1.0,"tags":["as","co","er"],"content":{"code":"await ib.connectAsync(\n    host, port, clientId, \n    timeout, readonly, account, raiseSyncErrors\n) -> None","language":"python","description":" Connect (Async)"},"stats":{"mentions":1,"sources":["ex_0193_8372747c"]}},{"id":"merged_ex_0194_217875f9","topic":" Disconnect","tier":"a2","confidence":1.0,"tags":["co"],"content":{"code":"ib.disconnect() -> None","language":"python","description":" Disconnect"},"stats":{"mentions":1,"sources":["ex_0194_217875f9"]}},{"id":"merged_ex_0195_8e8c97f7","topic":" Check Connection","tier":"a2","confidence":1.0,"tags":["co"],"content":{"code":"ib.isConnected() -> bool\nib.client.isReady() -> bool  # API ready","language":"python","description":" Check Connection"},"stats":{"mentions":1,"sources":["ex_0195_8e8c97f7"]}},{"id":"merged_ex_0196_6af2e413","topic":" Wait & Sleep","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"ib.waitOnUpdate(timeout: float = 0) -> bool\n# Wait for network update. Returns False on timeout.\n\nib.sleep(seconds: float = 0.02) -> None\n# Sleep while keeping event loop alive\n# ALWAYS use this instead of time.sleep()","language":"python","description":" Wait & Sleep"},"stats":{"mentions":1,"sources":["ex_0196_6af2e413"]}},{"id":"merged_ex_0197_5d3a8df7","topic":" Loop Management","tier":"a2","confidence":1.0,"tags":["as","co"],"content":{"code":"ib.run()  # Run until disconnect\nawait ib.runAsync()  # Async version\n\n# Condition-based iteration\nfor update in ib.loopUntil(timeout=60):\n    if condition:\n        break","language":"python","description":" Loop Management"},"stats":{"mentions":1,"sources":["ex_0197_5d3a8df7"]}},{"id":"merged_ex_0198_021797a7","topic":" Base Contract","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"@dataclass\nclass Contract:\n    conId: int = 0              # Unique IB contract ID\n    symbol: str = ''            # Ticker symbol\n    secType: str = ''           # Security type\n    lastTradeDateOrContractMonth: str = ''\n    strike: float = 0.0\n    right: str = ''             # 'C' or 'P' for options\n    multiplier: str = ''\n    exchange: str = ''\n    primaryExchange: str = ''\n    currency: str = ''\n    localSymbol: str = ''\n    tradingClass: str = ''\n    includeExpired: bool = False\n    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC\n    secId: str = ''\n    description: str = ''\n    issuerId: str = ''\n    comboLegsDescrip: str = ''\n    comboLegs: List = None      # For combo orders\n    deltaNeutralContract: DeltaNeutralContract = None","language":"python","description":" Base Contract"},"stats":{"mentions":1,"sources":["ex_0198_021797a7"]}},{"id":"merged_ex_0199_47b23e16","topic":" Stock","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"Stock(\n    symbol: str,\n    exchange: str = 'SMART',\n    currency: str = 'USD',\n    primaryExchange: str = ''\n)\n\n# Examples\nStock('AAPL', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nStock('BMW', 'SMART', 'EUR', primaryExchange='IBIS')","language":"python","description":" Stock"},"stats":{"mentions":1,"sources":["ex_0199_47b23e16"]}},{"id":"merged_ex_0200_ac6252b4","topic":" Forex","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"Forex(pair: str = 'EURUSD', exchange: str = 'IDEALPRO')\n\n# Examples\nForex('EURUSD')\nForex('GBPUSD')","language":"python","description":" Forex"},"stats":{"mentions":1,"sources":["ex_0200_ac6252b4"]}},{"id":"merged_ex_0201_30a355c3","topic":" Future","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"Future(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nFuture('ES', '20240920', 'GLOBEX')  # E-mini S&P\nFuture('CL', '202412', 'NYMEX')     # Crude Oil","language":"python","description":" Future"},"stats":{"mentions":1,"sources":["ex_0201_30a355c3"]}},{"id":"merged_ex_0202_8a148020","topic":" Option","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"Option(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    strike: float = 0.0,\n    right: str = '',            # 'C' or 'P'\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nOption('SPY', '20240920', 450, 'C', 'SMART')  # Call\nOption('AAPL', '20240315', 180, 'P', 'SMART') # Put","language":"python","description":" Option"},"stats":{"mentions":1,"sources":["ex_0202_8a148020"]}},{"id":"merged_ex_0203_d49a58bb","topic":" Index","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"Index(symbol: str = '', exchange: str = '')\n\n# Examples\nIndex('SPX', 'CBOE')\nIndex('VIX', 'CBOE')","language":"python","description":" Index"},"stats":{"mentions":1,"sources":["ex_0203_d49a58bb"]}},{"id":"merged_ex_0204_93b9ec89","topic":" CFD","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"CFD(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCFD('IBUS30')","language":"python","description":" CFD"},"stats":{"mentions":1,"sources":["ex_0204_93b9ec89"]}},{"id":"merged_ex_0205_203f5234","topic":" Commodity","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"Commodity(\n    symbol: str = '',\n    exchange: str = '',\n    currency: str = ''\n)\n\n# Example\nCommodity('XAUUSD', 'SMART', 'USD')","language":"python","description":" Commodity"},"stats":{"mentions":1,"sources":["ex_0205_203f5234"]}},{"id":"merged_ex_0206_bfa34fc6","topic":" Bond","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"Bond(secIdType: str = '', secId: str = '')\n\n# Example\nBond(secIdType='ISIN', secId='US03076KAA60')","language":"python","description":" Bond"},"stats":{"mentions":1,"sources":["ex_0206_bfa34fc6"]}},{"id":"merged_ex_0207_163692a6","topic":" Crypto","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"Crypto(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCrypto('BTC', 'PAXOS', 'USD')","language":"python","description":" Crypto"},"stats":{"mentions":1,"sources":["ex_0207_163692a6"]}},{"id":"merged_ex_0208_0ae96c65","topic":" Contract by conId","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"Contract(conId=270639)  # Direct lookup by IB contract ID","language":"python","description":" Contract by conId"},"stats":{"mentions":1,"sources":["ex_0208_0ae96c65"]}},{"id":"merged_ex_0209_d000a006","topic":" Qualify Contracts","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"# Resolve ambiguous contracts\ncontracts = ib.qualifyContracts(contract)\n# Returns list of fully qualified contracts\n\n# Example\nstock = Stock('AAPL', 'SMART', 'USD')\nqualified = ib.qualifyContracts(stock)[0]\nprint(qualified.conId)  # IB contract ID","language":"python","description":" Qualify Contracts"},"stats":{"mentions":1,"sources":["ex_0209_d000a006"]}},{"id":"merged_ex_0210_84bbd4a2","topic":" Contract Details","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"details = ib.reqContractDetails(contract)\n# Returns List[ContractDetails]\n\n# ContractDetails fields:\n# .contract - Fully qualified contract\n# .marketName\n# .minTick\n# .priceMagnifier\n# .orderTypes\n# .validExchanges\n# .underConId\n# .longName\n# .contractMonth\n# .industry\n# .category\n# .subcategory\n# .timeZoneId\n# .tradingHours\n# .liquidHours\n# And many more...","language":"python","description":" Contract Details"},"stats":{"mentions":1,"sources":["ex_0210_84bbd4a2"]}},{"id":"merged_ex_0211_0a67635a","topic":" Match Symbols","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"descriptions = ib.reqMatchingSymbols('app')\n# Returns List[ContractDescription]\n# Fuzzy search for symbols","language":"python","description":" Match Symbols"},"stats":{"mentions":1,"sources":["ex_0211_0a67635a"]}},{"id":"merged_ex_0212_944e293c","topic":" Base Order","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"@dataclass\nclass Order:\n    orderId: int = 0\n    clientId: int = 0\n    permId: int = 0\n    action: str = ''            # 'BUY' or 'SELL'\n    totalQuantity: float = 0.0\n    orderType: str = ''         # See order types below\n    lmtPrice: float = 0.0\n    auxPrice: float = 0.0       # Stop price\n    tif: str = 'DAY'            # Time in force\n    \n    # Advanced fields\n    ocaGroup: str = ''          # One-Cancels-All group\n    account: str = ''\n    openClose: str = 'O'        # 'O'=open, 'C'=close\n    origin: int = 0             # 0=customer\n    orderRef: str = ''\n    transmit: bool = True       # Auto-transmit\n    parentId: int = 0           # For bracket orders\n    blockOrder: bool = False\n    sweepToFill: bool = False\n    displaySize: int = 0\n    triggerMethod: int = 0\n    outsideRth: bool = False    # Outside regular hours\n    hidden: bool = False\n    \n    # Order combos\n    goodAfterTime: str = ''\n    goodTillDate: str = ''\n    rule80A: str = ''\n    allOrNone: bool = False\n    minQty: int = None\n    percentOffset: float = None\n    overridePercentageConstraints: bool = False\n    trailStopPrice: float = None\n    trailingPercent: float = None\n    \n    # Financial advisors\n    faGroup: str = ''\n    faProfile: str = ''\n    faMethod: str = ''\n    faPercentage: str = ''\n    \n    # Institutional\n    designatedLocation: str = ''\n    exemptCode: int = -1\n    \n    # Smart routing\n    discretionaryAmt: float = 0.0\n    eTradeOnly: bool = False\n    firmQuoteOnly: bool = False\n    nbboPriceCap: float = None\n    optOutSmartRouting: bool = False\n    \n    # Pegged orders\n    stockRefPrice: float = None\n    delta: float = None\n    \n    # Volatility orders\n    volatility: float = None\n    volatilityType: int = None\n    deltaNeutralOrderType: str = ''\n    deltaNeutralAuxPrice: float = None\n    deltaNeutralConId: int = 0\n    deltaNeutralShortSale: bool = False\n    deltaNeutralShortSaleSlot: int = 0\n    deltaNeutralDesignatedLocation: str = ''\n    continuousUpdate: bool = False\n    referencePriceType: int = None\n    \n    # Conditions\n    conditions: List = None\n    conditionsIgnoreRth: bool = False\n    conditionsCancelOrder: bool = False\n    \n    # Algo orders\n    algoStrategy: str = ''\n    algoParams: List = None\n    \n    # What-if\n    whatIf: bool = False\n    \n    # Misc\n    notHeld: bool = False\n    solicited: bool = False\n    randomizeSize: bool = False\n    randomizePrice: bool = False\n    \n    # Pegged to benchmark\n    referenceContractId: int = 0\n    peggedChangeAmount: float = 0.0\n    isPeggedChangeAmountDecrease: bool = False\n    referenceChangeAmount: float = 0.0\n    referenceExchangeId: str = ''\n    adjustedOrderType: str = ''\n    \n    # Misc2\n    modelCode: str = ''\n    extOperator: str = ''\n    cashQty: float = None\n    mifid2DecisionMaker: str = ''\n    mifid2DecisionAlgo: str = ''\n    mifid2ExecutionTrader: str = ''\n    mifid2ExecutionAlgo: str = ''\n    dontUseAutoPriceForHedge: bool = False\n    \n    # Manual times (for audit)\n    manualOrderTime: str = ''\n    manualOrderCancelTime: str = ''\n    \n    # Post to ATS\n    usePriceMgmtAlgo: bool = None","language":"python","description":" Base Order"},"stats":{"mentions":1,"sources":["ex_0212_944e293c"]}},{"id":"merged_ex_0213_59eaafe2","topic":" Market Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"MarketOrder(action: str, totalQuantity: float, **kwargs)\n\n# Examples\norder = MarketOrder('BUY', 100)\norder = MarketOrder('SELL', 50, tif='GTC')","language":"python","description":" Market Order"},"stats":{"mentions":1,"sources":["ex_0213_59eaafe2"]}},{"id":"merged_ex_0214_436ee625","topic":" Limit Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"LimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    **kwargs\n)\n\n# Examples\norder = LimitOrder('BUY', 100, 150.50)\norder = LimitOrder('SELL', 50, 155.00, tif='GTC')","language":"python","description":" Limit Order"},"stats":{"mentions":1,"sources":["ex_0214_436ee625"]}},{"id":"merged_ex_0217_b9979312","topic":" Bracket Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"BracketOrder(\n    action: str,\n    quantity: float,\n    limitPrice: float,\n    takeProfitPrice: float,\n    stopLossPrice: float\n) -> Tuple[Order, Order, Order]\n\n# Returns (parent, takeProfit, stopLoss)\n# Example\nparent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0, 160.0, 145.0\n)","language":"python","description":" Bracket Order"},"stats":{"mentions":1,"sources":["ex_0217_b9979312"]}},{"id":"merged_ex_0218_da330b8a","topic":" Place Order","tier":"a2","confidence":1.0,"tags":["ct","or"],"content":{"code":"trade = ib.placeOrder(contract: Contract, order: Order) -> Trade\n# Returns Trade object (live-updated)\n\n# Example\ncontract = Stock('AAPL', 'SMART', 'USD')\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# Trade object updated in real-time:\n# - trade.orderStatus\n# - trade.fills\n# - trade.log","language":"python","description":" Place Order"},"stats":{"mentions":1,"sources":["ex_0218_da330b8a"]}},{"id":"merged_ex_0220_af1ad75f","topic":" Cancel Order","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"trade = ib.cancelOrder(order: Order) -> Trade\n\n# Cancel all orders\nib.reqGlobalCancel()","language":"python","description":" Cancel Order"},"stats":{"mentions":1,"sources":["ex_0220_af1ad75f"]}},{"id":"merged_ex_0221_39d68f86","topic":" Order Status","tier":"a2","confidence":1.0,"tags":["or"],"content":{"code":"@dataclass\nclass OrderStatus:\n    orderId: int = 0\n    status: str = ''        # PendingSubmit, Submitted, Filled, Cancelled, etc.\n    filled: float = 0.0\n    remaining: float = 0.0\n    avgFillPrice: float = 0.0\n    permId: int = 0\n    parentId: int = 0\n    lastFillPrice: float = 0.0\n    clientId: int = 0\n    whyHeld: str = ''\n    mktCapPrice: float = 0.0","language":"python","description":" Order Status"},"stats":{"mentions":1,"sources":["ex_0221_39d68f86"]}},{"id":"merged_ex_0222_3d080260","topic":" Trade Object","tier":"a2","confidence":1.0,"tags":["ct","er","or"],"content":{"code":"@dataclass\nclass Trade:\n    contract: Contract = None\n    order: Order = None\n    orderStatus: OrderStatus = None\n    fills: List[Fill] = []\n    log: List[TradeLogEntry] = []\n    \n    # Methods\n    def isActive(self) -> bool\n    def isDone(self) -> bool\n    def filled(self) -> float\n    def remaining(self) -> float","language":"python","description":" Trade Object"},"stats":{"mentions":1,"sources":["ex_0222_3d080260"]}},{"id":"merged_ex_0224_acebfcb7","topic":" Request Market Data (Streaming)","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"ticker = ib.reqMktData(\n    contract: Contract,\n    genericTickList: str = '',\n    snapshot: bool = False,\n    regulatorySnapshot: bool = False,\n    mktDataOptions: List = None\n) -> Ticker\n\n# Ticker auto-updates in real-time","language":"python","description":" Request Market Data (Streaming)"},"stats":{"mentions":1,"sources":["ex_0224_acebfcb7"]}},{"id":"merged_ex_0225_73bbdf10","topic":"Generic Tick List IDs:","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"100 - putVolume, callVolume (options)\n101 - putOpenInterest, callOpenInterest (options)\n104 - histVolatility (options)\n105 - avOptionVolume (options)\n106 - impliedVolatility (options)\n162 - indexFuturePremium\n165 - low13week, high13week, low26week, high26week,\n      low52week, high52week, avVolume\n221 - markPrice\n225 - auctionVolume, auctionPrice, auctionImbalance\n233 - last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 - shortableShares\n258 - fundamentalRatios","language":"python","description":"Generic Tick List IDs:"},"stats":{"mentions":1,"sources":["ex_0225_73bbdf10"]}},{"id":"merged_ex_0226_109839aa","topic":"Example:","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract, genericTickList='233,236')\nib.sleep(2)\nprint(f\"Last: {ticker.last}\")\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Volume: {ticker.volume}\")","language":"python","description":"Example:"},"stats":{"mentions":1,"sources":["ex_0226_109839aa"]}},{"id":"merged_ex_0228_df91b679","topic":" Ticker Object","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"@dataclass\nclass Ticker:\n    contract: Contract = None\n    time: datetime = None\n    \n    # Bid/Ask\n    bid: float = nan\n    bidSize: float = nan\n    bidExchange: str = ''\n    ask: float = nan\n    askSize: float = nan\n    askExchange: str = ''\n    \n    # Last trade\n    last: float = nan\n    lastSize: float = nan\n    lastExchange: str = ''\n    \n    # Volume\n    volume: float = nan\n    volumeRate: float = nan\n    \n    # Prices\n    open: float = nan\n    high: float = nan\n    low: float = nan\n    close: float = nan\n    vwap: float = nan\n    \n    # Options\n    putVolume: float = nan\n    callVolume: float = nan\n    putOpenInterest: float = nan\n    callOpenInterest: float = nan\n    avOptionVolume: float = nan\n    impliedVolatility: float = nan\n    histVolatility: float = nan\n    \n    # Greeks (options)\n    delta: float = nan\n    gamma: float = nan\n    theta: float = nan\n    vega: float = nan\n    \n    # Market depth\n    domBids: List = []\n    domAsks: List = []\n    domTicks: List = []\n    \n    # Ticks\n    ticks: List = []\n    tickByTicks: List = []\n    \n    # Halted\n    halted: float = nan\n    \n    # Real-time\n    rtVolume: float = nan\n    rtTime: datetime = None\n    rtHistVolativity: float = nan\n    rtTradeVolume: float = nan\n    \n    # Methods\n    def marketPrice(self) -> float\n    def hasBidAsk(self) -> bool\n    def midpoint(self) -> float","language":"python","description":" Ticker Object"},"stats":{"mentions":1,"sources":["ex_0228_df91b679"]}},{"id":"merged_ex_0229_ad978f61","topic":" Market Depth (Level II)","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ticker = ib.reqMktDepth(\n    contract: Contract,\n    numRows: int = 5,\n    isSmartDepth: bool = False,\n    mktDepthOptions: List = None\n) -> Ticker\n\n# Ticker.domBids and Ticker.domAsks auto-update","language":"python","description":" Market Depth (Level II)"},"stats":{"mentions":1,"sources":["ex_0229_ad978f61"]}},{"id":"merged_ex_0231_1f886e3e","topic":" Tick-by-Tick Data","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ticker = ib.reqTickByTickData(\n    contract: Contract,\n    tickType: str,  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks: int = 0,\n    ignoreSize: bool = False\n) -> Ticker\n\n# Ticker.tickByTicks auto-updates","language":"python","description":" Tick-by-Tick Data"},"stats":{"mentions":1,"sources":["ex_0231_1f886e3e"]}},{"id":"merged_ex_0232_eea923a8","topic":" Market Data Type","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"ib.reqMarketDataType(marketDataType: int) -> None\n# 1 = Live\n# 2 = Frozen\n# 3 = Delayed\n# 4 = Delayed-Frozen","language":"python","description":" Market Data Type"},"stats":{"mentions":1,"sources":["ex_0232_eea923a8"]}},{"id":"merged_ex_0233_443b62c5","topic":" Request Historical Data","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"bars = ib.reqHistoricalData(\n    contract: Contract,\n    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'\n    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'\n    barSizeSetting: str = '1 hour',\n    whatToShow: str = 'TRADES', # See below\n    useRTH: bool = True,        # Regular trading hours only\n    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch\n    keepUpToDate: bool = False, # Auto-update\n    chartOptions: List = None,\n    timeout: float = 60\n) -> BarDataList\n\n# Returns BarDataList (auto-synced if keepUpToDate=True)","language":"python","description":" Request Historical Data"},"stats":{"mentions":1,"sources":["ex_0233_443b62c5"]}},{"id":"merged_ex_0234_5c6e682d","topic":"Duration Strings:","tier":"a2","confidence":1.0,"tags":["da"],"content":{"code":"S = Seconds (max 60)\nD = Days (max 365)\nW = Weeks (max 52)\nM = Months (max 12)\nY = Years (max 1)","language":"python","description":"Duration Strings:"},"stats":{"mentions":1,"sources":["ex_0234_5c6e682d"]}},{"id":"merged_ex_0235_43901f2a","topic":"Bar Sizes:","tier":"a2","confidence":1.0,"tags":["da"],"content":{"code":"'1 secs', '5 secs', '10 secs', '15 secs', '30 secs',\n'1 min', '2 mins', '3 mins', '5 mins', '10 mins', '15 mins', '20 mins', '30 mins',\n'1 hour', '2 hours', '3 hours', '4 hours', '8 hours',\n'1 day', '1 week', '1 month'","language":"python","description":"Bar Sizes:"},"stats":{"mentions":1,"sources":["ex_0235_43901f2a"]}},{"id":"merged_ex_0236_612914ff","topic":"What to Show:","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"'TRADES'           - Actual trades\n'MIDPOINT'         - Bid/ask midpoint\n'BID'              - Bid prices\n'ASK'              - Ask prices\n'BID_ASK'          - Bid/ask pairs\n'HISTORICAL_VOLATILITY'\n'OPTION_IMPLIED_VOLATILITY'\n'REBATE_RATE'\n'FEE_RATE'\n'YIELD_BID'\n'YIELD_ASK'\n'YIELD_BID_ASK'\n'YIELD_LAST'","language":"python","description":"What to Show:"},"stats":{"mentions":1,"sources":["ex_0236_612914ff"]}},{"id":"merged_ex_0238_11491458","topic":" Bar Object","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"@dataclass\nclass Bar:\n    date: datetime\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    average: float\n    barCount: int","language":"python","description":" Bar Object"},"stats":{"mentions":1,"sources":["ex_0238_11491458"]}},{"id":"merged_ex_0239_d5adc6d3","topic":" Historical Ticks","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"ticks = ib.reqHistoricalTicks(\n    contract: Contract,\n    startDateTime: str,\n    endDateTime: str,\n    numberOfTicks: int = 1000,\n    whatToShow: str = 'TRADES',  # 'TRADES', 'BID_ASK', 'MIDPOINT'\n    useRth: bool = True,\n    ignoreSize: bool = False,\n    miscOptions: List = None\n) -> List\n\n# Returns list of HistoricalTick objects","language":"python","description":" Historical Ticks"},"stats":{"mentions":1,"sources":["ex_0239_d5adc6d3"]}},{"id":"merged_ex_0240_38b77bc7","topic":" Head Timestamp","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"headTimestamp = ib.reqHeadTimeStamp(\n    contract: Contract,\n    whatToShow: str = 'TRADES',\n    useRTH: bool = True,\n    formatDate: int = 1\n) -> str\n\n# Earliest available data timestamp","language":"python","description":" Head Timestamp"},"stats":{"mentions":1,"sources":["ex_0240_38b77bc7"]}},{"id":"merged_ex_0241_a43bc6b4","topic":" Historical Schedule","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"schedule = ib.reqHistoricalSchedule(\n    contract: Contract,\n    numDays: int = 1,\n    endDateTime: str = '',\n    useRTH: bool = True\n) -> List[HistoricalSchedule]\n\n# Trading schedule for contract","language":"python","description":" Historical Schedule"},"stats":{"mentions":1,"sources":["ex_0241_a43bc6b4"]}},{"id":"merged_ex_0242_62ca894c","topic":" Real-Time Bars","tier":"a2","confidence":1.0,"tags":["ct","vnt"],"content":{"code":"bars = ib.reqRealTimeBars(\n    contract: Contract,\n    barSize: int = 5,           # Only 5 supported\n    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK\n    useRTH: bool = False,\n    realTimeBarsOptions: List = None\n) -> RealTimeBarList\n\n# Returns RealTimeBarList (auto-updating)\n# bars.updateEvent fires on new bar","language":"python","description":" Real-Time Bars"},"stats":{"mentions":1,"sources":["ex_0242_62ca894c"]}},{"id":"merged_ex_0243_0587e2fb","topic":" Cancel Real-Time Bars","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"ib.cancelRealTimeBars(bars: RealTimeBarList) -> None","language":"python","description":" Cancel Real-Time Bars"},"stats":{"mentions":1,"sources":["ex_0243_0587e2fb"]}},{"id":"merged_ex_0245_21f82c32","topic":" Managed Accounts","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"accounts = ib.managedAccounts() -> List[str]\n# List of account codes","language":"python","description":" Managed Accounts"},"stats":{"mentions":1,"sources":["ex_0245_21f82c32"]}},{"id":"merged_ex_0246_af6a41c6","topic":" Account Values","tier":"a2","confidence":1.0,"tags":["prt"],"content":{"code":"values = ib.accountValues(account: str = '') -> List[AccountValue]\n\n# AccountValue fields:\n# .account\n# .tag      - Key name (e.g., 'NetLiquidation')\n# .value    - Value as string\n# .currency\n# .modelCode","language":"python","description":" Account Values"},"stats":{"mentions":1,"sources":["ex_0246_af6a41c6"]}},{"id":"merged_ex_0247_c0af1b5a","topic":"Common Tags:","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"NetLiquidation      - Total account value\nTotalCashValue      - Cash balance\nSettledCash         - Settled cash\nAccruedCash         - Accrued cash\nBuyingPower         - Buying power\nEquityWithLoanValue - Stock value + cash\nGrossPositionValue  - Total position value\nRegTEquity          - RegT equity\nRegTMargin          - RegT margin\nSMA                 - Special Memo Account\nInitMarginReq       - Initial margin\nMaintMarginReq      - Maintenance margin\nAvailableFunds      - Available funds\nExcessLiquidity     - Excess liquidity","language":"python","description":"Common Tags:"},"stats":{"mentions":1,"sources":["ex_0247_c0af1b5a"]}},{"id":"merged_ex_0248_23c41848","topic":" Account Summary","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"summary = ib.reqAccountSummary() -> List[AccountValue]\n# Summary for all accounts\n\n# Or filter by tags\nsummary = ib.reqAccountSummary(\n    account: str = 'All',\n    modelCode: str = '',\n    tags: str = 'NetLiquidation,TotalCashValue,BuyingPower'\n)","language":"python","description":" Account Summary"},"stats":{"mentions":1,"sources":["ex_0248_23c41848"]}},{"id":"merged_ex_0249_f664de43","topic":" Portfolio","tier":"a2","confidence":1.0,"tags":["ct","prt"],"content":{"code":"portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]\n\n# PortfolioItem fields:\n# .contract\n# .position        - Quantity\n# .marketPrice     - Current price\n# .marketValue     - Position value\n# .averageCost     - Avg cost basis\n# .unrealizedPNL   - Unrealized P&L\n# .realizedPNL     - Realized P&L\n# .account","language":"python","description":" Portfolio"},"stats":{"mentions":1,"sources":["ex_0249_f664de43"]}},{"id":"merged_ex_0250_af167094","topic":" Positions","tier":"a2","confidence":1.0,"tags":["ct","prt"],"content":{"code":"positions = ib.positions(account: str = '') -> List[Position]\n\n# Position fields:\n# .account\n# .contract\n# .position       - Quantity\n# .avgCost        - Average cost","language":"python","description":" Positions"},"stats":{"mentions":1,"sources":["ex_0250_af167094"]}},{"id":"merged_ex_0251_fd03c5d2","topic":" PnL (Profit & Loss)","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"pnl = ib.reqPnL(account: str, modelCode: str = '') -> PnL\n# Start PnL subscription\n\n# PnL fields (live-updated):\n# .account\n# .modelCode\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n\n# Cancel\nib.cancelPnL(account: str, modelCode: str = '')","language":"python","description":" PnL (Profit & Loss)"},"stats":{"mentions":1,"sources":["ex_0251_fd03c5d2"]}},{"id":"merged_ex_0252_1a669c09","topic":" PnL Single Position","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"pnlSingle = ib.reqPnLSingle(\n    account: str,\n    modelCode: str,\n    conId: int\n) -> PnLSingle\n\n# PnLSingle fields (live-updated):\n# .account\n# .modelCode\n# .conId\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n# .position\n# .value\n\n# Cancel\nib.cancelPnLSingle(account, modelCode, conId)","language":"python","description":" PnL Single Position"},"stats":{"mentions":1,"sources":["ex_0252_1a669c09"]}},{"id":"merged_ex_0253_4e41919c","topic":" Event Handling","tier":"a2","confidence":1.0,"tags":["co","ct","vnt"],"content":{"code":"# Events use eventkit library\n\n# Subscribe to event\ndef onPendingTickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.marketPrice()}\")\n\nib.pendingTickersEvent += onPendingTickers\n\n# Unsubscribe\nib.pendingTickersEvent -= onPendingTickers\n\n# One-time handler\nib.connectedEvent += lambda: print('Connected!')","language":"python","description":" Event Handling"},"stats":{"mentions":1,"sources":["ex_0253_4e41919c"]}},{"id":"merged_ex_0254_d1dc505e","topic":" Trade Events","tier":"a2","confidence":1.0,"tags":["vnt","or"],"content":{"code":"# New order placed\nib.newOrderEvent += lambda trade: print(f'New order: {trade}')\n\n# Order modified\nib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')\n\n# Order status changed\nib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')\n\n# Execution received\nib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')\n\n# Commission report\nib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')","language":"python","description":" Trade Events"},"stats":{"mentions":1,"sources":["ex_0254_d1dc505e"]}},{"id":"merged_ex_0255_8775dd62","topic":" Market Data Events","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"# Ticker updates\nib.pendingTickersEvent += lambda tickers: handle_tickers(tickers)\n\n# Bar updates\nib.barUpdateEvent += lambda bars, hasNewBar: handle_bars(bars, hasNewBar)\n\n# Scanner data\nib.scannerDataEvent += lambda scanData: print(scanData)","language":"python","description":" Market Data Events"},"stats":{"mentions":1,"sources":["ex_0255_8775dd62"]}},{"id":"merged_ex_0256_d86ab109","topic":" Account Events","tier":"a2","confidence":1.0,"tags":["vnt","prt"],"content":{"code":"# Portfolio updates\nib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')\n\n# Position changes\nib.positionEvent += lambda position: print(f'Position: {position}')\n\n# Account value updates\nib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')\n\n# PnL updates\nib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')","language":"python","description":" Account Events"},"stats":{"mentions":1,"sources":["ex_0256_d86ab109"]}},{"id":"merged_ex_0257_81a00951","topic":" Connection Events","tier":"a2","confidence":1.0,"tags":["co","ct","er","vnt"],"content":{"code":"# Connected\nib.connectedEvent += lambda: print('Connected to TWS')\n\n# Disconnected\nib.disconnectedEvent += lambda: print('Disconnected')\n\n# Error\nib.errorEvent += lambda reqId, errorCode, errorString, contract: \\\n    print(f'Error {errorCode}: {errorString}')","language":"python","description":" Connection Events"},"stats":{"mentions":1,"sources":["ex_0257_81a00951"]}},{"id":"merged_ex_0258_28c76fef","topic":"Warnings (informational):","tier":"a2","confidence":1.0,"tags":["co","er"],"content":{"code":"2104 - Market data farm connection OK\n2106 - Historical data farm connection OK\n2158 - Sec-def data farm connection OK","language":"python","description":"Warnings (informational):"},"stats":{"mentions":1,"sources":["ex_0258_28c76fef"]}},{"id":"merged_ex_0259_e9e86cd9","topic":"Errors:","tier":"a2","confidence":1.0,"tags":["co","er","or"],"content":{"code":"200 - No security definition found\n201 - Order rejected\n202 - Order cancelled\n321 - Error validating request\n326 - Unable to connect (check port)\n354 - Requested market data not subscribed\n404 - Order held\n502 - Couldn't connect to TWS","language":"python","description":"Errors:"},"stats":{"mentions":1,"sources":["ex_0259_e9e86cd9"]}},{"id":"merged_ex_0260_9c708f65","topic":" Datetime Utilities","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"# Format for IB\nformatted = util.formatIBDatetime(dt: datetime) -> str\n# Returns: 'YYYYMMDD HH:MM:SS UTC'\n\n# Parse from IB\nparsed = util.parseIBDatetime(s: str) -> Union[date, datetime]","language":"python","description":" Datetime Utilities"},"stats":{"mentions":1,"sources":["ex_0260_9c708f65"]}},{"id":"merged_ex_0261_45f7dcb4","topic":" Dataframe Conversion","tier":"a2","confidence":1.0,"tags":["prt"],"content":{"code":"import pandas as pd\n\n# Bars to DataFrame\ndf = util.df(bars)\n\n# List of objects to DataFrame\ndf = util.df(ib.positions())\ndf = util.df(ib.accountValues())","language":"python","description":" Dataframe Conversion"},"stats":{"mentions":1,"sources":["ex_0261_45f7dcb4"]}},{"id":"merged_ex_0262_3d6ef144","topic":" Logging","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"# Log to console\nutil.logToConsole(level=logging.INFO)\n\n# Log to file\nutil.logToFile('ib_log.txt', level=logging.DEBUG)","language":"python","description":" Logging"},"stats":{"mentions":1,"sources":["ex_0262_3d6ef144"]}},{"id":"merged_ex_0263_1b93afa6","topic":" Jupyter Notebooks","tier":"a2","confidence":1.0,"tags":["as"],"content":{"code":"# At start of notebook\nutil.startLoop()\n\n# Or with old notebooks\nutil.patchAsyncio()","language":"python","description":" Jupyter Notebooks"},"stats":{"mentions":1,"sources":["ex_0263_1b93afa6"]}},{"id":"merged_ex_0264_083aaf30","topic":" Qt Integration","tier":"a2","confidence":1.0,"tags":["as","vnt"],"content":{"code":"util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'\n# Integrates asyncio with Qt event loop","language":"python","description":" Qt Integration"},"stats":{"mentions":1,"sources":["ex_0264_083aaf30"]}},{"id":"merged_ex_0265_53e6fadb","topic":" Schedule Periodic Tasks","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"def callback():\n    print('Periodic task')\n\n# Schedule every 60 seconds\nhandle = util.schedule(60, callback)\n\n# Cancel scheduled task\nhandle.cancel()","language":"python","description":" Schedule Periodic Tasks"},"stats":{"mentions":1,"sources":["ex_0265_53e6fadb"]}},{"id":"merged_ex_0266_fab63157","topic":" Time Range Iterator","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"# Iterate over time periods\nfor dt in util.timeRange(\n    start='20240101',\n    end='20240131',\n    step='1 day'\n):\n    print(dt)","language":"python","description":" Time Range Iterator"},"stats":{"mentions":1,"sources":["ex_0266_fab63157"]}},{"id":"merged_ex_0268_1fbd5182","topic":"\u2705 GOOD - Use streaming:","tier":"a2","confidence":1.0,"tags":["ct","da","vnt"],"content":{"code":"# For tick data\nticker = ib.reqMktData(contract, '233')  # Last, volume, vwap\nticker.updateEvent += lambda ticker: process_tick(ticker)\n\n# For bar data\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)","language":"python","description":"\u2705 GOOD - Use streaming:"},"stats":{"mentions":1,"sources":["ex_0268_1fbd5182"]}},{"id":"merged_ex_0269_4d249eb8","topic":"\u274c BAD:","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"time.sleep(5)  # Blocks event loop!","language":"python","description":"\u274c BAD:"},"stats":{"mentions":1,"sources":["ex_0269_4d249eb8"]}},{"id":"merged_ex_0270_c9bcedf6","topic":"\u2705 GOOD:","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"ib.sleep(5)  # Keeps event loop running","language":"python","description":"\u2705 GOOD:"},"stats":{"mentions":1,"sources":["ex_0270_c9bcedf6"]}},{"id":"merged_ex_0271_fda8a0c1","topic":"\u274c BAD - Ambiguous:","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)","language":"python","description":"\u274c BAD - Ambiguous:"},"stats":{"mentions":1,"sources":["ex_0271_fda8a0c1"]}},{"id":"merged_ex_0272_d4da6975","topic":"\u2705 GOOD - Qualified:","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"contract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\nticker = ib.reqMktData(contract)","language":"python","description":"\u2705 GOOD - Qualified:"},"stats":{"mentions":1,"sources":["ex_0272_d4da6975"]}},{"id":"merged_ex_0273_ee1d6f63","topic":"\u274c BAD - Polling:","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"while True:\n    if ticker.last > 150:\n        break\n    ib.sleep(0.1)","language":"python","description":"\u274c BAD - Polling:"},"stats":{"mentions":1,"sources":["ex_0273_ee1d6f63"]}},{"id":"merged_ex_0274_2dd7ade1","topic":"\u2705 GOOD - Event-driven:","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"def on_price_update(ticker):\n    if ticker.last > 150:\n        take_action()\n\nticker.updateEvent += on_price_update","language":"python","description":"\u2705 GOOD - Event-driven:"},"stats":{"mentions":1,"sources":["ex_0274_2dd7ade1"]}},{"id":"merged_ex_0275_0223f3f8","topic":"\u2705 GOOD:","tier":"a2","confidence":1.0,"tags":["ct","er","vnt"],"content":{"code":"def on_error(reqId, errorCode, errorString, contract):\n    if errorCode == 200:\n        print(f\"Contract not found: {contract}\")\n    elif errorCode == 321:\n        print(f\"Validation error: {errorString}\")\n    # Handle other errors...\n\nib.errorEvent += on_error","language":"python","description":"\u2705 GOOD:"},"stats":{"mentions":1,"sources":["ex_0275_0223f3f8"]}},{"id":"merged_ex_0276_35e97390","topic":"\u2705 GOOD:","tier":"a2","confidence":1.0,"tags":["co","ct","da","er"],"content":{"code":"try:\n    ticker = ib.reqMktData(contract)\n    # ... do work ...\nfinally:\n    ib.cancelMktData(contract)\n    ib.disconnect()","language":"python","description":"\u2705 GOOD:"},"stats":{"mentions":1,"sources":["ex_0276_35e97390"]}},{"id":"merged_ex_0277_e3d77231","topic":"\u2705 GOOD - Built-in throttling:","tier":"a2","confidence":1.0,"tags":["ct","da"],"content":{"code":"# ib-insync handles throttling automatically\nfor contract in large_list:\n    ib.reqMktData(contract)\n# No manual delays needed","language":"python","description":"\u2705 GOOD - Built-in throttling:"},"stats":{"mentions":1,"sources":["ex_0277_e3d77231"]}},{"id":"merged_ex_0279_792ef977","topic":"\u2705 GOOD:","tier":"a2","confidence":1.0,"tags":["co","vnt"],"content":{"code":"def on_disconnect():\n    print(\"Disconnected! Attempting reconnect...\")\n    reconnect_logic()\n\nib.disconnectedEvent += on_disconnect","language":"python","description":"\u2705 GOOD:"},"stats":{"mentions":1,"sources":["ex_0279_792ef977"]}},{"id":"merged_ex_0280_7ff23534","topic":"\u2705 GOOD:","tier":"a2","confidence":1.0,"tags":["as","co","er"],"content":{"code":"ib = IB()\nib.RequestTimeout = 30  # 30 second timeout\nib.RaiseRequestErrors = True  # Raise exceptions\n\ntry:\n    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)\nexcept asyncio.TimeoutError:\n    print(\"Connection timeout!\")","language":"python","description":"\u2705 GOOD:"},"stats":{"mentions":1,"sources":["ex_0280_7ff23534"]}},{"id":"merged_ex_0281_2484482f","topic":" Pattern: Live Ticker Monitor","tier":"a2","confidence":1.0,"tags":["co","ct","da","vnt"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        symbol = ticker.contract.symbol\n        price = ticker.marketPrice()\n        volume = ticker.volume\n        print(f\"{symbol}: ${price:.2f} | Vol: {volume}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract, '', False, False)\n\n# Run forever\nib.run()","language":"python","description":" Pattern: Live Ticker Monitor"},"stats":{"mentions":1,"sources":["ex_0281_2484482f"]}},{"id":"merged_ex_0282_2728ae87","topic":" Pattern: Real-Time Bar Processing","tier":"a2","confidence":1.0,"tags":["co","ct","vnt"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\ncontract = ib.qualifyContracts(contract)[0]\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += on_bar_update\n\nib.run()","language":"python","description":" Pattern: Real-Time Bar Processing"},"stats":{"mentions":1,"sources":["ex_0282_2728ae87"]}},{"id":"merged_ex_0283_bdce8c76","topic":" Pattern: Automated Trading Strategy","tier":"a2","confidence":1.0,"tags":["co","ct","da","er","vnt","or"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Strategy parameters\nquantity = 100\nentry_price = None\nposition = 0\n\ndef on_tick(ticker):\n    global entry_price, position\n    price = ticker.last\n    \n    if price is None or price != price:  # NaN check\n        return\n    \n    # Entry logic\n    if position == 0 and should_enter(price):\n        order = MarketOrder('BUY', quantity)\n        trade = ib.placeOrder(contract, order)\n        entry_price = price\n        position = quantity\n        print(f\"ENTRY: Buy {quantity} @ {price}\")\n    \n    # Exit logic\n    elif position > 0 and should_exit(price, entry_price):\n        order = MarketOrder('SELL', quantity)\n        trade = ib.placeOrder(contract, order)\n        profit = (price - entry_price) * quantity\n        print(f\"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}\")\n        position = 0\n        entry_price = None\n\ndef should_enter(price):\n    # Your entry logic\n    return False\n\ndef should_exit(price, entry):\n    # Your exit logic (e.g., stop loss, take profit)\n    return False\n\nticker = ib.reqMktData(contract, '233', False, False)\nticker.updateEvent += on_tick\n\nib.run()","language":"python","description":" Pattern: Automated Trading Strategy"},"stats":{"mentions":1,"sources":["ex_0283_bdce8c76"]}},{"id":"merged_ex_0284_51b7c018","topic":" Pattern: Historical Data Download","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"from ib_insync import *\nimport pandas as pd\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Download multiple timeframes\ntimeframes = [\n    ('1 Y', '1 day'),\n    ('6 M', '1 hour'),\n    ('30 D', '15 mins')\n]\n\nall_data = {}\nfor duration, barsize in timeframes:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=barsize,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    df = util.df(bars)\n    all_data[f'{duration}_{barsize}'] = df\n    print(f\"Downloaded {len(bars)} {barsize} bars for {duration}\")\n\n# Save to files\nfor name, df in all_data.items():\n    df.to_csv(f\"{contract.symbol}_{name}.csv\", index=False)\n\nib.disconnect()","language":"python","description":" Pattern: Historical Data Download"},"stats":{"mentions":1,"sources":["ex_0284_51b7c018"]}},{"id":"merged_ex_0285_a059ab35","topic":" Pattern: Portfolio Monitor","tier":"a2","confidence":1.0,"tags":["co","ct","vnt","prt"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef show_portfolio():\n    print(\"\\n=== PORTFOLIO ===\")\n    for item in ib.portfolio():\n        symbol = item.contract.symbol\n        pos = item.position\n        price = item.marketPrice\n        value = item.marketValue\n        pnl = item.unrealizedPNL\n        print(f\"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}\")\n    \n    print(\"\\n=== ACCOUNT ===\")\n    values = ib.accountValues()\n    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']\n    for value in values:\n        if value.tag in important_tags:\n            print(f\"{value.tag:20} | {value.value:15} {value.currency}\")\n\ndef on_update(item):\n    show_portfolio()\n\n# Show initial state\nshow_portfolio()\n\n# Update on changes\nib.updatePortfolioEvent += on_update\n\nib.run()","language":"python","description":" Pattern: Portfolio Monitor"},"stats":{"mentions":1,"sources":["ex_0285_a059ab35"]}},{"id":"merged_ex_0286_c1f31f77","topic":" Pattern: Option Chain Analysis","tier":"a2","confidence":1.0,"tags":["co","ct","da"],"content":{"code":"from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\n# Get option chain\nchains = ib.reqSecDefOptParams(\n    underlying.symbol,\n    '',\n    underlying.secType,\n    underlying.conId\n)\n\nprint(f\"Found {len(chains)} option chains\")\n\n# Get chain for specific exchange\nchain = next(c for c in chains if c.exchange == 'SMART')\nprint(f\"Trading class: {chain.tradingClass}\")\nprint(f\"Expirations: {sorted(chain.expirations)[:5]}\")  # First 5\nprint(f\"Strike range: {min(chain.strikes)} - {max(chain.strikes)}\")\n\n# Request contracts for specific expiration\nexpiration = sorted(chain.expirations)[0]\nstrikes = sorted([s for s in chain.strikes if 400 < s < 500])\n\ncontracts = [\n    Option('SPY', expiration, strike, right, 'SMART')\n    for strike in strikes[:5]\n    for right in ['C', 'P']\n]\n\n# Qualify and get details\ncontracts = ib.qualifyContracts(*contracts)\n\n# Request market data\nfor contract in contracts:\n    ticker = ib.reqMktData(contract, '', False, False)\n    ib.sleep(1)\n    print(f\"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}\")\n\nib.disconnect()","language":"python","description":" Pattern: Option Chain Analysis"},"stats":{"mentions":1,"sources":["ex_0286_c1f31f77"]}},{"id":"merged_ex_0287_6fea4d44","topic":"Error 502: Couldn't connect to TWS","tier":"a2","confidence":1.0,"tags":["co","er"],"content":{"code":"# Solutions:\n# 1. Check TWS/Gateway is running\n# 2. Check correct port (7497=TWS, 4001=Gateway)\n# 3. Enable API in TWS settings\n# 4. Check firewall\n# 5. Verify clientId is unique\n\n# Test connection\nimport socket\nsock = socket.socket()\ntry:\n    sock.connect(('127.0.0.1', 7497))\n    print(\"Port is open\")\nexcept:\n    print(\"Cannot connect to port\")\nfinally:\n    sock.close()","language":"python","description":"Error 502: Couldn't connect to TWS"},"stats":{"mentions":1,"sources":["ex_0287_6fea4d44"]}},{"id":"merged_ex_0288_6880db86","topic":"Error 326: Unable to connect","tier":"a2","confidence":1.0,"tags":["co","ct","er"],"content":{"code":"# Check API settings in TWS:\n# Configuration -> API -> Settings\n# - Enable ActiveX and Socket Clients\n# - Socket port: 7497 (TWS) or 4001 (Gateway)\n# - Trusted IPs: 127.0.0.1\n# - Master API client ID: (optional)","language":"python","description":"Error 326: Unable to connect"},"stats":{"mentions":1,"sources":["ex_0288_6880db86"]}},{"id":"merged_ex_0290_5eea209b","topic":"Missing tick data","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"# Don't use waitOnUpdate() loop for ticks - data loss!\n\n# \u274c BAD\nwhile True:\n    ib.waitOnUpdate()\n    # Some ticks lost!\n\n# \u2705 GOOD - Use events\nticker.updateEvent += lambda t: process(t)","language":"python","description":"Missing tick data"},"stats":{"mentions":1,"sources":["ex_0290_5eea209b"]}},{"id":"merged_ex_0292_6d4e3880","topic":"Orders not showing","tier":"a2","confidence":1.0,"tags":["co","or"],"content":{"code":"# Check:\n# 1. Correct clientId\n# 2. \"Download open orders on connection\" enabled in TWS\n# 3. Use ib.openOrders() not ib.reqOpenOrders()\n\n# Sync orders\nib.reqOpenOrders()  # Legacy, can be stale\nib.openOrders()     # Better - auto-synced","language":"python","description":"Orders not showing"},"stats":{"mentions":1,"sources":["ex_0292_6d4e3880"]}},{"id":"merged_ex_0293_aec1b4a0","topic":"Error 162: Historical Market Data Service error","tier":"a2","confidence":1.0,"tags":["ct","da","er"],"content":{"code":"# Common causes:\n# 1. Requesting too much data\n# 2. Invalid date range\n# 3. Contract not found\n# 4. No data available for period\n\n# Solution: Break into chunks\ndt = ''\nall_bars = []\nwhile True:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime=dt,\n        durationStr='30 D',\n        barSizeSetting='1 hour',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    if not bars:\n        break\n    all_bars.extend(bars)\n    dt = bars[0].date\n    ib.sleep(1)  # Respect rate limits","language":"python","description":"Error 162: Historical Market Data Service error"},"stats":{"mentions":1,"sources":["ex_0293_aec1b4a0"]}},{"id":"merged_ex_0294_41afd91b","topic":"Slow responses","tier":"a2","confidence":1.0,"tags":[],"content":{"code":"# Solutions:\n# 1. Reduce simultaneous requests\n# 2. Use batch requests where possible\n# 3. Increase TWS memory allocation\n# 4. Use keepUpToDate for live bars instead of repeated requests\n\n# Increase TWS memory:\n# Configuration -> Settings -> Memory Allocation -> 4096 MB","language":"python","description":"Slow responses"},"stats":{"mentions":1,"sources":["ex_0294_41afd91b"]}},{"id":"merged_ex_0295_b291fa9b","topic":"Too many requests","tier":"a2","confidence":1.0,"tags":["vnt"],"content":{"code":"# IB throttles automatically at 45 req/sec\n# Monitor throttle events:\n\ndef on_throttle_start():\n    print(\"Throttling started\")\n\ndef on_throttle_end():\n    print(\"Throttling ended\")\n\nib.client.throttleStart += on_throttle_start\nib.client.throttleEnd += on_throttle_end","language":"python","description":"Too many requests"},"stats":{"mentions":1,"sources":["ex_0295_b291fa9b"]}},{"id":"merged_ex_0296_3cf79bd0","topic":"Event loop conflicts","tier":"a2","confidence":1.0,"tags":["as","vnt"],"content":{"code":"# At start of notebook:\nutil.startLoop()\n\n# If still issues:\nutil.patchAsyncio()\n\n# For old notebooks:\nimport nest_asyncio\nnest_asyncio.apply()","language":"python","description":"Event loop conflicts"},"stats":{"mentions":1,"sources":["ex_0296_3cf79bd0"]}},{"id":"merged_ex_0297_f097284e","topic":"Ticker accumulation","tier":"a2","confidence":1.0,"tags":["ct"],"content":{"code":"# Cancel unused tickers\nfor contract in old_contracts:\n    ib.cancelMktData(contract)\n\n# Clear refs\ndel ticker","language":"python","description":"Ticker accumulation"},"stats":{"mentions":1,"sources":["ex_0297_f097284e"]}}]