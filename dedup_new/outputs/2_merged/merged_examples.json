{
  "merged_examples": [
    {
      "id": "merged_ex_0001_73157af0",
      "code": "from ib_insync import *\norder = MarketOrder('BUY', 100)",
      "language": "python",
      "description": " Market Order",
      "sources": [
        "ex_0001_73157af0"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0002_8770c7ad",
      "code": "order = LimitOrder('BUY', 100, 175.50)",
      "language": "python",
      "description": " Limit Order",
      "sources": [
        "ex_0002_8770c7ad"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0003_3baa2883",
      "code": "order = StopOrder('SELL', 100, 170.00)  # Stop loss",
      "language": "python",
      "description": " Stop Order",
      "sources": [
        "ex_0003_3baa2883"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0003",
      "code": "parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 175.0,\n    takeProfitPrice=185.0,\n    stopLossPrice=170.0\n)\n\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading.",
      "sources": [
        "ex_0004_1edc2880",
        "ex_0278_3d95d75e"
      ],
      "tags": [
        "contract",
        "order",
        "error"
      ],
      "notes": "Examples show different price parameters (175/185/170 vs 150/160/145) demonstrating the pattern works with any price levels. Example 1 includes 'error' tag highlighting potential error handling considerations.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_cluster_0004",
      "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # Trail by 2%\norder.tif = 'GTC'\n\n# Requires valid contract object\n# trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a trailing stop order that tracks price movements by percentage. Specifies SELL action, 100 shares, 2% trailing offset, and Good-Til-Canceled duration. Includes order placement example requiring a valid contract object. Suitable for percentage-based trailing stop loss strategies.",
      "sources": [
        "ex_0005_a46437c8",
        "ex_0153_fcded4d3"
      ],
      "tags": [
        "order",
        "contract"
      ],
      "notes": "Example 2 includes order placement with contract while Example 1 stops at order configuration. Both use identical order parameters. Actual implementation requires valid contract object for placement.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0006_ce50b185",
      "code": "# Trigger when SPY hits 450\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\ntrigger_contract = ib.qualifyContracts(trigger_contract)[0]\n\ncondition = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # Above price\n    price=450.0\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]",
      "language": "python",
      "description": " Conditional Order",
      "sources": [
        "ex_0006_ce50b185"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0006",
      "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1')\n]\n\n# Requires contract definition before placement:\n# trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter.",
      "sources": [
        "ex_0007_aba79f2a",
        "ex_0160_aae7547e"
      ],
      "tags": [
        "order",
        "contract",
        "TWAP"
      ],
      "notes": "Example 2 adds 'allowPastEndTime=1' parameter and demonstrates order placement. Example 1 omits these but shows basic structure. Both use same core TWAP configuration.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0008_d7830359",
      "code": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\norder = LimitOrder('BUY', 100, 175.0)\ntrade = ib.placeOrder(contract, order)\n\n# Wait for fill\nwhile not trade.isDone():\n    ib.sleep(0.1)\n\nprint(f\"Status: {trade.orderStatus.status}\")",
      "language": "python",
      "description": " Basic Pattern",
      "sources": [
        "ex_0008_d7830359"
      ],
      "tags": [
        "connect",
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0009_55344dab",
      "code": "# Check buying power first\norder_copy = Order(**{k: v for k, v in order.__dict__.items()})\norder_copy.whatIf = True\n\norderState = ib.whatIfOrder(contract, order_copy)\nif orderState.commission > 0:\n    trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " With Validation",
      "sources": [
        "ex_0009_55344dab"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0010_7e8f1098",
      "code": "ib.cancelOrder(order)",
      "language": "python",
      "description": " Cancel Order",
      "sources": [
        "ex_0010_7e8f1098"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0011_18b44996",
      "code": "ib.reqGlobalCancel()",
      "language": "python",
      "description": " Cancel All",
      "sources": [
        "ex_0011_18b44996"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0011",
      "code": "order.lmtPrice = 176.0\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order.",
      "sources": [
        "ex_0012_ae79ffd3",
        "ex_0219_e7868613"
      ],
      "tags": [
        "contract",
        "order",
        "modify",
        "limit_price",
        "trading"
      ],
      "notes": "Examples differ only in commented instructions and price values (176.0 vs 151.0), but share identical structure. The second example includes a comment '# Modify existing order' for clarity, though the core code remains functionally equivalent. Best practice is to explicitly update order attributes before resubmission.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0013_489b83e2",
      "code": "def on_order_status(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n\nib.orderStatusEvent += on_order_status",
      "language": "python",
      "description": " Monitor Status",
      "sources": [
        "ex_0013_489b83e2"
      ],
      "tags": [
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0014_cbe2f695",
      "code": "option = Option('SPY', '20240315', 450, 'C', 'SMART')\noption = ib.qualifyContracts(option)[0]\norder = LimitOrder('BUY', 10, 5.50)\ntrade = ib.placeOrder(option, order)",
      "language": "python",
      "description": " Single Option",
      "sources": [
        "ex_0014_cbe2f695"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0014",
      "code": "buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')\n]\n\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread\ntrade = ib.placeOrder(combo, order)",
      "language": "python",
      "description": "Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters.",
      "sources": [
        "ex_0015_e4716efb",
        "ex_0166_08a5d66a"
      ],
      "tags": [
        "contract",
        "order",
        "spread",
        "options"
      ],
      "notes": "Key variations: 1) Vertical spread uses same expiration/different strikes, calendar spread uses same strike/different expirations. 2) Action ratios reverse for credit spreads (SELL then BUY). 3) Order direction ('BUY'/'SELL') depends on spread type (debit/credit). Example 2 shows calendar spread construction with reversed actions.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0016_8c2fb027",
      "code": "'DAY'    # Day order (default)\n'GTC'    # Good till cancelled\n'IOC'    # Immediate or cancel\n'GTD'    # Good till date\n'FOK'    # Fill or kill",
      "language": "python",
      "description": " Time In Force",
      "sources": [
        "ex_0016_8c2fb027"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0017_6a11bf25",
      "code": "# 1. Enter position\nentry = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry)\n\n# 2. Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    avg_price = entry_trade.orderStatus.avgFillPrice\n    \n    # 3. Set stop loss\n    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop\n    ib.placeOrder(contract, stop)\n    \n    # 4. Set take profit\n    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit\n    ib.placeOrder(contract, target)",
      "language": "python",
      "description": " Position Entry with Protection",
      "sources": [
        "ex_0017_6a11bf25"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0018_ce1ccb8b",
      "code": "# Scale in\nfor qty in [25, 25, 25, 25]:\n    order = LimitOrder('BUY', qty, price)\n    ib.placeOrder(contract, order)\n    ib.sleep(300)  # 5 min between orders\n\n# Scale out\ntotal_position = 100\nfor pct in [0.25, 0.25, 0.25, 0.25]:\n    qty = int(total_position * pct)\n    order = LimitOrder('SELL', qty, price)\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Scale In/Out",
      "sources": [
        "ex_0018_ce1ccb8b"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0019_2cc9e38b",
      "code": "def place_order_safe(ib, contract, order):\n    try:\n        trade = ib.placeOrder(contract, order)\n        \n        # Wait with timeout\n        timeout = 10\n        start = time.time()\n        while trade.orderStatus.status == 'PendingSubmit':\n            if time.time() - start > timeout:\n                ib.cancelOrder(order)\n                raise TimeoutError(\"Order submission timeout\")\n            ib.sleep(0.1)\n        \n        return trade\n    except Exception as e:\n        print(f\"Order failed: {e}\")\n        return None",
      "language": "python",
      "description": " Error Handling",
      "sources": [
        "ex_0019_2cc9e38b"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0019",
      "code": "while True:\n    bars = ib.reqHistoricalData(...)  # DON'T POLL!\n    time.sleep(5)  # Also wrong - blocks event loop!",
      "language": "python",
      "description": "Demonstrates incorrect pattern of repeatedly polling historical data in a blocking loop. This approach violates API best practices by 1) Using historical requests instead of real-time streaming 2) Blocking the event loop with sleep() which prevents processing of messages and events. Use real-time market data subscriptions instead of polling historical endpoints.",
      "sources": [
        "ex_0020_eb569bed",
        "ex_0267_ecb56a32"
      ],
      "tags": [
        "data",
        "event"
      ],
      "notes": "Example 2 adds emphasis on event loop blocking consequence. Both agree on core anti-pattern of polling historical data. Combined comments show both polling and blocking issues.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0021_b4426143",
      "code": "# For ticks\nticker = ib.reqMktData(contract)\nticker.updateEvent += process_tick\n\n# For bars  \nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += process_bar",
      "language": "python",
      "description": "\u2705 ALWAYS DO THIS:",
      "sources": [
        "ex_0021_b4426143"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0022_a3f0f5a9",
      "code": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Start streaming\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data\nib.sleep(2)\n\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Last: {ticker.last}\")\nprint(f\"Volume: {ticker.volume}\")",
      "language": "python",
      "description": " Basic Ticker (Streaming)",
      "sources": [
        "ex_0022_a3f0f5a9"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0023_e4cf6f06",
      "code": "def on_ticker_update(ticker):\n    print(f\"{ticker.contract.symbol}: ${ticker.last:.2f}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_ticker_update",
      "language": "python",
      "description": " With Event Handler",
      "sources": [
        "ex_0023_e4cf6f06"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0024_0e65c2b1",
      "code": "# Request additional data\nticker = ib.reqMktData(\n    contract,\n    genericTickList='233,236',  # Volume, shortable shares\n    snapshot=False\n)\n\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}\")\nprint(f\"RT Volume: {ticker.rtVolume}\")",
      "language": "python",
      "description": " Generic Ticks (Extra Data)",
      "sources": [
        "ex_0024_0e65c2b1"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0025_b431b910",
      "code": "100 - Option volume\n101 - Option open interest  \n104 - Historical volatility\n106 - Implied volatility\n165 - 52-week high/low\n221 - Mark price\n233 - Last, volume, VWAP\n236 - Shortable shares\n258 - Fundamental ratios",
      "language": "python",
      "description": " Generic Tick IDs",
      "sources": [
        "ex_0025_b431b910"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0026_bff1f5f7",
      "code": "ib.cancelMktData(contract)",
      "language": "python",
      "description": " Cancel Streaming",
      "sources": [
        "ex_0026_bff1f5f7"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0027_f3914538",
      "code": "bars = ib.reqRealTimeBars(\n    contract,\n    barSize=5,              # Always 5 seconds\n    whatToShow='TRADES',    # TRADES, MIDPOINT, BID, ASK\n    useRTH=False\n)\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"{bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close} V:{bar.volume}\")\n\nbars.updateEvent += on_bar_update\n\n# Cancel when done\nib.cancelRealTimeBars(bars)",
      "language": "python",
      "description": " Real-Time Bars (5-Second Updates)",
      "sources": [
        "ex_0027_f3914538"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0027",
      "code": "contract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',          # '' = now\n    durationStr='30 D',      # 30 days\n    barSizeSetting='1 hour',\n    whatToShow='TRADES',     # Can be MIDPOINT for FX\n    useRTH=True              # Regular hours only\n)\n\n# Convert to pandas\ndf = util.df(bars)\nprint(df.head())",
      "language": "python",
      "description": "Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion.",
      "sources": [
        "ex_0028_df8dcf24",
        "ex_0237_f1541456"
      ],
      "tags": [
        "contract",
        "data",
        "pandas",
        "forex",
        "historical"
      ],
      "notes": "Key variations: 1) whatToShow parameter differs between TRADES (equities) vs MIDPOINT (FX) 2) Forex contract example vs generic contract 3) Explicit pandas import in one example vs implicit in util.df",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0029_6e6893b1",
      "code": "'60 S'  - 60 seconds\n'1 D'   - 1 day\n'2 W'   - 2 weeks\n'6 M'   - 6 months\n'1 Y'   - 1 year",
      "language": "python",
      "description": " Duration Options",
      "sources": [
        "ex_0029_6e6893b1"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0030_b39d58cf",
      "code": "'1 secs', '5 secs', '15 secs', '30 secs'\n'1 min', '5 mins', '15 mins', '30 mins'\n'1 hour', '4 hours'\n'1 day', '1 week', '1 month'",
      "language": "python",
      "description": " Bar Sizes",
      "sources": [
        "ex_0030_b39d58cf"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0031_809d444a",
      "code": "'TRADES'    - Actual trades (default)\n'MIDPOINT'  - Bid/ask midpoint\n'BID'       - Bid prices\n'ASK'       - Ask prices",
      "language": "python",
      "description": " What to Show",
      "sources": [
        "ex_0031_809d444a"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0032_34b0e6c2",
      "code": "bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    keepUpToDate=True  # \u2190 Auto-update!\n)\n\nbars.updateEvent += lambda bars, hasNewBar: print(f\"Updated: {hasNewBar}\")",
      "language": "python",
      "description": " Keep Historical Updated (Live)",
      "sources": [
        "ex_0032_34b0e6c2"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0033_b6bbded7",
      "code": "ticker = ib.reqTickByTickData(\n    contract,\n    tickType='AllLast',  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks=0,\n    ignoreSize=False\n)\n\ndef on_tick(ticker):\n    if ticker.tickByTicks:\n        tick = ticker.tickByTicks[-1]\n        print(f\"Tick: {tick.time} {tick.price} x {tick.size}\")\n\nticker.updateEvent += on_tick",
      "language": "python",
      "description": " Tick-by-Tick Data",
      "sources": [
        "ex_0033_b6bbded7"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0034_785d16e2",
      "code": "ticker = ib.reqMktDepth(\n    contract,\n    numRows=10,\n    isSmartDepth=False\n)\n\nib.sleep(2)\n\nprint(\"Bids:\")\nfor bid in ticker.domBids:\n    print(f\"  {bid.price} x {bid.size}\")\n\nprint(\"Asks:\")\nfor ask in ticker.domAsks:\n    print(f\"  {ask.price} x {ask.size}\")\n\n# Cancel\nib.cancelMktDepth(contract)",
      "language": "python",
      "description": " Market Depth (Level II)",
      "sources": [
        "ex_0034_785d16e2"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0035_c23ecc05",
      "code": "contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract)\n\nib.run()  # Run event loop",
      "language": "python",
      "description": " Multiple Tickers Pattern",
      "sources": [
        "ex_0035_c23ecc05"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0035",
      "code": "# Market Data Types:\n# 1 = Live (subscription required)\n# 2 = Frozen (snapshot)\n# 3 = Delayed (free, 15-min delay)\n# 4 = Delayed-Frozen\nib.reqMarketDataType(3)  # Use delayed data (free)",
      "language": "python",
      "description": "Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions.",
      "sources": [
        "ex_0036_b007e6a8",
        "ex_0289_2973e326"
      ],
      "tags": [
        "market data",
        "subscription",
        "delayed data",
        "error handling",
        "connection",
        "reqMarketDataType"
      ],
      "notes": "Example 1 provides complete market type definitions while Example 2 focuses on resolving subscription errors. Both agree on using type 3 for free delayed data. Example 2 additionally mentions type 4 (Delayed-Frozen) as an alternative solution for Error 354.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0037_86e01f21",
      "code": "def price_alert(ticker, target_price, above=True):\n    \"\"\"Alert when price crosses threshold\"\"\"\n    def check_price(ticker):\n        if not ticker.last or ticker.last != ticker.last:\n            return\n        \n        if above and ticker.last >= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} above ${target_price}\")\n            ticker.updateEvent -= check_price  # Unsubscribe\n        elif not above and ticker.last <= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} below ${target_price}\")\n            ticker.updateEvent -= check_price\n    \n    ticker.updateEvent += check_price\n\n# Usage\nticker = ib.reqMktData(contract)\nprice_alert(ticker, 180.0, above=True)",
      "language": "python",
      "description": " Price Alert System",
      "sources": [
        "ex_0037_86e01f21"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0038_342563ba",
      "code": "class MovingAverage:\n    def __init__(self, period=20):\n        self.period = period\n        self.prices = []\n    \n    def update(self, price):\n        self.prices.append(price)\n        if len(self.prices) > self.period:\n            self.prices.pop(0)\n    \n    def value(self):\n        return sum(self.prices) / len(self.prices) if self.prices else None\n\nma20 = MovingAverage(20)\n\ndef on_bar(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        ma20.update(bar.close)\n        if ma20.value():\n            print(f\"Price: {bar.close:.2f} | MA20: {ma20.value():.2f}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += on_bar",
      "language": "python",
      "description": " Moving Average Calculator",
      "sources": [
        "ex_0038_342563ba"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0039_6faded7e",
      "code": "class OHLCTracker:\n    def __init__(self):\n        self.open = None\n        self.high = None\n        self.low = None\n        self.close = None\n    \n    def update(self, price):\n        if self.open is None:\n            self.open = price\n        \n        if self.high is None or price > self.high:\n            self.high = price\n        \n        if self.low is None or price < self.low:\n            self.low = price\n        \n        self.close = price\n    \n    def reset(self):\n        self.open = self.high = self.low = self.close = None\n\ntracker = OHLCTracker()\n\ndef on_tick(ticker):\n    if ticker.last:\n        tracker.update(ticker.last)\n        print(f\"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_tick",
      "language": "python",
      "description": " OHLC Tracker",
      "sources": [
        "ex_0039_6faded7e"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0040_8452a621",
      "code": "# Blocking interface - simple and direct\nfrom ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)  # Blocks until complete",
      "language": "python",
      "description": "Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...",
      "sources": [
        "ex_0040_8452a621"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0041_e5acebcb",
      "code": "# Asynchronous interface - non-blocking\nimport asyncio\nfrom ib_insync import *\n\nasync def main():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking\n    \nasyncio.run(main())",
      "language": "python",
      "description": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)   Blocks until complete\n",
      "sources": [
        "ex_0041_e5acebcb"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0042_4c1e2894",
      "code": "# WRONG - freezes everything\nimport time\nticker = ib.reqMktData(contract)\ntime.sleep(5)  # Event loop frozen, no updates processed\nprint(ticker.last)  # May be empty\n\n# CORRECT - allows message processing\nticker = ib.reqMktData(contract)\nib.sleep(5)  # Framework processes updates in background\nprint(ticker.last)  # Contains current data",
      "language": "python",
      "description": "The golden rule: never use time.sleep()\u2014always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields...",
      "sources": [
        "ex_0042_4c1e2894"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0043_5d3bba14",
      "code": "# Jupyter notebook setup\nfrom ib_insync import *\n\nutil.startLoop()  # Enables nested event loops\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n# Can now use blocking methods directly in notebook cells",
      "language": "python",
      "description": "For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package.",
      "sources": [
        "ex_0043_5d3bba14"
      ],
      "tags": [
        "async",
        "connect",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0044_cff8313a",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef onTicker(ticker):\n    print(f\"Price update: {ticker.contract.symbol} @ {ticker.last}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTicker\n\nib.run()  # Runs event loop indefinitely",
      "language": "python",
      "description": "For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...",
      "sources": [
        "ex_0044_cff8313a"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0045_4e24d1aa",
      "code": "# Synchronous event handler\ndef onOrderStatus(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    if trade.isDone():\n        print(f\"Filled at: {trade.orderStatus.avgFillPrice}\")\n\nib.orderStatusEvent += onOrderStatus\n\n# Asynchronous event handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        print(f\"New bar: {bars[-1]}\")\n        # Can use await inside async handlers\n        await ib.qualifyContractsAsync(contract)\n\nbars.updateEvent += onBarUpdate",
      "language": "python",
      "description": "ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.",
      "sources": [
        "ex_0045_4e24d1aa"
      ],
      "tags": [
        "async",
        "contract",
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0046_d613ad24",
      "code": "contract = Forex('EURUSD')\nticker = ib.reqMktData(contract)\n\nasync def onTickerUpdate(ticker):\n    print(f\"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}\")\n    \nticker.updateEvent += onTickerUpdate",
      "language": "python",
      "description": "Ticker-specific events provide fine-grained control over individual market data subscriptions:",
      "sources": [
        "ex_0046_d613ad24"
      ],
      "tags": [
        "async",
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0047_02297e7d",
      "code": "# Unsubscribe\nticker.updateEvent -= onTickerUpdate\n\n# One-time handler\n@ticker.updateEvent.once\ndef onFirstUpdate(ticker):\n    print(f\"First update received: {ticker.last}\")",
      "language": "python",
      "description": "Unsubscribe from events using the -= operator, and use the @event.once decorator for one-time handlers that automatically unsubscribe after firing.",
      "sources": [
        "ex_0047_02297e7d"
      ],
      "tags": [
        "async",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0048_4f262d22",
      "code": "async def get_multiple_contracts():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    contracts = [\n        Stock('AAPL', 'SMART', 'USD'),\n        Stock('GOOGL', 'SMART', 'USD'),\n        Stock('MSFT', 'SMART', 'USD')\n    ]\n    \n    # Request all contract details concurrently\n    results = await asyncio.gather(*[\n        ib.reqContractDetailsAsync(c) for c in contracts\n    ])\n    \n    return results",
      "language": "python",
      "description": "Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations.",
      "sources": [
        "ex_0048_4f262d22"
      ],
      "tags": [
        "async",
        "connect",
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0049_17c31825",
      "code": "async def monitor_multiple_tickers():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    async def watch_ticker(contract):\n        ticker = ib.reqMktData(contract)\n        await ib.sleep(1)\n        return ticker\n    \n    # Create tasks for concurrent execution\n    tasks = [\n        asyncio.create_task(watch_ticker(Forex('EURUSD'))),\n        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),\n        asyncio.create_task(watch_ticker(Forex('USDJPY')))\n    ]\n    \n    tickers = await asyncio.gather(*tasks)\n    return tickers",
      "language": "python",
      "description": "Use asyncio.createtask() for truly concurrent execution of independent operations:",
      "sources": [
        "ex_0049_17c31825"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0050_6a97af6f",
      "code": "# WRONG - blocks event loop in callback\ndef onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        ib.qualifyContracts(contract)  # Blocking!\n\n# CORRECT - use async handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        await ib.qualifyContractsAsync(contract)",
      "language": "python",
      "description": "Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately.",
      "sources": [
        "ex_0050_6a97af6f"
      ],
      "tags": [
        "async",
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0051_76c1e159",
      "code": "# WRONG - misses rapid ticks\nwhile True:\n    ib.waitOnUpdate()\n    print(ticker.last)\n\n# CORRECT - captures all updates\ndef onTicker(ticker):\n    print(ticker.last)\n    \nticker.updateEvent += onTicker",
      "language": "python",
      "description": "Missing tick data with waitOnUpdate(): The waitOnUpdate() method can miss rapid updates because ticks from the first update get cleared before processing. Always use event handlers for tick data colle...",
      "sources": [
        "ex_0051_76c1e159"
      ],
      "tags": [
        "async",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0052_e56ea900",
      "code": "# Internal architecture (conceptual)\nIB Instance\n    \u2514\u2500\u2500 Wrapper Instance (single source of truth)\n        \u251c\u2500\u2500 accountValues (dict)\n        \u251c\u2500\u2500 acctSummary (dict)\n        \u251c\u2500\u2500 portfolio (defaultdict)\n        \u251c\u2500\u2500 positions (defaultdict)\n        \u251c\u2500\u2500 trades (dict)\n        \u251c\u2500\u2500 tickers (dict)\n        \u2514\u2500\u2500 [other state collections]\n    \u2514\u2500\u2500 Client Instance (network communication)",
      "language": "python",
      "description": "The IB class provides the user-facing interface, but internally delegates all state storage to the Wrapper. This Wrapper maintains dictionaries for account values, portfolio items, positions, trades, ...",
      "sources": [
        "ex_0052_e56ea900"
      ],
      "tags": [
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0053_127607b2",
      "code": "# CORRECT - access live state\ndef check_positions():\n    positions = ib.positions()\n    for pos in positions:\n        print(f\"{pos.contract.symbol}: {pos.position}\")\n\n# WRONG - storing stale copies\ncached_positions = ib.positions()  # Snapshot becomes stale\n# Later...\nprint(cached_positions)  # Likely outdated",
      "language": "python",
      "description": "The critical pattern: never store copies of state in long-lived variables. Always call IB methods to access current state. Stored copies become stale as the Wrapper updates in the background.",
      "sources": [
        "ex_0053_127607b2"
      ],
      "tags": [
        "contract",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0054_2b50dee3",
      "code": "# Trade object is automatically updated\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# trade.orderStatus updates automatically in background\ndef check_order_status():\n    if trade.orderStatus.status == 'Filled':\n        print(\"Order filled!\")\n    elif trade.isDone():\n        print(\"Order completed\")",
      "language": "python",
      "description": "The returned objects themselves\u2014Ticker, Trade, Position, Portfolio\u2014are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...",
      "sources": [
        "ex_0054_2b50dee3"
      ],
      "tags": [
        "contract",
        "data",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0055_3cb13bff",
      "code": "def onPositionUpdate(position):\n    print(f\"Position: {position.contract.symbol}: {position.position}\")\n\nib.positionEvent += onPositionUpdate\n\ndef onPortfolioUpdate(item):\n    print(f\"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}\")\n\nib.updatePortfolioEvent += onPortfolioUpdate",
      "language": "python",
      "description": "Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking.",
      "sources": [
        "ex_0055_3cb13bff"
      ],
      "tags": [
        "contract",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0056_43a0d333",
      "code": "def onUpdate():\n    positions = ib.positions()\n    print(f\"Current positions: {len(positions)}\")\n\nib.updateEvent += onUpdate",
      "language": "python",
      "description": "The global updateEvent fires on any state change, useful for triggering comprehensive checks:",
      "sources": [
        "ex_0056_43a0d333"
      ],
      "tags": [
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0057_0fc7542b",
      "code": "def long_calculation():\n    for i in range(1000):\n        result = expensive_operation()\n        \n        # Periodically yield to allow state updates\n        if i % 100 == 0:\n            ib.sleep(0)\n        \n        # State may have changed during sleep\n        current_positions = ib.positions()",
      "language": "python",
      "description": "When performing calculations or processing that takes significant time, yield control to the event loop periodically using ib.sleep(0). This allows the Wrapper to process incoming messages and update ...",
      "sources": [
        "ex_0057_0fc7542b"
      ],
      "tags": [
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0058_425a6b9f",
      "code": "# All portfolio items across accounts\nall_portfolio = ib.portfolio()\n\n# Portfolio for specific account\naccount_portfolio = ib.portfolio(account='U1234567')\n\n# All positions\nall_positions = ib.positions()\n\n# Positions for specific account\naccount_positions = ib.positions(account='U1234567')\n\n# Iterate through positions\nfor position in ib.positions():\n    symbol = position.contract.symbol\n    qty = position.position\n    avg_cost = position.avgCost\n    print(f\"{symbol}: {qty} @ ${avg_cost}\")",
      "language": "python",
      "description": " Patterns for accessing portfolio and positions",
      "sources": [
        "ex_0058_425a6b9f"
      ],
      "tags": [
        "contract",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0059_7013efa0",
      "code": "# Get all open orders\nopen_orders = ib.orders()\n\n# Get all trades (open and completed from this session)\nall_trades = ib.trades()\n\n# Get all fills from this session\nfills = ib.fills()\n\n# Request all open orders including from other clients\nib.reqAllOpenOrders()",
      "language": "python",
      "description": " Trade and order management state",
      "sources": [
        "ex_0059_7013efa0"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0060_374afa70",
      "code": "# WRONG - threading with asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nexecutor = ThreadPoolExecutor(max_workers=2)\nexecutor.submit(ib.positions)  # Will fail!\n\n# CORRECT - use asyncio tasks\nasync def fetch_multiple_contracts():\n    tasks = [\n        ib.qualifyContractsAsync(contract1),\n        ib.qualifyContractsAsync(contract2),\n        ib.qualifyContractsAsync(contract3)\n    ]\n    results = await asyncio.gather(*tasks)\n    return results",
      "language": "python",
      "description": "ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.",
      "sources": [
        "ex_0060_374afa70"
      ],
      "tags": [
        "async",
        "contract",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0061_f269a415",
      "code": "class TradingBot:\n    def __init__(self, ib):\n        self.ib = ib\n        self._positions_cache = None\n        self._cache_time = None\n        \n    def get_positions(self, max_age=1.0):\n        \"\"\"Get positions with short-term caching\"\"\"\n        now = time.time()\n        if (self._positions_cache is None or \n            self._cache_time is None or \n            now - self._cache_time > max_age):\n            self._positions_cache = self.ib.positions()\n            self._cache_time = now\n        return self._positions_cache",
      "language": "python",
      "description": "Caching with incorrect invalidation: If you must cache state for performance, implement short-lived caching with explicit refresh logic.",
      "sources": [
        "ex_0061_f269a415"
      ],
      "tags": [
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0062_4ca1eb17",
      "code": "def get_price():\n    if not ib.isConnected():\n        raise ConnectionError(\"Not connected to IB\")\n    ticker = ib.reqMktData(contract)\n    ib.sleep(2)\n    if ticker.last:\n        return ticker.last\n    raise ValueError(\"No price data available\")",
      "language": "python",
      "description": "Not checking connection state: Always verify connection before state access.",
      "sources": [
        "ex_0062_4ca1eb17"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0063_228c81f6",
      "code": "from ib_insync import *\nimport logging\n\nclass IBDataManager:\n    \"\"\"Demonstrates best practices for single source of truth pattern\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self._setup_logging()\n        self._setup_events()\n    \n    def _setup_logging(self):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n    \n    def _setup_events(self):\n        self.ib.connectedEvent += self._on_connected\n        self.ib.disconnectedEvent += self._on_disconnected\n        self.ib.positionEvent += self._on_position\n        self.ib.updatePortfolioEvent += self._on_portfolio\n    \n    def connect(self):\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(\"Connected to IB\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _on_connected(self):\n        self.logger.info(\"Connection established\")\n        self.ib.reqAccountSummary()\n    \n    def _on_disconnected(self):\n        self.logger.warning(\"Disconnected from IB\")\n    \n    def _on_position(self, position):\n        self.logger.info(f\"Position update: {position.contract.symbol}\")\n    \n    def _on_portfolio(self, item):\n        self.logger.info(f\"Portfolio update: {item.contract.symbol}\")\n    \n    def get_current_positions(self):\n        \"\"\"Get current positions (always fresh from single source)\"\"\"\n        if not self.ib.isConnected():\n            raise ConnectionError(\"Not connected\")\n        return self.ib.positions()\n    \n    def get_position_for_symbol(self, symbol):\n        \"\"\"Get position for specific symbol\"\"\"\n        for pos in self.get_current_positions():\n            if pos.contract.symbol == symbol:\n                return pos\n        return None",
      "language": "python",
      "description": " Production-ready state manager",
      "sources": [
        "ex_0063_228c81f6"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0064_bdc1144a",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Create and qualify contract\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Create and place market order\norder = MarketOrder('BUY', 100)\ntrade = ib.placeOrder(contract, order)\n\n# Monitor order status\nprint(f\"Order status: {trade.orderStatus.status}\")",
      "language": "python",
      "description": "Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets.",
      "sources": [
        "ex_0064_bdc1144a"
      ],
      "tags": [
        "connect",
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0065_1584a6ea",
      "code": "def order_status_callback(trade):\n    if trade.orderStatus.status == 'Filled':\n        fill = trade.fills[-1]\n        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '\n              f'{fill.execution.shares} @ {fill.execution.avgPrice}')\n\ntrade.filledEvent += order_status_callback",
      "language": "python",
      "description": "Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders.",
      "sources": [
        "ex_0065_1584a6ea"
      ],
      "tags": [
        "contract",
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0066_d7c5ce88",
      "code": "# Basic limit order\nlimit_order = LimitOrder('BUY', 100, 150.00)\ntrade = ib.placeOrder(contract, limit_order)\n\n# Limit order with time-in-force\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.tif = 'GTD'  # Good Till Date\nlimit_order.goodTillDate = '20240331 23:59:59'\ntrade = ib.placeOrder(contract, limit_order)\n\n# Allow outside regular trading hours\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.outsideRth = True\ntrade = ib.placeOrder(contract, limit_order)",
      "language": "python",
      "description": "Limit orders execute only at the specified price or better, providing price protection but no guarantee of execution. Set time-in-force parameters to control order lifespan.",
      "sources": [
        "ex_0066_d7c5ce88"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0067_f66f09e8",
      "code": "# Trailing stop with fixed dollar amount\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.auxPrice = 2.0  # Trail by $2\ntrailing_order.trailStopPrice = 150.0  # Initial trigger price\n\ntrade = ib.placeOrder(contract, trailing_order)\n\n# Trailing stop with percentage\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.trailingPercent = 5.0  # Trail by 5%\n\ntrade = ib.placeOrder(contract, trailing_order)",
      "language": "python",
      "description": "Trailing stops follow favorable price movement, maintaining a specified distance from the highest price reached (for sells) or lowest price (for buys). They protect profits while allowing continued up...",
      "sources": [
        "ex_0067_f66f09e8"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0068_68d1eeb1",
      "code": "trail_limit_order = Order()\ntrail_limit_order.orderType = 'TRAIL LIMIT'\ntrail_limit_order.totalQuantity = 100\ntrail_limit_order.action = 'SELL'\ntrail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop\ntrail_limit_order.auxPrice = 2.0  # Trail amount\ntrail_limit_order.trailStopPrice = 150.0\n\ntrade = ib.placeOrder(contract, trail_limit_order)",
      "language": "python",
      "description": "Trailing stop limit orders trigger a limit order (rather than market order) when the stop is hit, providing more control but risking non-execution:",
      "sources": [
        "ex_0068_68d1eeb1"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0069_97afc54d",
      "code": "# Using the helper method (recommended)\norders = [\n    LimitOrder('BUY', 100, 150.00),\n    LimitOrder('BUY', 100, 149.00),\n    LimitOrder('BUY', 100, 148.00)\n]\n\noca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)\n\nfor order in oca_orders:\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "OCO orders link multiple orders such that when one executes, the others automatically cancel. Use for scenarios like placing buy orders at multiple price levels where you only want one fill.",
      "sources": [
        "ex_0069_97afc54d"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0070_e2d9a68a",
      "code": "oca_group_name = 'MyOCAGroup_123'\n\norder1 = LimitOrder('BUY', 100, 150.00)\norder1.ocaGroup = oca_group_name\norder1.ocaType = 2  # Proportional reduction with block\norder1.transmit = False\n\norder2 = LimitOrder('BUY', 100, 149.00)\norder2.ocaGroup = oca_group_name\norder2.ocaType = 2\norder2.transmit = False\n\norder3 = LimitOrder('BUY', 100, 148.00)\norder3.ocaGroup = oca_group_name\norder3.ocaType = 2\norder3.transmit = True  # Last order triggers transmission\n\nib.placeOrder(contract, order1)\nib.placeOrder(contract, order2)\nib.placeOrder(contract, order3)",
      "language": "python",
      "description": "Manual OCO setup provides more control over individual order parameters:",
      "sources": [
        "ex_0070_e2d9a68a"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0071_a5aa41ea",
      "code": "# Using the helper function (recommended)\nbracket = ib.bracketOrder(\n    'BUY',\n    quantity=100,\n    limitPrice=150.00,\n    takeProfitPrice=155.00,\n    stopLossPrice=145.00\n)\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af...",
      "sources": [
        "ex_0071_a5aa41ea"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0072_20869a92",
      "code": "bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)\nbracket[0].orderType = 'MKT'\nbracket[0].lmtPrice = 0\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "For market entry instead of limit entry, modify the parent order:",
      "sources": [
        "ex_0072_20869a92"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0073_68026665",
      "code": "parent = Order()\nparent.orderId = ib.client.getReqId()\nparent.action = 'BUY'\nparent.orderType = 'LMT'\nparent.totalQuantity = 100\nparent.lmtPrice = 150.00\nparent.transmit = False\n\ntakeProfit = Order()\ntakeProfit.orderId = parent.orderId + 1\ntakeProfit.action = 'SELL'\ntakeProfit.orderType = 'LMT'\ntakeProfit.totalQuantity = 100\ntakeProfit.lmtPrice = 155.00\ntakeProfit.parentId = parent.orderId\ntakeProfit.transmit = False\n\nstopLoss = Order()\nstopLoss.orderId = parent.orderId + 2\nstopLoss.action = 'SELL'\nstopLoss.orderType = 'STP'\nstopLoss.auxPrice = 145.00\nstopLoss.totalQuantity = 100\nstopLoss.parentId = parent.orderId\nstopLoss.transmit = True  # Last order triggers all\n\nib.placeOrder(contract, parent)\nib.placeOrder(contract, takeProfit)\nib.placeOrder(contract, stopLoss)",
      "language": "python",
      "description": "Manual bracket construction for full control:",
      "sources": [
        "ex_0073_68026665"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0074_62270345",
      "code": "from typing import NamedTuple\n\nclass BracketOrderTwoTargets(NamedTuple):\n    parent: Order\n    takeProfit1: Order\n    takeProfit2: Order\n    stopLoss: Order\n\ndef bracket_two_targets(action, quantity, limit_price, \n                       tp_price1, tp_price2, sl_price, ib):\n    \"\"\"Create bracket with two take-profit targets\"\"\"\n    \n    parent = LimitOrder(action, quantity, limit_price)\n    parent.orderId = ib.client.getReqId()\n    parent.transmit = False\n    \n    # First take profit (half position)\n    takeProfit1 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price1\n    )\n    takeProfit1.orderId = parent.orderId + 1\n    takeProfit1.parentId = parent.orderId\n    takeProfit1.transmit = False\n    \n    # Second take profit (remaining half)\n    takeProfit2 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price2\n    )\n    takeProfit2.orderId = parent.orderId + 2\n    takeProfit2.parentId = parent.orderId\n    takeProfit2.transmit = False\n    \n    # Stop loss for full position\n    stopLoss = StopOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity,\n        sl_price\n    )\n    stopLoss.orderId = parent.orderId + 3\n    stopLoss.parentId = parent.orderId\n    stopLoss.transmit = True\n    \n    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)\n\n# Usage\nbracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Scale out of positions by setting multiple take-profit levels:",
      "sources": [
        "ex_0074_62270345"
      ],
      "tags": [
        "contract",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0075_d96e77e8",
      "code": "contract = Forex('GBPUSD')\nib.qualifyContracts(contract)\n\n# Place entry order\nparent_order = MarketOrder('BUY', 25000)\ntrade = ib.placeOrder(contract, parent_order)\n\n# Wait for fill\nib.sleep(1)\nwhile trade.orderStatus.status != 'Filled':\n    ib.waitOnUpdate()\n\n# Calculate levels based on actual fill price\nfill_price = trade.orderStatus.avgFillPrice\nstop_loss_price = fill_price - 0.0015\ntake_profit_price = fill_price + 0.0020\n\n# Place child orders\nstop_loss_order = StopOrder('SELL', 25000, stop_loss_price)\ntake_profit_order = LimitOrder('SELL', 25000, take_profit_price)\n\nib.placeOrder(contract, stop_loss_order)\nib.placeOrder(contract, take_profit_order)",
      "language": "python",
      "description": "For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:",
      "sources": [
        "ex_0075_d96e77e8"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0076_c4ff8d3a",
      "code": "# Trade object attributes\ntrade.order          # The original order\ntrade.orderStatus    # Current status object\ntrade.fills          # List of fills\ntrade.log            # Log of status changes\ntrade.isActive()     # Is order still active\ntrade.isDone()       # Is order complete\n\n# Order status values\n# PendingSubmit, PendingCancel, PreSubmitted, Submitted, \n# Filled, Cancelled, Inactive, ApiPending\n\n# Event callbacks for monitoring\ndef on_fill(trade, fill):\n    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')\n\ntrade.fillEvent += on_fill\n\ndef on_filled(trade):\n    total = sum(f.execution.shares for f in trade.fills)\n    avg_price = trade.orderStatus.avgFillPrice\n    print(f'Complete: {total} shares @ avg {avg_price}')\n\ntrade.filledEvent += on_filled\n\ndef on_status(trade):\n    print(f'Status: {trade.orderStatus.status}')\n\ntrade.statusEvent += on_status",
      "language": "python",
      "description": " Order status monitoring",
      "sources": [
        "ex_0076_c4ff8d3a"
      ],
      "tags": [
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0077_85f6c0d1",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Recommended method\ncontract = Future('ES', '202506', 'CME')\n\n# With additional parameters\ncontract = Future(\n    symbol='ES',\n    lastTradeDateOrContractMonth='202506',\n    exchange='CME',\n    localSymbol='ESM6',\n    multiplier='50',\n    currency='USD'\n)",
      "language": "python",
      "description": "The Future class provides the cleanest syntax for futures contracts:",
      "sources": [
        "ex_0077_85f6c0d1"
      ],
      "tags": [
        "connect",
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0078_1e17e8a5",
      "code": "contract = Contract()\ncontract.secType = 'FUT'\ncontract.symbol = 'MNQ'\ncontract.exchange = 'CME'\ncontract.currency = 'USD'\ncontract.localSymbol = 'MNQZ5'",
      "language": "python",
      "description": "The generic Contract class requires more verbose setup:",
      "sources": [
        "ex_0078_1e17e8a5"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0079_8c44b68b",
      "code": "contract = Contract(conId=495512516)",
      "language": "python",
      "description": "Using conId (contract identifier) provides the most precise identification when known:",
      "sources": [
        "ex_0079_8c44b68b"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0080_52d6cf6d",
      "code": "# Single contract\ncontract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\n# Multiple contracts concurrently\ncontracts = [\n    Future('ES', '202506', 'CME'),\n    Future('NQ', '202506', 'CME'),\n    Future('CL', '202506', 'NYMEX')\n]\nqualified = ib.qualifyContracts(*contracts)",
      "language": "python",
      "description": "Qualification sends a contract details request to IB servers, fills in missing fields (especially conId, localSymbol, multiplier, exact expiry date, tradingClass), and returns a list of successfully q...",
      "sources": [
        "ex_0080_52d6cf6d"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0081_642b54b4",
      "code": "contract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\nif qualified:\n    contract = qualified[0]\n    print(f\"ConId: {contract.conId}\")\n    print(f\"Local Symbol: {contract.localSymbol}\")\n    print(f\"Expiry: {contract.lastTradeDateOrContractMonth}\")",
      "language": "python",
      "description": "The method updates the contract object in-place when successful:",
      "sources": [
        "ex_0081_642b54b4"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0082_b5e51137",
      "code": "# Too vague - multiple matches\ncontract = Future('ES', exchange='CME')\nib.qualifyContracts(contract)\n# Warning: Ambiguous contract, possibles are [Future('ES', '202506'), ...]\n\n# Specific - unambiguous\ncontract = Future('ES', '202506', 'CME')\nib.qualifyContracts(contract)  # Success\n\n# Or use localSymbol\ncontract = Future('ES', exchange='CME', localSymbol='ESM6')\nib.qualifyContracts(contract)  # Success\n\n# Or use conId (most precise)\ncontract = Contract(conId=495512516)\nib.qualifyContracts(contract)  # Always unambiguous",
      "language": "python",
      "description": "When multiple contracts match your specification, qualifyContracts() logs a warning with possible matches. The solution: be more specific with contract details.",
      "sources": [
        "ex_0082_b5e51137"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0083_62498bd6",
      "code": "def validate_futures_contract(ib, contract):\n    \"\"\"Validate and qualify a futures contract\"\"\"\n    try:\n        qualified = ib.qualifyContracts(contract)\n        if not qualified:\n            print(f\"ERROR: Contract could not be qualified\")\n            return None\n        \n        contract = qualified[0]\n        print(f\"\u2713 Qualified: {contract.localSymbol}\")\n        print(f\"  ConId: {contract.conId}\")\n        print(f\"  Expiry: {contract.lastTradeDateOrContractMonth}\")\n        return contract\n    except Exception as e:\n        print(f\"ERROR: {e}\")\n        return None\n\n# Usage\ncontract = Future('ES', '202506', 'CME')\nvalidated = validate_futures_contract(ib, contract)\nif validated:\n    order = MarketOrder('BUY', 1)\n    trade = ib.placeOrder(validated, order)",
      "language": "python",
      "description": "Always validate and handle qualification failures before placing orders:",
      "sources": [
        "ex_0083_62498bd6"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0084_7ced81f4",
      "code": "contract = Future('ES', '202506', 'CME')\ndetails_list = ib.reqContractDetails(contract)\n\nfor details in details_list:\n    print(f\"ConId: {details.contract.conId}\")\n    print(f\"Local Symbol: {details.contract.localSymbol}\")\n    print(f\"Expiry: {details.contract.lastTradeDateOrContractMonth}\")\n    print(f\"Multiplier: {details.contract.multiplier}\")\n    print(f\"Min Tick: {details.minTick}\")\n    print(f\"Market Name: {details.marketName}\")",
      "language": "python",
      "description": "Use reqContractDetails() to get comprehensive contract information beyond basic qualification:",
      "sources": [
        "ex_0084_7ced81f4"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0085_ff9da4c6",
      "code": "# Request data for expired contract\ncontract = Future('ES', '202012', 'CME')\ncontract.includeExpired = True\n\nqualified = ib.qualifyContracts(contract)\nif qualified:\n    bars = ib.reqHistoricalData(\n        qualified[0],\n        endDateTime='',\n        durationStr='1 Y',\n        barSizeSetting='1 day',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    print(f\"Retrieved {len(bars)} bars\")",
      "language": "python",
      "description": "The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl...",
      "sources": [
        "ex_0085_ff9da4c6"
      ],
      "tags": [
        "contract",
        "data",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0086_5032bbea",
      "code": "from datetime import datetime\n\ndef get_front_month_contract(ib, symbol, exchange):\n    \"\"\"Get the front month futures contract\"\"\"\n    contract = Future(symbol, exchange=exchange)\n    contract_details = ib.reqContractDetails(contract)\n    \n    if not contract_details:\n        return None\n    \n    now = datetime.now()\n    active_contracts = []\n    \n    for details in contract_details:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(expiry_str, '%Y%m')\n        \n        if expiry > now:\n            active_contracts.append((expiry, details.contract))\n    \n    if not active_contracts:\n        return None\n    \n    # Sort and return front month\n    active_contracts.sort(key=lambda x: x[0])\n    front_month = active_contracts[0][1]\n    \n    qualified = ib.qualifyContracts(front_month)\n    return qualified[0] if qualified else None\n\n# Usage\nes_front = get_front_month_contract(ib, 'ES', 'CME')\nprint(f\"Front month: {es_front.localSymbol}\")",
      "language": "python",
      "description": "Implement automatic front month detection to handle contract rollovers:",
      "sources": [
        "ex_0086_5032bbea"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0087_bdec6e72",
      "code": "def check_rollover_needed(contract, days_before=5):\n    \"\"\"Check if rollover needed\"\"\"\n    expiry_str = contract.lastTradeDateOrContractMonth\n    if len(expiry_str) == 8:\n        expiry = datetime.strptime(expiry_str, '%Y%m%d')\n    else:\n        expiry = datetime.strptime(expiry_str + '01', '%Y%m%d')\n    \n    days_to_expiry = (expiry - datetime.now()).days\n    return days_to_expiry <= days_before",
      "language": "python",
      "description": "Check if rollover is needed based on days to expiry:",
      "sources": [
        "ex_0087_bdec6e72"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0088_0333ca26",
      "code": "# Continuous futures (historical data only)\ncont_future = ContFuture('ES', 'CME')\nib.qualifyContracts(cont_future)\n\nbars = ib.reqHistoricalData(\n    cont_future,\n    endDateTime='',\n    durationStr='2 Y',\n    barSizeSetting='1 day',\n    whatToShow='TRADES',\n    useRTH=True\n)",
      "language": "python",
      "description": "ContFuture provides rolled contract data for backtesting but has significant limitations:",
      "sources": [
        "ex_0088_0333ca26"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0089_aa3f4ca5",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Subscribe to market data\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data to populate\nib.sleep(2)\n\n# Access real-time data\nprint(f\"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}\")",
      "language": "python",
      "description": "The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:",
      "sources": [
        "ex_0089_aa3f4ca5"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0090_63eb797f",
      "code": "# Request time & sales data\nticker = ib.reqMktData(contract, '233', False, False)\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}\")",
      "language": "python",
      "description": "The genericTickList parameter requests specific data fields using tick IDs: 100 (options volume), 101 (options open interest), 106 (implied volatility), 165 (52-week high/low), 233 (time & sales with ...",
      "sources": [
        "ex_0090_63eb797f"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0091_57100ddd",
      "code": "contract = Forex('EURUSD')\n\n# Request 5-second bars\nbars = ib.reqRealTimeBars(\n    contract,\n    5,              # Bar size (only 5 seconds supported)\n    'MIDPOINT',     # Can be TRADES, MIDPOINT, BID, or ASK\n    False           # useRTH\n)\n\n# Access bars list\nprint(bars[-1])  # Most recent bar",
      "language": "python",
      "description": "Provides 5-second aggregated bars, the only bar size supported by Interactive Brokers for real-time bar streaming:",
      "sources": [
        "ex_0091_57100ddd"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0091",
      "code": "contract = Stock('TSLA', 'SMART', 'USD')\n\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    formatDate=1,\n    keepUpToDate=True  # Enables live updates\n)",
      "language": "python",
      "description": "Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing.",
      "sources": [
        "ex_0092_27c9aee2",
        "ex_0244_39f6deda"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Example 1 includes formatDate=1 while Example 2 omits it. Example 2 explicitly mentions bars.updateEvent firing on changes. Both agree on core parameters. Contract creation shown in Example 1 but not Example 2.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0093_43b2c4bd",
      "code": "contract = Forex('EURUSD')\n\nticker = ib.reqTickByTickData(\n    contract,\n    'BidAsk',  # Can be Last, AllLast, BidAsk, or MidPoint\n    0,         # numberOfTicks (0 = unlimited)\n    False      # ignoreSize\n)\n\n# Access tick-by-tick data\nprint(ticker.tickByTicks)",
      "language": "python",
      "description": "The most granular data stream, providing every individual tick from the exchange. Limited to 3 simultaneous subscriptions per client:",
      "sources": [
        "ex_0093_43b2c4bd"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0094_b590c4c9",
      "code": "contract = Forex('EURUSD')\n\nticker = ib.reqMktDepth(contract)\nib.sleep(2)\n\n# Access order book\nprint(\"Bids:\", [(d.price, d.size) for d in ticker.domBids[:5]])\nprint(\"Asks:\", [(d.price, d.size) for d in ticker.domAsks[:5]])",
      "language": "python",
      "description": "Order book (Level II) data showing bid and ask depth. Requires Level II market data subscription:",
      "sources": [
        "ex_0094_b590c4c9"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0095_c4cd43da",
      "code": "def onTickerUpdate(ticker):\n    print(f\"{ticker.contract.symbol}: Last {ticker.last}\")\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTickerUpdate\n\nib.run()",
      "language": "python",
      "description": "Individual ticker events for ticker-specific logic:",
      "sources": [
        "ex_0095_c4cd43da"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0096_ed4bca13",
      "code": "contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\ndef onPendingTickers(tickers):\n    \"\"\"Called when any subscribed ticker has new data\"\"\"\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.last}\")\n\nib.pendingTickersEvent += onPendingTickers\nib.run()",
      "language": "python",
      "description": "Global pendingTickersEvent for monitoring multiple tickers efficiently:",
      "sources": [
        "ex_0096_ed4bca13"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0097_3e1b5da3",
      "code": "def onBarUpdate(bars, hasNewBar):\n    \"\"\"\n    bars: BarDataList containing all bars\n    hasNewBar: Boolean indicating if a new bar was added\n    \"\"\"\n    if hasNewBar:\n        latest = bars[-1]\n        print(f\"New bar: O={latest.open}, H={latest.high}, \"\n              f\"L={latest.low}, C={latest.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += onBarUpdate\nib.run()",
      "language": "python",
      "description": "Bar update events for streaming bar data:",
      "sources": [
        "ex_0097_3e1b5da3"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0098_3c54380f",
      "code": "import pandas as pd\n\ncontracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\n# Create DataFrame\ndf = pd.DataFrame(\n    index=[c.pair() for c in contracts],\n    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']\n)\n\ndef onPendingTickers(tickers):\n    for t in tickers:\n        df.loc[t.contract.pair()] = (\n            t.bidSize, t.bid, t.ask, t.askSize, \n            t.high, t.low, t.close\n        )\n    print(df)\n\nib.pendingTickersEvent += onPendingTickers\nib.sleep(30)",
      "language": "python",
      "description": "Combine ibinsync with pandas for structured data handling:",
      "sources": [
        "ex_0098_3c54380f"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0099_24d7046c",
      "code": "# WRONG - blocks everything\nimport time\n\ndef onTickerUpdate(ticker):\n    time.sleep(5)  # Frozen!\n    process(ticker)\n\n# CORRECT - yields control\ndef onTickerUpdate(ticker):\n    ib.sleep(0)  # Yields to allow message processing\n    process(ticker)",
      "language": "python",
      "description": "Never use time.sleep() in callbacks or main code\u2014it freezes the event loop and prevents message processing. Always use ib.sleep() to yield control.",
      "sources": [
        "ex_0099_24d7046c"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0100_bd27cf80",
      "code": "def onTickerUpdate(ticker):\n    for i in range(1000):\n        process_chunk(i)\n        if i % 100 == 0:\n            ib.sleep(0)  # Yield every 100 iterations",
      "language": "python",
      "description": "For long-running operations, yield control periodically:",
      "sources": [
        "ex_0100_bd27cf80"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0101_46f5524b",
      "code": "for contract in large_contract_list:\n    ticker = ib.reqMktData(contract)\n    ib.sleep(0.02)  # Small delay between requests",
      "language": "python",
      "description": "ibinsync automatically throttles requests to 45 requests per second, compatible with TWS/Gateway 974+. No manual intervention needed for individual requests, but spread out batch operations:",
      "sources": [
        "ex_0101_46f5524b"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0102_2681b27b",
      "code": "active_subscriptions = set()\nMAX_SUBSCRIPTIONS = 95  # Leave margin\n\ndef subscribe_with_limit(contract):\n    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:\n        # Unsubscribe oldest\n        oldest = active_subscriptions.pop()\n        ib.cancelMktData(oldest)\n    \n    ticker = ib.reqMktData(contract)\n    active_subscriptions.add(contract)\n    return ticker",
      "language": "python",
      "description": "Interactive Brokers limits concurrent subscriptions: typically 100 for market data lines, only 3 for tick-by-tick data.",
      "sources": [
        "ex_0102_2681b27b"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0103_922900ca",
      "code": "class TickerManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.contracts = {}\n        \n    def subscribe(self, symbol, exchange='SMART', currency='USD'):\n        contract = Stock(symbol, exchange, currency)\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract)\n        ticker.updateEvent += self.onUpdate\n        \n        self.tickers[symbol] = ticker\n        self.contracts[symbol] = contract\n        return ticker\n    \n    def unsubscribe(self, symbol):\n        if symbol in self.tickers:\n            self.ib.cancelMktData(self.contracts[symbol])\n            del self.tickers[symbol]\n            del self.contracts[symbol]\n    \n    def onUpdate(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n\n# Usage\nmanager = TickerManager(ib)\nmanager.subscribe('AAPL')\nmanager.subscribe('GOOGL')",
      "language": "python",
      "description": "Encapsulate subscription management in a reusable class:",
      "sources": [
        "ex_0103_922900ca"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0104_14f4249a",
      "code": "# WRONG\ncontract1 = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract1)\n\ncontract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!\nib.cancelMktData(contract2)  # Won't work\n\n# CORRECT\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nib.cancelMktData(contract)  # Use same object",
      "language": "python",
      "description": "Critical: Use the same contract object for cancellation that you used for subscription. Creating a new identical contract won't work\u2014object identity matters.",
      "sources": [
        "ex_0104_14f4249a"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0105_d552e908",
      "code": "ib.cancelMktData(contract)\nib.cancelRealTimeBars(bars)\nib.cancelHistoricalData(bars)\nib.cancelTickByTickData(contract, 'BidAsk')\nib.cancelMktDepth(contract)",
      "language": "python",
      "description": "Cancel different data types with specific methods:",
      "sources": [
        "ex_0105_d552e908"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0106_f97028f9",
      "code": "ticker.updateEvent += handler\n# Later...\nticker.updateEvent -= handler\nib.cancelMktData(contract)",
      "language": "python",
      "description": "Remove event handlers before unsubscribing to prevent memory leaks:",
      "sources": [
        "ex_0106_f97028f9"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0107_7cda9f41",
      "code": "def shutdown():\n    # Cancel all subscriptions\n    for contract in active_contracts:\n        ib.cancelMktData(contract)\n    \n    # Allow cancellations to process\n    ib.sleep(1)\n    \n    # Disconnect\n    ib.disconnect()\n\ntry:\n    ib.run()\nfinally:\n    shutdown()",
      "language": "python",
      "description": "Proper shutdown procedure:",
      "sources": [
        "ex_0107_7cda9f41"
      ],
      "tags": [
        "connect",
        "contract",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0108_aa9a9920",
      "code": "# WRONG - ticks cleared before checking\nticker = ib.reqMktData(contract)\nib.sleep(5)\nprint(ticker.ticks)  # Likely empty\n\n# CORRECT - process in event\ndef onUpdate(ticker):\n    for tick in ticker.ticks:\n        process_tick(tick)\n\nticker.updateEvent += onUpdate",
      "language": "python",
      "description": "Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update\u2014process ticks in event handlers when they arrive.",
      "sources": [
        "ex_0108_aa9a9920"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0109_76fc649a",
      "code": "def onBarUpdate(bars, hasNewBar):\n    if len(bars) > 1000:\n        # Keep only last 1000 bars\n        del bars[:len(bars)-1000]",
      "language": "python",
      "description": "Accumulating historical bars: When using keepUpToDate=True, limit buffer size to prevent unbounded memory growth.",
      "sources": [
        "ex_0109_76fc649a"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0110_385aac72",
      "code": "from ib_insync import *\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nclass TradingSystem:\n    def __init__(self):\n        self.ib = IB()\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def connect(self):\n        self.ib.connect('127.0.0.1', 7497, clientId=1)\n        self.ib.errorEvent += self.onError\n        self.ib.pendingTickersEvent += self.onPendingTickers\n        \n    def subscribe(self, symbol):\n        contract = Stock(symbol, 'SMART', 'USD')\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract, '', False, False)\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n    def onPendingTickers(self, tickers):\n        for ticker in tickers:\n            self.process_ticker(ticker)\n            \n    def process_ticker(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n        \n        # Always yield control in callbacks\n        self.ib.sleep(0)\n        \n    def onError(self, reqId, errorCode, errorString, contract):\n        logging.error(f\"Error {errorCode}: {errorString}\")\n        \n    def shutdown(self):\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n        self.ib.sleep(1)\n        self.ib.disconnect()\n        \n    def run(self):\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            print(\"Shutting down...\")\n        finally:\n            self.shutdown()\n\n# Usage\nif __name__ == '__main__':\n    system = TradingSystem()\n    system.connect()\n    system.subscribe('AAPL')\n    system.subscribe('GOOGL')\n    system.run()",
      "language": "python",
      "description": " Production-ready streaming system",
      "sources": [
        "ex_0110_385aac72"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "error",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0111_6bf39739",
      "code": "from ib_insync import *\n\n# Connect to IB\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Correct approach for E-mini S&P 500 futures\nes_contract = Future(symbol='ES', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Micro E-mini Nasdaq-100 futures\nmnq_contract = Future(symbol='MNQ', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Crude Oil futures\ncl_contract = Future(symbol='CL', lastTradeDateOrContractMonth='202506', exchange='NYMEX')\n\n# Qualify the contracts\nqualified_contracts = ib.qualifyContracts(es_contract, mnq_contract, cl_contract)",
      "language": "python",
      "description": "When working with futures contracts in ibinsync, accurate exchange specification is critical. Here's the current correct approach:",
      "sources": [
        "ex_0111_6bf39739"
      ],
      "tags": [
        "connect",
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0112_0d08872d",
      "code": "def get_qualified_futures_contract(ib, symbol, expiry, exchange):\n    \"\"\"Get a fully qualified futures contract ready for trading\"\"\"\n    contract = Future(symbol=symbol, \n                     lastTradeDateOrContractMonth=expiry,\n                     exchange=exchange)\n    \n    # Request complete contract details\n    qualified = ib.qualifyContracts(contract)\n    \n    if not qualified:\n        print(f\"ERROR: Could not qualify {symbol} contract\")\n        return None\n        \n    # Return the fully qualified contract\n    return qualified[0]\n\n# Example usage\nes_contract = get_qualified_futures_contract(ib, 'ES', '202506', 'CME')\nprint(f\"ConId: {es_contract.conId}, LocalSymbol: {es_contract.localSymbol}\")",
      "language": "python",
      "description": "For real-time futures trading, always fully qualify your contracts to ensure proper execution:",
      "sources": [
        "ex_0112_0d08872d"
      ],
      "tags": [
        "contract",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0113_777eef12",
      "code": "def get_contract_by_symbol(ib, local_symbol):\n    \"\"\"Get contract using local symbol (e.g., 'ESM6')\"\"\"\n    # Parse the local symbol\n    root = ''.join([c for c in local_symbol if c.isalpha()])\n    suffix = ''.join([c for c in local_symbol if not c.isalpha()])\n    \n    # Extract month code and year\n    month_code = suffix[0] if len(suffix) > 0 else ''\n    year_code = suffix[1:] if len(suffix) > 1 else ''\n    \n    # Create generic contract\n    contract = Contract()\n    contract.secType = 'FUT'\n    contract.symbol = root\n    contract.exchange = get_exchange_for_symbol(root)  # Helper function\n    contract.localSymbol = local_symbol\n    \n    # Qualify the contract\n    qualified = ib.qualifyContracts(contract)\n    return qualified[0] if qualified else None\n\ndef get_exchange_for_symbol(symbol):\n    \"\"\"Get correct exchange for common futures symbols\"\"\"\n    exchanges = {\n        'ES': 'CME', 'MES': 'CME', 'NQ': 'CME', 'MNQ': 'CME',\n        'RTY': 'CME', 'M2K': 'CME', 'YM': 'CBOT', 'MYM': 'CBOT',\n        'CL': 'NYMEX', 'GC': 'NYMEX', 'SI': 'NYMEX', 'HG': 'NYMEX',\n        'ZB': 'CBOT', 'ZN': 'CBOT', 'ZF': 'CBOT', 'ZT': 'CBOT',\n        '6E': 'CME', '6A': 'CME', '6B': 'CME', '6J': 'CME'\n    }\n    return exchanges.get(symbol, 'SMART')",
      "language": "python",
      "description": "| Month | Code | Example |\n|-------|------|---------|\n| January | F | ESF6 (ES Jan 2026) |\n| February | G | ESG6 (ES Feb 2026) |\n| March | H | ESH6 (ES Mar 2026) |\n| April | J | ESJ6 (ES Apr 2026) |\n|...",
      "sources": [
        "ex_0113_777eef12"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0114_dcf476f2",
      "code": "# Trailing stop for ES futures\ndef place_es_trailing_stop(ib, action, quantity, trail_amount):\n    \"\"\"Place a trailing stop order for ES futures\"\"\"\n    # Get current front month ES contract\n    es = get_front_month_contract(ib, 'ES', 'CME')\n    \n    # Create trailing stop order\n    order = Order()\n    order.action = action  # 'BUY' or 'SELL'\n    order.orderType = 'TRAIL'\n    order.totalQuantity = quantity\n    order.auxPrice = trail_amount  # Trail amount in points\n    \n    # Place the order\n    trade = ib.placeOrder(es, order)\n    return trade\n\n# Market-Limit OCO for MNQ futures\ndef place_mnq_market_limit_oco(ib, action, quantity, limit_price):\n    \"\"\"Place a market-limit OCO order for MNQ futures\"\"\"\n    # Get current front month MNQ contract\n    mnq = get_front_month_contract(ib, 'MNQ', 'CME')\n    \n    # Create OCO orders\n    market_order = MarketOrder(action, quantity)\n    limit_order = LimitOrder(action, quantity, limit_price)\n    \n    # Set up OCO group\n    oca_group = f\"MNQ_OCO_{int(time.time())}\"  # Unique group ID\n    \n    market_order.ocaGroup = oca_group\n    market_order.ocaType = 2  # Proportional\n    \n    limit_order.ocaGroup = oca_group\n    limit_order.ocaType = 2\n    \n    # Place orders\n    trade1 = ib.placeOrder(mnq, market_order)\n    trade2 = ib.placeOrder(mnq, limit_order)\n    \n    return [trade1, trade2]",
      "language": "python",
      "description": "For futures trading, complex order types like OCO and trailing stops require careful setup:",
      "sources": [
        "ex_0114_dcf476f2"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0115_e6c51488",
      "code": "class FuturesDataManager:\n    \"\"\"Manage real-time data for multiple futures contracts\"\"\"\n    \n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def subscribe(self, symbol, exchange='CME'):\n        \"\"\"Subscribe to real-time market data for a futures contract\"\"\"\n        # Get front month contract\n        contract = get_front_month_contract(self.ib, symbol, exchange)\n        \n        if not contract:\n            print(f\"Error: Could not find front month contract for {symbol}\")\n            return None\n            \n        # Request market data\n        ticker = self.ib.reqMktData(contract, '', False, False)\n        \n        # Store references\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n        return ticker\n        \n    def get_price(self, symbol):\n        \"\"\"Get current price for a subscribed symbol\"\"\"\n        if symbol not in self.tickers:\n            return None\n            \n        ticker = self.tickers[symbol]\n        \n        # Use last or midpoint price\n        if ticker.last:\n            return ticker.last\n        elif ticker.bid and ticker.ask:\n            return (ticker.bid + ticker.ask) / 2\n        else:\n            return None\n    \n    def get_contracts_expiring_soon(self, days_threshold=10):\n        \"\"\"Get list of contracts expiring soon\"\"\"\n        expiring_soon = []\n        now = datetime.now()\n        \n        for contract in self.active_contracts:\n            expiry_str = contract.lastTradeDateOrContractMonth\n            \n            if len(expiry_str) == 8:  # YYYYMMDD format\n                expiry = datetime.strptime(expiry_str, '%Y%m%d')\n            else:  # YYYYMM format\n                expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n                \n            days_to_expiry = (expiry - now).days\n            \n            if days_to_expiry <= days_threshold:\n                expiring_soon.append((contract, days_to_expiry))\n                \n        return expiring_soon\n        \n    def cleanup(self):\n        \"\"\"Unsubscribe from all market data\"\"\"\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n            \n        self.tickers.clear()\n        self.active_contracts.clear()",
      "language": "python",
      "description": "For live futures data, proper subscription management is essential:",
      "sources": [
        "ex_0115_e6c51488"
      ],
      "tags": [
        "contract",
        "data",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0116_d1d3b777",
      "code": "def get_continuous_futures_data(ib, symbol, exchange, duration='1 Y', bar_size='1 day'):\n    \"\"\"Get historical data for continuous futures contract\"\"\"\n    # Create a ContFuture for historical data\n    contract = ContFuture(symbol, exchange)\n    ib.qualifyContracts(contract)\n    \n    # Request historical data\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=bar_size,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    \n    return bars\n\n# Get front month based on volume/open interest\ndef get_most_liquid_contract(ib, symbol, exchange):\n    \"\"\"Get the most liquid contract based on volume and open interest\"\"\"\n    # Get all active contracts for this symbol\n    contract = Future(symbol, exchange=exchange)\n    details_list = ib.reqContractDetails(contract)\n    \n    if not details_list:\n        return None\n    \n    # Filter out expired contracts\n    now = datetime.now()\n    active_contracts = []\n    \n    for details in details_list:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        \n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n            \n        if expiry > now:\n            active_contracts.append(details.contract)\n    \n    if not active_contracts:\n        return None\n    \n    # Get volume data for each contract\n    contract_data = []\n    \n    for contract in active_contracts:\n        ticker = ib.reqMktData(contract, '100,101', False, False)  # Request volume and OI\n        ib.sleep(1)  # Allow data to populate\n        \n        contract_data.append({\n            'contract': contract,\n            'volume': ticker.volume or 0,\n            'openInterest': ticker.openInterest or 0\n        })\n        \n        # Cancel the market data request\n        ib.cancelMktData(contract)\n    \n    # Sort by combined volume and open interest\n    contract_data.sort(key=lambda x: x['volume'] + x['openInterest'], reverse=True)\n    \n    # Return the most liquid contract\n    return contract_data[0]['contract'] if contract_data else None",
      "language": "python",
      "description": "For continuous futures analysis, use a combination of reqHistoricalData and dynamic front-month tracking:",
      "sources": [
        "ex_0116_d1d3b777"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0117_03a78138",
      "code": "class FuturesTradingSystem:\n    \"\"\"Complete futures trading system with proper state management\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        \n        self.active_contracts = {}  # symbol -> contract\n        self.active_orders = {}     # orderId -> order\n        self.active_positions = {}  # symbol -> position\n        \n        # Setup logger\n        self.logger = self._setup_logger()\n        \n    def _setup_logger(self):\n        logger = logging.getLogger('FuturesTradingSystem')\n        logger.setLevel(logging.INFO)\n        \n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        \n        return logger\n        \n    def connect(self):\n        \"\"\"Connect to IB and initialize state\"\"\"\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(f\"Connected to IB ({self.host}:{self.port})\")\n            \n            # Setup event handlers\n            self.ib.errorEvent += self._handle_error\n            self.ib.positionEvent += self._handle_position\n            self.ib.orderStatusEvent += self._handle_order_status\n            \n            # Initialize positions\n            self._update_positions()\n            \n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _update_positions(self):\n        \"\"\"Update current positions\"\"\"\n        positions = self.ib.positions()\n        \n        for position in positions:\n            if position.contract.secType == 'FUT':\n                symbol = position.contract.symbol\n                self.active_positions[symbol] = position\n                self.logger.info(f\"Current position: {symbol}: {position.position}\")\n    \n    def _handle_position(self, position):\n        \"\"\"Handle position updates\"\"\"\n        if position.contract.secType == 'FUT':\n            symbol = position.contract.symbol\n            self.active_positions[symbol] = position\n            self.logger.info(f\"Position update: {symbol}: {position.position}\")\n    \n    def _handle_order_status(self, trade):\n        \"\"\"Handle order status updates\"\"\"\n        orderId = trade.order.orderId\n        status = trade.orderStatus.status\n        \n        self.logger.info(f\"Order {orderId} status: {status}\")\n        \n        # Store active orders\n        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:\n            self.active_orders[orderId] = trade\n        # Remove completed orders\n        elif status in ['Filled', 'Cancelled', 'Inactive']:\n            if orderId in self.active_orders:\n                del self.active_orders[orderId]\n    \n    def _handle_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle error events\"\"\"\n        self.logger.error(f\"Error {errorCode}: {errorString}\")\n        \n        # Handle connection issues\n        if errorCode in [1100, 1101, 1102]:\n            self.logger.critical(\"Connection issue detected!\")\n    \n    def get_contract(self, symbol, expiry, exchange):\n        \"\"\"Get a fully qualified futures contract\"\"\"\n        contract_key = f\"{symbol}_{expiry}_{exchange}\"\n        \n        # Use cached contract if available\n        if contract_key in self.active_contracts:\n            return self.active_contracts[contract_key]\n            \n        # Otherwise qualify a new one\n        contract = Future(symbol=symbol, \n                         lastTradeDateOrContractMonth=expiry,\n                         exchange=exchange)\n        \n        qualified = self.ib.qualifyContracts(contract)\n        \n        if not qualified:\n            self.logger.error(f\"Failed to qualify contract: {symbol} {expiry}\")\n            return None\n            \n        qualified_contract = qualified[0]\n        self.active_contracts[contract_key] = qualified_contract\n        \n        return qualified_contract\n    \n    def place_market_order(self, symbol, expiry, exchange, action, quantity):\n        \"\"\"Place market order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = MarketOrder(action, quantity)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} market order for {quantity} {symbol}\")\n        return trade\n    \n    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):\n        \"\"\"Place limit order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = LimitOrder(action, quantity, price)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} limit order for {quantity} {symbol} @ {price}\")\n        return trade\n    \n    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, \n                          entry_price, profit_price, stop_price):\n        \"\"\"Place bracket order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        # Create bracket orders\n        bracket = self.ib.bracketOrder(\n            action,\n            quantity,\n            entry_price,\n            profit_price,\n            stop_price\n        )\n        \n        # Place all orders\n        trades = []\n        for order in bracket:\n            trade = self.ib.placeOrder(contract, order)\n            trades.append(trade)\n        \n        self.logger.info(f\"Placed bracket order for {quantity} {symbol}\")\n        return trades\n    \n    def cancel_all_orders(self):\n        \"\"\"Cancel all open orders\"\"\"\n        open_trades = self.ib.openTrades()\n        for trade in open_trades:\n            if not trade.isDone():\n                self.ib.cancelOrder(trade.order)\n                self.logger.info(f\"Cancelled order {trade.order.orderId}\")\n    \n    def get_position(self, symbol):\n        \"\"\"Get current position for symbol\"\"\"\n        return self.active_positions.get(symbol)\n    \n    def close_position(self, symbol):\n        \"\"\"Close position for symbol\"\"\"\n        position = self.get_position(symbol)\n        \n        if not position or position.position == 0:\n            self.logger.info(f\"No position to close for {symbol}\")\n            return None\n        \n        # Create closing order\n        action = 'SELL' if position.position > 0 else 'BUY'\n        quantity = abs(position.position)\n        \n        return self.place_market_order(\n            symbol,\n            position.contract.lastTradeDateOrContractMonth,\n            position.contract.exchange,\n            action,\n            quantity\n        )\n    \n    def run(self):\n        \"\"\"Run the system indefinitely\"\"\"\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            self.logger.info(\"Shutting down...\")\n        finally:\n            # Cleanup on exit\n            self.cancel_all_orders()\n            self.ib.disconnect()\n            self.logger.info(\"Disconnected from IB\")",
      "language": "python",
      "description": "Here's a more comprehensive structure for a futures trading system:",
      "sources": [
        "ex_0117_03a78138"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0118_9050e9e9",
      "code": "pip install ib_insync\n\n\nfrom ib_insync import *\n# util.startLoop() # uncomment this line when in a notebook\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\ncontract, endDateTime='', durationStr='30 D',\nbarSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)\n\n# convert to pandas dataframe:\ndf = util.df(bars)\nprint(df)",
      "language": "python",
      "description": " Code Examples\n- Fetching consecutive historical data\n- Async streaming ticks\n- Scanner data (blocking)\n- Scanner data (streaming)\n- Option calculations\n- Order book\n- Minimum price increments\n- News ...",
      "sources": [
        "ex_0118_9050e9e9"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0119_672d75df",
      "code": "events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',\n          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',\n          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',\n          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',\n          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',\n          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',\n          'timeoutEvent')\n\nRequestTimeout: float = 0\nRaiseRequestErrors: bool = False\nMaxSyncedSubAccounts: int = 50\nTimezoneTWS = None\n\n#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\nConnect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.\n**This method is blocking.**\n**Parameters:**\n- **host** (str) - Host name or IP address.\n- **port** (int) - Port number.\n- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.\n- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n- **readonly** (bool) - Set to True when API is in read-only mode.\n- **account** (str) - Main account to receive updates for.\n- \n#### disconnect()\nDisconnect from a TWS or IB gateway application. This will clear all session state.\n\n#### isConnected()\nIs there an API connection to TWS or IB gateway?\n**Return type:** bool\n\n#### static run(*, timeout=None)\nBy default run the event loop forever.\nWhen awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.\nAn optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.\n\n#### static schedule(callback, *args)\nSchedule the callback to be run at the given time with the given arguments. This will return the Event Handle.\n**Parameters:**\n- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.\n- **callback** (Callable) - Callable scheduled to run.\n- **args** - Arguments for to call callback with.\n\n#### static sleep()\nWait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.\n**Parameters:**\n- **secs** (float) - Time in seconds to wait.\n**Return type:** bool\n\n#### static timeRange(end, step)\nIterator that waits periodically until certain time points are reached while yielding those time points.\n**Parameters:**\n- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **step** (float) - The number of seconds of each period\n**Return type:** Iterator[datetime]\n\n#### static timeRangeAsync(end, step)\nAsync version of timeRange().\n**Return type:** AsyncIterator[datetime]\n\n#### static waitUntil()\nWait until the given time t is reached.\n**Parameters:**\n- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.\n**Return type:** bool\n\n#### waitOnUpdate(timeout=0)\nWait on any new update to arrive from the network.\n**Parameters:**\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used\n**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.\n**Return type:** bool\n**Returns:** True if not timed-out, False otherwise.\n\n#### loopUntil(condition=None, timeout=0)\nIterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.\n**Parameters:**\n- **condition** - Predicate function that is tested after every network update.\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.\n**Return type:** Iterator[object]\n\n#### setTimeout(timeout=60)\nSet a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.\nThe timeout fires once per connected session but can be set again after firing or after a reconnect.\n**Parameters:**\n- **timeout** (float) - Timeout in seconds.\n\n#### managedAccounts()\nList of account names.\n**Return type:** List[str]\n\n#### accountValues(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### accountSummary(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**This method is blocking on first run, non-blocking after that.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### portfolio()\nList of portfolio items of the default account.\n**Return type:** List[PortfolioItem]\n\n#### positions(account='')\nList of positions for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[Position]\n\n#### pnl(account='', modelCode='')\nList of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.\n**Parameters:**\n- **account** - If specified, filter for this account name.\n- **modelCode** - If specified, filter for this account model.\n**Return type:** List[PnL]\n\n#### pnlSingle(account='', modelCode='', conId=0)\nList of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n- **conId** (int) - If specified, filter for this contract ID.\n**Return type:** List[PnLSingle]\n\n#### trades()\nList of all order trades from this session.\n**Return type:** List[Trade]\n\n#### openTrades()\nList of all open order trades.\n**Return type:** List[Trade]\n\n#### orders()\nList of all orders from this session.\n**Return type:** List[Order]\n\n#### openOrders()\nList of all open orders.\n**Return type:** List[Order]\n\n#### fills()\nList of all fills from this session.\n**Return type:** List[Fill]\n\n#### executions()\nList of all executions from this session.\n**Return type:** List[Execution]\n\n#### ticker(contract)\nGet ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().\n**Parameters:**\n- **contract** (Contract) - Contract to get ticker for.\n**Return type:** Ticker\n\n#### tickers()\nGet a list of all tickers.\n**Return type:** List[Ticker]\n\n#### pendingTickers()\nGet a list of all tickers that have pending ticks or domTicks.\n**Return type:** List[Ticker]\n\n#### realtimeBars()\nGet a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.\n**Return type:** List[Union[BarDataList, RealTimeBarList]]\n\n#### newsTicks()\nList of ticks with headline news. The article itself can be retrieved with reqNewsArticle().\n**Return type:** List[NewsTick]\n\n#### newsBulletins()\nList of IB news bulletins.\n**Return type:** List[NewsBulletin]\n\n#### reqTickers(*contracts, regulatorySnapshot=False)\nRequest and return a list of snapshot tickers. The list is returned when all tickers are ready.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to get tickers for.\n- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).\n**Return type:** List[Ticker]\n\n#### qualifyContracts(*contracts)\nFully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to qualify.\n**Return type:** List[Contract]\n\n#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)\nCreate a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:\n\nfor o in bracket:\n    ib.placeOrder(contract, o)\n**Parameters:**\n- **action** (str) - 'BUY' or 'SELL'.\n- **quantity** (float) - Size of order.\n- **limitPrice** (float) - Limit price of entry order.\n- **takeProfitPrice** (float) - Limit price of profit order.\n- **stopLossPrice** (float) - Stop price of loss order.\n**Return type:** BracketOrder\n\n#### static oneCancelsAll(orders, ocaGroup, ocaType)\nPlace the trades in the same One Cancels All (OCA) group.\nhttps://interactivebrokers.github.io/tws-api/oca.html\n**Parameters:**\n- **orders** (List[Order]) - The orders that are to be placed together.\n**Return type:** List[Order]\n\n#### whatIfOrder(contract, order)\nRetrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.\n**This method is blocking.**\n**Parameters:**\n- **contract** (Contract) - Contract to test.\n- **order** (Order) - Order to test.\n**Return type:** OrderState\n\n#### placeOrder(contract, order)\nPlace a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.\n**Parameters:**\n- **contract** (Contract) - Contract to use for order.\n- **order** (Order) - The order to be placed.\n**Return type:** Trade\n\n#### cancelOrder(order, manualCancelOrderTime='')\nCancel the order and return the Trade it belongs to.\n**Parameters:**\n- **order** (Order) - The order to be canceled.\n- **manualCancelOrderTime** (str) - For audit trail.\n**Return type:** Trade\n\n#### reqGlobalCancel()\nCancel all active trades including those placed by other clients or TWS/IB gateway.\n\n#### reqCurrentTime()\nRequest TWS current time.\n**This method is blocking.**\n**Return type:** datetime\n\n#### reqAccountUpdates(account='')\nThis is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n\n#### reqAccountUpdatesMulti(account='', modelCode='')\nIt is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n\n#### reqAccountSummary()\nIt is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.\n**This method is blocking.**\n\n#### reqAutoOpenOrders(autoBind=True)\nBind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting \"Use negative numbers to bind automatic orders\" must be checked. This request is automatically called when clientId=0.\nhttps://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html\n\n**Parameters:**\n- **autoBind** (bool) - Set binding on or off.\n\n#### reqOpenOrders()\nRequest and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.\n**This method is blocking.**\n**Return type:** List[Order]\n\n#### reqAllOpenOrders()\nRequest and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.\n**Return type:** List[Order]\n\n#### reqCompletedOrders(apiOnly)\nRequest and return a list of completed trades.\n**Parameters:**\n- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).\n**Return type:** List[Trade]\n\n#### reqExecutions(execFilter=None)\nIt is recommended to use fills() or executions() instead. Request and return a list of fills.\n**This method is blocking.**\n**Parameters:**\n- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.\n**Return type:** List[Fill]\n\n#### reqPositions()\nIt is recommended to use positions() instead. Request and return a list of positions for all accounts.\n**This method is blocking.**\n**Return type:** List[Position]\n\n#### reqPnL(account, modelCode='')\nStart a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - If specified, filter for this account model.\n**Return type:** PnL\n\n#### cancelPnL(account, modelCode='')\nCancel PnL subscription.\n**Parameters:**\n- **account** - Cancel for this account.\n- **modelCode** (str) - If specified, cancel for this account model.\n\n#### reqPnLSingle(account, modelCode, conId)\nStart a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - Filter for this account model.\n- **conId** (int) - Filter for this contract ID.\n**Return type:** PnLSingle\n\n#### cancelPnLSingle(account, modelCode, conId)\nCancel PnLSingle subscription for the given account, modelCode and conId.\n**Parameters:**\n- **account** (str) - Cancel for this account name.\n- **modelCode** (str) - Cancel for this account model.\n- **conId** (int) - Cancel for this contract ID.\n\n#### reqContractDetails(contract)\nGet a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/contract_details.html\n**Parameters:**\n- **contract** (Contract) - The contract to get details for.\n**Return type:** List[ContractDetails]\n\n#### reqMatchingSymbols(pattern)\nRequest contract descriptions of contracts that match a pattern.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/matching_symbols.html\n**Parameters:**\npattern (str) -The first few letters of the ticker symbol, or for longer strings a character\nsequence matching a word in the security name.\nReturn type\nList[ContractDescription]\n\n#### reqMarketRule(marketRuleId)\nRequest price increments rule.\nhttps://interactivebrokers.github.io/tws-api/minimum_increment.html\nParameters\nmarketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-\ntained via reqContractDetails() from ContractDetails.marketRuleIds, which con-\ntains a comma separated string of market rule IDs.\nReturn type\nPriceIncrement\n\n#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])\nRequest realtime 5 second bars.\nhttps://interactivebrokers.github.io/tws-api/realtime_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-barSize (int) -Must be 5.\n-whatToShow (str) -Specifies the source for constructing bars. Can be \u2018TRADES\u2019, \u2018MID-\nPOINT\u2019, \u2018BID\u2019 or \u2018ASK\u2019.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-realTimeBarsOptions (List[TagValue]) -Unknown.\nReturn type\nRealTimeBarList\n\n#### cancelRealTimeBars(bars)\nCancel the realtime bars subscription.\nParameters\nbars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.\n\n#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)\nRequest historical bar data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-durationStr (str) -Time span of all the bars. Examples: \u201860 S\u2019, \u201830 D\u2019, \u201813 W\u2019, \u20186 M\u2019,\n\u201810 Y\u2019.\n-barSizeSetting (str) -Time period of one bar. Must be one of: \u20181 secs\u2019, \u20185 secs\u2019, \u201810\nsecs\u2019 15 secs\u2019, \u201830 secs\u2019, \u20181 min\u2019, \u20182 mins\u2019, \u20183 mins\u2019, \u20185 mins\u2019, \u201810 mins\u2019, \u201815 mins\u2019, \u201820\nmins\u2019, \u201830 mins\u2019, \u20181 hour\u2019, \u20182 hours\u2019, \u20183 hours\u2019, \u20184 hours\u2019, \u20188 hours\u2019, \u20181 day\u2019, \u20181 week\u2019, \u20181\nmonth\u2019.\n-whatToShow (str) -Specifies the source for constructing bars. Must be one\nof: \u2018TRADES\u2019, \u2018MIDPOINT\u2019, \u2018BID\u2019, \u2018ASK\u2019, \u2018BID_ASK\u2019, \u2018ADJUSTED_LAST\u2019, \u2018HIS-\nTORICAL_VOLATILITY\u2019, \u2018OPTION_IMPLIED_VOLATILITY\u2019, \u2018REBATE_RATE\u2019,\n\u2018FEE_RATE\u2019, \u2018YIELD_BID\u2019, \u2018YIELD_ASK\u2019, \u2018YIELD_BID_ASK\u2019, \u2018YIELD_LAST\u2019. For\n\u2018SCHEDULE\u2019 use reqHistoricalSchedule().\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields\nto be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as\nused by TWS.\n-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars\nupdated; endDateTime must be set empty (\u2018\u2019) then.\n-chartOptions (List[TagValue]) -Unknown.\n-timeout (float) -Timeout in seconds after which to cancel the request and return an\nempty bar series. Set to 0 to wait indefinitely.\nReturn type\nBarDataList\n\n#### cancelHistoricalData(bars)\nCancel the update subscription for the historical bars.\nParameters\nbars (BarDataList) -The bar list that was obtained from reqHistoricalData with a\nkeepUpToDate subscription.\n\n\n#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)\nRequest historical schedule.\nThis method is blocking.\nParameters\n-contract (Contract) -Contract of interest.\n-numDays (int) -Number of days.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for\nextended hours.\nReturn type\nHistoricalSchedule\n\n#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nRequest historical ticks. The time resolution of the ticks is one second.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_time_and_sales.html\nParameters\n-contract (Contract) -Contract to query.\n-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-\ntime.datetime, or it can be given as a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no\ntimezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be\ngiven, the other must be blank.\n-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can\ncontain a bit more to accommodate all ticks in the latest second.\n-whatToShow (str) -One of \u2018Bid_Ask\u2019, \u2018Midpoint\u2019 or \u2018Trades\u2019.\n-useRTH -If True then only show data from within Regular Trading Hours, if False then\nshow all data.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\n-miscOptions (List[TagValue]) -Unknown.\nReturn type\nList\n\n#### reqMarketDataType(marketDataType)\nSet the market data type used for reqMktData().\nParameters\nmarketDataType (int) -One of:\n-1 = Live\n-2 = Frozen\n-3 = Delayed\n-4 = Delayed frozen\nhttps://interactivebrokers.github.io/tws-api/market_data_type.html\nreqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)\nGet the datetime of earliest available historical data for the contract.\nParameters\n-contract (Contract) -Contract of interest.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-\ntime.datetime with UTC timezone.\nReturn type\ndatetime\n\n#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,\nmktDataOptions=None)\nSubscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will\ninitially be empty and gradually (after a couple of seconds) be filled.\nhttps://interactivebrokers.github.io/tws-api/md_request.html\nParameters\n-contract (Contract) -Contract of interest.\n-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause\ncorresponding Ticker fields to be filled:\n\nID  Ticker fields\n100 putVolume, callVolume (for options)\n101 putOpenInterest, callOpenInterest (for options)\n104 histVolatility (for options)\n105 avOptionVolume (for options)\n106 impliedVolatility (for options)\n162 indexFuturePremium\n165 low13week, high13week, low26week, high26week, low52week,\nhigh52week, avVolume\n221 markPrice\n225 auctionVolume, auctionPrice, auctionImbalance\n233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 shortableShares\n258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)\n293 tradeCount\n294 tradeRate\n295 volumeRate\n375 rtTradeVolume\n411 rtHistVolatility\n456 dividends (of type ib_insync.objects.Dividends)\n588 futuresOpenInterest\n\n-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a\nstream of realtime tick data.\n-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).\n-mktDataOptions (Optional[List[TagValue]]) -Unknown\nReturn type\nTicker\n\n#### cancelMktData(contract)\nUnsubscribe from realtime streaming tick data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\nreqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)\nSubscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.\nhttps://interactivebrokers.github.io/tws-api/tick_data.html\nParameters\n-contract (Contract) -Contract of interest.\n-tickType (str) -One of \u2018Last\u2019, \u2018AllLast\u2019, \u2018BidAsk\u2019 or \u2018MidPoint\u2019.\n-numberOfTicks (int) -Number of ticks or 0 for unlimited.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\nReturn type\nTicker\n\n#### cancelTickByTickData(contract, tickType)\nUnsubscribe from tick-by-tick data\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqSmartComponents(bboExchange)\nObtain mapping from single letter codes to exchange names.\nNote: The exchanges must be open when using this request, otherwise an empty list is returned.\nReturn type\nList[SmartComponent]\n\n#### reqMktDepthExchanges()\nGet those exchanges that have have multiple market makers (and have ticks returned with marketMaker\ninfo).\nReturn type\nList[DepthMktDataDescription]\n\n#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)\nSubscribe to market depth data (a.k.a. DOM, L2 or order book).\nhttps://interactivebrokers.github.io/tws-api/market_depth.html\nParameters\n-contract (Contract) -Contract of interest.\n-numRows (int) -Number of depth level on each side of the order book (5 max).\n-isSmartDepth (bool) -Consolidate the order book across exchanges.\n-mktDepthOptions -Unknown.\nReturn type\nTicker\nReturns\nThe Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the\nlist of MktDepthData in ticker.domTicks.\n\n#### cancelMktDepth(contract, isSmartDepth=False)\nUnsubscribe from market depth data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqHistogramData(contract, useRTH, period)\nRequest histogram data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/histograms.html\nParameters\n-contract (Contract) -Contract to query.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-period (str) -Period of which data is being requested, for example \u20183 days\u2019.\nReturn type\nList[HistogramData]\n\n#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])\nGet fundamental data of a contract in XML format.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/fundamentals.html\nParameters\n-contract (Contract) -Contract to query.\n-reportType (str) \u2013\n\u2013 \u2018ReportsFinSummary\u2019: Financial summary\n\u2013 \u2019ReportsOwnership\u2019: Company\u2019s ownership\n\u2013 \u2019ReportSnapshot\u2019: Company\u2019s financial overview\n\u2013 \u2019ReportsFinStatements\u2019: Financial Statements\n\u2013 \u2019RESC\u2019: Analyst Estimates\n\u2013 \u2019CalendarReport\u2019: Company\u2019s calendar\n-fundamentalDataOptions (List[TagValue]) -Unknown\nReturn type\nstr\n\n#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])\nDo a blocking market scan by starting a subscription and canceling it after the initial list of results are in.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -Basic filters.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.\nReturn type\nScanDataList\n\n#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nSubscribe to market scan data.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -What to scan for.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.\nReturn type\nScanDataList\n\n#### cancelScannerSubscription(dataList)\nCancel market data subscription.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\ndataList (ScanDataList) -The scan data list that was obtained from\nreqScannerSubscription().\n\n#### reqScannerParameters()\nRequests an XML list of scanner parameters.\nThis method is blocking.\nReturn type\nstr\n\n#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])\nCalculate the volatility given the option price.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-optionPrice (float) -Option price to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions (List[TagValue]) -Unknown\nReturn type\nOptionComputation\n\n#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])\nCalculate the option price given the volatility.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-volatility (float) -Option volatility to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions -Unknown\nReturn type\nOptionComputation\n\n#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nGet the option chain.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-underlyingSymbol (str) -Symbol of underlier contract.\n-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).\n-underlyingSecType (str) -The type of the underlying security, like \u2018STK\u2019 or \u2018FUT\u2019.\n-underlyingConId (int) -conId of the underlying contract.\nReturn type\nList[OptionChain]\n\n#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)\nExercise an options contract.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-contract (Contract) -The option contract to be exercised.\n-exerciseAction (int) \u2013\n\u2013 1 = exercise the option\n\u2013 2 = let the option lapse\n-exerciseQuantity (int) -Number of contracts to be exercised.\n-account (str) -Destination account.\n-override (int) \u2013\n\u2013 0 = no override\n\u2013 1 = override the system\u2019s natural action\n\n#### reqNewsProviders()\nGet a list of news providers.\nThis method is blocking.\nReturn type\nList[NewsProvider]\n\n#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)\nGet the body of a news article.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\n-providerCode (str) -Code indicating news provider, like \u2018BZ\u2019 or \u2018FLY\u2019.\n-articleId (str) -ID of the specific article.\n-newsArticleOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nNewsArticle\n\n#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nGet historical news headline.\nhttps://interactivebrokers.github.io/tws-api/news.html\nThis method is blocking.\nParameters\n-conId (int) -Search news articles for contract with this conId.\n-providerCodes (str) -A \u2018+\u2019-separated list of provider codes, like \u2018BZ+FLY\u2019.\n-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be\ngiven as a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given\nas a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-totalResults (int) -Maximum number of headlines to fetch (300 max).\n-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nHistoricalNews\n\n#### reqNewsBulletins(allMessages)\nSubscribe to IB news bulletins.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\nallMessages (bool) -If True then fetch all messages for the day.\n\n#### cancelNewsBulletins()\nCancel subscription to IB news bulletins.\n\n#### requestFA(faDataType)\nRequests to change the FA configuration.\nThis method is blocking.\nParameters\nfaDataType (int) \u2013\n-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation\nmethod to all accounts in the group.\n-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined\ncalculation value.\n-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than\naccount numbers.\n\n#### replaceFA(faDataType, xml)\nReplaces Financial Advisor\u2019s settings.\nParameters\n-faDataType (int) -See requestFA().\n-xml (str) -The XML-formatted configuration string.\n\n#### reqUserInfo()\nGet the White Branding ID of the user.\nReturn type\nstr\n\n#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\n\n#### async qualifyContractsAsync(*contracts)\nReturn type\nList[Contract]\n\n#### async reqTickersAsync(*contracts, regulatorySnapshot=False)\nReturn type\nList[Ticker]\n\n#### whatIfOrderAsync(contract, order)\nReturn type\nAwaitable[OrderState]\n\n#### reqCurrentTimeAsync()\nReturn type\nAwaitable[datetime]\n\n#### reqAccountUpdatesAsync(account)\nReturn type\nAwaitable[None]\n\n#### reqAccountUpdatesMultiAsync(account, modelCode='')\nReturn type\nAwaitable[None]\n\n#### async accountSummaryAsync(account='')\nReturn type\nList[AccountValue]\n\n#### reqAccountSummaryAsync()\nReturn type\nAwaitable[None]\n\n#### reqOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqAllOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqCompletedOrdersAsync(apiOnly)\nReturn type\nAwaitable[List[Trade]]\n\n#### reqExecutionsAsync(execFilter=None)\nReturn type\nAwaitable[List[Fill]]\n\n#### reqPositionsAsync()\nReturn type\nAwaitable[List[Position]]\n\n#### reqContractDetailsAsync(contract)\nReturn type\nAwaitable[List[ContractDetails]]\n\n#### async reqMatchingSymbolsAsync(pattern)\nReturn type\nOptional[List[ContractDescription]]\n\n#### async reqMarketRuleAsync(marketRuleId)\nReturn type\nOptional[List[PriceIncrement]]\n\n#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,\nuseRTH, formatDate=1, keepUpToDate=False, chartOptions=[],\ntimeout=60)\nReturn type\nBarDataList\n\n#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)\nReturn type\nAwaitable[HistoricalSchedule]\n\n#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nReturn type\nAwaitable[List]\n\n#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)\nReturn type\nAwaitable[datetime]\n\n#### reqSmartComponentsAsync(bboExchange)\n\n#### reqMktDepthExchangesAsync()\nReturn type\nAwaitable[List[DepthMktDataDescription]]\n\n#### reqHistogramDataAsync(contract, useRTH, period)\nReturn type\nAwaitable[List[HistogramData]]\n\n#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])\nReturn type\nAwaitable[str]\n\n#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nReturn type\nScanDataList\n\n#### reqScannerParametersAsync()\nReturn type\nAwaitable[str]\n\n#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nReturn type\nAwaitable[List[OptionChain]]\n\n#### reqNewsProvidersAsync()\nReturn type\nAwaitable[List[NewsProvider]]\n\n#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)\nReturn type\nAwaitable[NewsArticle\n\n#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nReturn type\nOptional[HistoricalNews]\n\n#### async requestFAAsync(faDataType)\nreqUserInfoAsync()",
      "language": "python",
      "description": "Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.",
      "sources": [
        "ex_0119_672d75df"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data",
        "error",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0120_61a75e07",
      "code": "Socket client for communicating with Interactive Brokers.\n\n#### class ib_insync.client.Client(wrapper)\nReplacement for ibapi.client.EClient that uses asyncio.\nThe client is fully asynchronous and has its own event-driven networking code that replaces the networking code\nof the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can\nbe used as a drop-in replacement for the standard EClient as provided by IBAPI.\nCompared to the standard EClient this client has the following additional features:\n-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for\nnextValidId to start requests as the client has already done that. The reqId is directly available with\ngetReqId().\n-client.connectAsync() is a coroutine for connecting asynchronously.\n-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-\nonds).\n-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size\ninstead of the two wrapper methods priceTick and sizeTick.\n-Automatic request throttling.\n-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after\na network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.\n-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the\nnetwork packet\u2019s data has been handled. A possible use is to write or evaluate the newly arrived data in one\nbatch instead of item by item.\nParameters\n-MaxRequests (int) -Throttle the number of requests to MaxRequests per\nRequestsInterval seconds. Set to 0 to disable throttling.\n-RequestsInterval (float) -Time interval (in seconds) for request throttling.\n-MinClientVersion (int) -Client protocol version.\n-MaxClientVersion (int) -Client protocol version\n\nEvents:\n-apiStart ()\n-apiEnd ()\n-apiError (errorMsg: str)\n-throttleStart ()\n-throttleEnd ()\nevents = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')\nMaxRequests = 45\nRequestsInterval = 1\nMinClientVersion = 157\nMaxClientVersion = 176\nDISCONNECTED = 0\nCONNECTING = 1\nCONNECTED = 2\nreset()\nserverVersion()\nReturn type\nint\nrun()\nisConnected()\nisReady()\nIs the API connection up and running?\nReturn type\nbool\nconnectionStats()\nGet statistics about the connection.\nReturn type\nConnectionStats\ngetReqId()\nGet new request ID.\nReturn type\nint\nupdateReqId(minReqId)\nUpdate the next reqId to be at least minReqId.\ngetAccounts()\nGet the list of account names that are under management.\nReturn type\nList[str]\n\nsetConnectOptions(connectOptions)\nSet additional connect options.\nParameters\nconnectOptions (str) -Use \u201c+PACEAPI\u201d to use request-pacing built into TWS/gateway\n974+.\n\nconnect(host, port, clientId, timeout=2.0)\nConnect to a running TWS or IB gateway application.\nParameters\n-host (str) -Host name or IP address.\n-port (int) -Port number.\n-clientId (int) -ID number to use for this client; must be unique per connection.\n-timeout (Optional[float]) -If establishing the connection takes longer than timeout\nseconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n\nasync connectAsync(host, port, clientId, timeout=2.0)\n\ndisconnect()\nDisconnect from IB connection.\n\nsend(*fields)\nSerialize and send the given fields using the IB socket protocol.\n\nsendMsg(msg)\n\nreqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)\n\ncancelMktData(reqId)\n\nplaceOrder(orderId, contract, order)\n\ncancelOrder(orderId, manualCancelOrderTime='')\n\nreqOpenOrders()\n\nreqAccountUpdates(subscribe, acctCode)\n\nreqExecutions(reqId, execFilter)\n\nreqIds(numIds)\n\nreqContractDetails(reqId, contract)\n\nreqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)\n\ncancelMktDepth(reqId, isSmartDepth)\n\nreqNewsBulletins(allMsgs)\n\ncancelNewsBulletins()\n\nsetServerLogLevel(logLevel)\n\nreqAutoOpenOrders(bAutoBind)\n\nreqAllOpenOrders()\n\nreqManagedAccts()\n\nrequestFA(faData)\n\nreplaceFA(reqId, faData, cxml)\n\nreqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate, keepUpToDate, chartOptions)\n\nexerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)\n\nreqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,\nscannerSubscriptionFilterOptions)\n\ncancelScannerSubscription(reqId)\n\nreqScannerParameters()\n\ncancelHistoricalData(reqId)\n\nreqCurrentTime()\n\nreqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)\n\ncancelRealTimeBars(reqId)\n\nreqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)\n\ncancelFundamentalData(reqId)\n\ncalculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)\n\ncalculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)\n\ncancelCalculateImpliedVolatility(reqId)\n\ncancelCalculateOptionPrice(reqId)\n\nreqGlobalCancel()\n\nreqMarketDataType(marketDataType)\n\nreqPositions()\n\nreqAccountSummary(reqId, groupName, tags)\n\ncancelAccountSummary(reqId)\n\ncancelPositions()\n\nverifyRequest(apiName, apiVersion)\n\nverifyMessage(apiData)\n\nqueryDisplayGroups(reqId)\n\nsubscribeToGroupEvents(reqId, groupId)\n\nupdateDisplayGroup(reqId, contractInfo)\n\nunsubscribeFromGroupEvents(reqId)\n\nstartApi()\n\nverifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)\n\nverifyAndAuthMessage(apiData, xyzResponse)\n\nreqPositionsMulti(reqId, account, modelCode)\n\ncancelPositionsMulti(reqId)\n\nreqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )\n\ncancelAccountUpdatesMulti(reqId)\n\nreqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\n\nreqSoftDollarTiers(reqId)\n\nreqFamilyCodes()\n\nreqMatchingSymbols(reqId, pattern)\n\nreqMktDepthExchanges()\n\nreqSmartComponents(reqId, bboExchange)\n\nreqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)\n\nreqNewsProviders()\n\nreqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions)\n\nreqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)\n\nreqHistogramData(tickerId, contract, useRTH, timePeriod)\n\ncancelHistogramData(tickerId)\n\ncancelHeadTimeStamp(reqId)\n\nreqMarketRule(marketRuleId)\n\nreqPnL(reqId, account, modelCode)\n\ncancelPnL(reqId)\n\nreqPnLSingle(reqId, account, modelCode, conid)\n\ncancelPnLSingle(reqId)\n\nreqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize, miscOptions)\n\nreqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)\n\ncancelTickByTickData(reqId)\n\nreqCompletedOrders(apiOnly)\n\nreqWshMetaData(reqId)\n\ncancelWshMetaData(reqId)\n\nreqWshEventData(reqId, data)\n\ncancelWshEventData(reqId)\n\nreqUserInfo(reqId)",
      "language": "python",
      "description": "\nClient",
      "sources": [
        "ex_0120_61a75e07"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data",
        "error",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0121_fda0b06a",
      "code": "#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',\ntotalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =\n1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:\nstr = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',\nocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,\nblockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,\ntriggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,\ngoodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:\nbool = False, minQty: int = 2147483647, percentOffset: float =\n1.7976931348623157e+308, overridePercentageConstraints: bool = False,\ntrailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =\n1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str\n= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',\norigin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:\nfloat = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,\nnbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool\n= False, auctionStrategy: int = 0, startingPrice: float =\n1.7976931348623157e+308, stockRefPrice: float =\n1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,\nstockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float\n= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:\nbool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int\n= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =\n1.7976931348623157e+308, deltaNeutralConId: int = 0,\ndeltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',\ndeltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',\ndeltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,\ndeltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,\nreferencePriceType: int = 2147483647, basisPoints: float =\n1.7976931348623157e+308, basisPointsType: int = 2147483647,\nscaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,\nscalePriceIncrement: float = 1.7976931348623157e+308,\nscalePriceAdjustValue: float = 1.7976931348623157e+308,\nscalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =\n1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:\nint = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:\nbool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',\naccount: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:\nstr = '', algoStrategy: str = '', algoParams:\n~typing.List[~ib_insync.contract.TagValue] = <factory>,\nsmartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =\n<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,\nsolicited: bool = False, modelCode: str = '', orderComboLegs:\n~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,\norderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,\nreferenceContractId: int = 0, peggedChangeAmount: float = 0.0,\nisPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float\n= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:\nfloat = 1.7976931348623157e+308, adjustedStopPrice: float =\n1.7976931348623157e+308, adjustedStopLimitPrice: float =\n1.7976931348623157e+308, adjustedTrailingAmount: float =\n1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:\nfloat = 1.7976931348623157e+308, conditions:\n~typing.List[~ib_insync.order.OrderCondition] = <factory>,\nconditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,\nextOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =\n<factory>, cashQty: float = 1.7976931348623157e+308,\nmifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',\nmifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',\ndontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,\n\nOrder for trading contracts.\nhttps://interactivebrokers.github.io/tws-api/available_orders.html\norderId: int = 0\nclientId: int = 0\npermId: int = 0\naction: str = ''\ntotalQuantity: float = 0.0\norderType: str = ''\nlmtPrice: float = 1.7976931348623157e+308\nauxPrice: float = 1.7976931348623157e+308\ntif: str = ''\nactiveStartTime: str = ''\nactiveStopTime: str = ''\nocaGroup: str = ''\nocaType: int = 0\norderRef: str = ''\ntransmit: bool = True\nparentId: int = 0\nblockOrder: bool = False\nsweepToFill: bool = False\ndisplaySize: int = 0\ntriggerMethod: int = 0\noutsideRth: bool = False\nhidden: bool = False\ngoodAfterTime: str = ''\ngoodTillDate: str = ''\nrule80A: str = ''\nallOrNone: bool = False\nminQty: int = 2147483647\npercentOffset: float = 1.7976931348623157e+308\noverridePercentageConstraints: bool = False\ntrailStopPrice: float = 1.7976931348623157e+308\ntrailingPercent: float = 1.7976931348623157e+308\nfaGroup: str = ''\nfaProfile: str = ''\nfaMethod: str = ''\nfaPercentage: str = ''\ndesignatedLocation: str = ''\nopenClose: str = 'O'\norigin: int = 0\nshortSaleSlot: int = 0\nexemptCode: int = -1\ndiscretionaryAmt: float = 0.0\neTradeOnly: bool = False\nfirmQuoteOnly: bool = False\nnbboPriceCap: float = 1.7976931348623157e+308\noptOutSmartRouting: bool = False\nauctionStrategy: int = 0\nstartingPrice: float = 1.7976931348623157e+308\nstockRefPrice: float = 1.7976931348623157e+308\ndelta: float = 1.7976931348623157e+308\nstockRangeLower: float = 1.7976931348623157e+308\nstockRangeUpper: float = 1.7976931348623157e+308\nrandomizePrice: bool = False\nrandomizeSize: bool = False\nvolatility: float = 1.7976931348623157e+308\nvolatilityType: int = 2147483647\ndeltaNeutralOrderType: str = ''\ndeltaNeutralAuxPrice: float = 1.7976931348623157e+308\ndeltaNeutralConId: int = 0\ndeltaNeutralSettlingFirm: str = ''\ndeltaNeutralClearingAccount: str = ''\ndeltaNeutralClearingIntent: str = ''\ndeltaNeutralOpenClose: str = ''\ndeltaNeutralShortSale: bool = False\ndeltaNeutralShortSaleSlot: int = 0\ndeltaNeutralDesignatedLocation: str = ''\ncontinuousUpdate: bool = False\nreferencePriceType: int = 2147483647\nbasisPoints: float = 1.7976931348623157e+308\nbasisPointsType: int = 2147483647\nscaleInitLevelSize: int = 2147483647\nscaleSubsLevelSize: int = 2147483647\nscalePriceIncrement: float = 1.7976931348623157e+308\nscalePriceAdjustValue: float = 1.7976931348623157e+308\nscalePriceAdjustInterval: int = 2147483647\nscaleProfitOffset: float = 1.7976931348623157e+308\nscaleAutoReset: bool = False\nscaleInitPosition: int = 2147483647\nscaleInitFillQty: int = 2147483647\nscaleRandomPercent: bool = False\nscaleTable: str = ''\nhedgeType: str = ''\nhedgeParam: str = ''\naccount: str = ''\nsettlingFirm: str = ''\nclearingAccount: str = ''\nclearingIntent: str = ''\nalgoStrategy: str = ''\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\nalgoId: str = ''\nwhatIf: bool = False\nnotHeld: bool = False\nsolicited: bool = False\nmodelCode: str = ''\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nreferenceContractId: int = 0\npeggedChangeAmount: float = 0.0\nisPeggedChangeAmountDecrease: bool = False\nreferenceChangeAmount: float = 0.0\nreferenceExchangeId: str = ''\nadjustedOrderType: str = ''\ntriggerPrice: float = 1.7976931348623157e+308\nadjustedStopPrice: float = 1.7976931348623157e+308\nadjustedStopLimitPrice: float = 1.7976931348623157e+308\nadjustedTrailingAmount: float = 1.7976931348623157e+308\nadjustableTrailingUnit: int = 0\nlmtPriceOffset: float = 1.7976931348623157e+308\nconditions: List[OrderCondition]\nconditionsCancelOrder: bool = False\nconditionsIgnoreRth: bool = False\nextOperator: str = ''\nsoftDollarTier: SoftDollarTier\ncashQty: float = 1.7976931348623157e+308\nmifid2DecisionMaker: str = ''\nmifid2DecisionAlgo: str = ''\nmifid2ExecutionTrader: str = ''\nmifid2ExecutionAlgo: str = ''\ndontUseAutoPriceForHedge: bool = False\nisOmsContainer: bool = False\ndiscretionaryUpToLimitPrice: bool = False\nautoCancelDate: str = ''\nfilledQuantity: float = 1.7976931348623157e+308\nrefFuturesConId: int = 0\nautoCancelParent: bool = False\nshareholder: str = ''\nimbalanceOnly: bool = False\nrouteMarketableToBbo: bool = False\nparentPermId: int = 0\nusePriceMgmtAlgo: bool = False\nduration: int = 2147483647\npostToAts: int = 2147483647\nadvancedErrorOverride: str = ''\nmanualOrderTime: str = ''\nminTradeQty: int = 2147483647\nminCompeteSize: int = 2147483647\ncompeteAgainstBestOffset: float = 1.7976931348623157e+308\nmidOffsetAtWhole: float = 1.7976931348623157e+308\nmidOffsetAtHalf: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =\n0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,\nlastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',\nmktCapPrice: float = 0.0)\n\norderId: int = 0\nstatus: str = ''\nfilled: float = 0.0\nremaining: float = 0.0\navgFillPrice: float = 0.0\npermId: int = 0\nparentId: int = 0\nlastFillPrice: float = 0.0\nclientId: int = 0\nwhyHeld: str = ''\nmktCapPrice: float = 0.0\nPendingSubmit: ClassVar[str] = 'PendingSubmit'\nPendingCancel: ClassVar[str] = 'PendingCancel'\nPreSubmitted: ClassVar[str] = 'PreSubmitted'\nSubmitted: ClassVar[str] = 'Submitted'\nApiPending: ClassVar[str] = 'ApiPending'\nApiCancelled: ClassVar[str] = 'ApiCancelled'\nCancelled: ClassVar[str] = 'Cancelled'\nFilled: ClassVar[str] = 'Filled'\nInactive: ClassVar[str] = 'Inactive'\nDoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}\nActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',\n'Submitted'}\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',\nequityWithLoanBefore: str = '', initMarginChange: str = '',\nmaintMarginChange: str = '', equityWithLoanChange: str = '',\ninitMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:\nstr = '', commission: float = 1.7976931348623157e+308,\nminCommission: float = 1.7976931348623157e+308, maxCommission:\nfloat = 1.7976931348623157e+308, commissionCurrency: str = '',\nwarningText: str = '', completedTime: str = '', completedStatus: str = '')\n\nstatus: str = ''\ninitMarginBefore: str = ''\nmaintMarginBefore: str = ''\nequityWithLoanBefore: str = ''\ninitMarginChange: str = ''\nmaintMarginChange: str = ''\nequityWithLoanChange: str = ''\ninitMarginAfter: str = ''\nmaintMarginAfter: str = ''\nequityWithLoanAfter: str = ''\ncommission: float = 1.7976931348623157e+308\nminCommission: float = 1.7976931348623157e+308\nmaxCommission: float = 1.7976931348623157e+308\ncommissionCurrency: str = ''\nwarningText: str = ''\ncompletedTime: str = ''\ncompletedStatus: str = ''\ndict()\n\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)\n\nprice: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:\n~ib_insync.order.Order = <factory>, orderStatus:\n~ib_insync.order.OrderStatus = <factory>, fills:\n~typing.List[~ib_insync.objects.Fill] = <factory>, log:\n~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:\nstr = '')\nTrade keeps track of an order, its status and all its fills.\nEvents:\n-statusEvent (trade: Trade)\n-modifyEvent (trade: Trade)\n-fillEvent (trade: Trade, fill: Fill)\n-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)\n-filledEvent (trade: Trade)\n-cancelEvent (trade: Trade)\n-cancelledEvent (trade: Trade)\nevents: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',\n'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')\ncontract: Contract\norder: Order\norderStatus: OrderStatus\nfills: List[Fill]\nlog: List[TradeLogEntry]\nadvancedError: str = ''\nisActive()\nTrue if eligible for execution, false otherwise.\nisDone()\nTrue if completely filled or cancelled, false otherwise.\nfilled()\nNumber of shares filled.\nremaining()\nNumber of shares remaining to be filled.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)\nCreate new instance of BracketOrder(parent, takeProfit, stopLoss)\nproperty parent\nproperty takeProfit\nproperty stopLoss\n\n#### class ib_insync.order.OrderCondition\nstatic createClass(condType)\nAnd()\nOr()\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,\nprice: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =\n0)\ncondType: int = 1\nconjunction: str = 'a'\nisMore: bool = True\nprice: float = 0.0\nconId: int = 0\nexch: str = ''\ntriggerMethod: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:\nstr = '')\ncondType: int = 3\nconjunction: str = 'a'\nisMore: bool = True\ntime: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,\npercent: int = 0)\ncondType: int = 4\nconjunction: str = 'a'\nisMore: bool = True\npercent: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',\nexch: str = '', symbol: str = '')\ncondType: int = 5\nconjunction: str = 'a'\nsecType: str = ''\nexch: str = ''\nsymbol: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,\nvolume: int = 0, conId: int = 0, exch: str = '')\ncondType: int = 6\nconjunction: str = 'a'\nisMore: bool = True\nvolume: int = 0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =\nTrue, changePercent: float = 0.0, conId: int = 0, exch: str\n= '')\ncondType: int = 7\nconjunction: str = 'a'\nisMore: bool = True\nchangePercent: float = 0.0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject",
      "language": "python",
      "description": "\nOrder",
      "sources": [
        "ex_0121_fda0b06a"
      ],
      "tags": [
        "contract",
        "error",
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0122_bbbc6522",
      "code": "Financial instrument types used by Interactive Brokers\n\nclass ib_insync.contract.Contract(secType: str = '', conId: int = 0, symbol: str = '',\nlastTradeDateOrContractMonth: str = '', strike: float = 0.0, right: str =\n'', multiplier: str = '', exchange: str = '', primaryExchange: str = '',\ncurrency: str = '', localSymbol: str = '', tradingClass: str = '',\nincludeExpired: bool = False, secIdType: str = '', secId: str = '',\ndescription: str = '', issuerId: str = '', comboLegsDescrip: str = '',\ncomboLegs: ~typing.List[~ib_insync.contract.ComboLeg] = <factory>,\ndeltaNeutralContract:\n~typing.Optional[~ib_insync.contract.DeltaNeutralContract] = None)\nContract(**kwargs) can create any contract using keyword arguments. To simplify working with contracts,\nthere are also more specialized contracts that take optional positional arguments. Some examples:\n\n\nContract(conId=270639)\nStock('AMD', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nForex('EURUSD')\nCFD('IBUS30')\nFuture('ES', '20180921', 'CME')\nOption('SPY', '20170721', 240, 'C', 'SMART')\nBond(secIdType='ISIN', secId='US03076KAA60')\nCrypto('BTC', 'PAXOS', 'USD')\n\nParameters\n-conId (int) -The unique IB contract identifier.\n-symbol (str) -The contract (or its underlying) symbol.\n-secType (str) -The security type:\n\u2013 \u2019STK\u2019 = Stock (or ETF)\n\u2013 \u2019OPT\u2019 = Option\n\u2013 \u2019FUT\u2019 = Future\n\u2013 \u2019IND\u2019 = Index\n\u2013 \u2019FOP\u2019 = Futures option\n\u2013 \u2019CASH\u2019 = Forex pair\n\u2013 \u2019CFD\u2019 = CFD\n\u2013 \u2019BAG\u2019 = Combo\n\u2013 \u2019WAR\u2019 = Warrant\n\u2013 \u2019BOND\u2019 = Bond\n\u2013 \u2019CMDTY\u2019 = Commodity\n\u2013 \u2019NEWS\u2019 = News\n\u2013 \u2019FUND\u2019 = Mutual fund\n\u2013 \u2019CRYPTO\u2019 = Crypto currency\n-lastTradeDateOrContractMonth (str) -The contract\u2019s last trading day or contract\nmonth (for Options and Futures). Strings with format YYYYMM will be interpreted as\nthe Contract Month whereas YYYYMMDD will be interpreted as Last Trading Day.\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or Call. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019, \u2018CALL\u2019, or \u2018\u2019 for non-options.\n-multiplier (str) -he instrument\u2019s multiplier (i.e. options, futures).\n-exchange (str) -The destination exchange.\n-currency (str) -The underlying\u2019s currency.\n-localSymbol (str) -The contract\u2019s symbol within its primary exchange. For options, this\nwill be the OCC symbol.\n-primaryExchange (str) -The contract\u2019s primary exchange. For smart routed contracts,\nused to define contract in case of ambiguity. Should be defined as native exchange of contract,\ne.g. ISLAND for MSFT. For exchanges which contain a period in name, will only be part of\nexchange name prior to period, i.e. ENEXT for ENEXT.BE.\n-tradingClass (str) -The trading class name for this contract. Available in TWS contract\ndescription window as well. For example, GBL Dec \u201813 future\u2019s trading class is \u201cFGBL\u201d.\n-includeExpired (bool) -If set to true, contract details requests and historical data queries\ncan be performed pertaining to expired futures contracts. Expired options or other instrument\ntypes are not available.\n-secIdType (str) -Security identifier type. Examples for Apple:\n\u2013 secIdType=\u2019ISIN\u2019, secId=\u2019US0378331005\u2019\n\u2013 secIdType=\u2019CUSIP\u2019, secId=\u2019037833100\u2019\n-secId (str) -Security identifier.\n-comboLegsDescription (str) -Description of the combo legs.\n-comboLegs (List[ComboLeg]) -The legs of a combined contract definition.\n-deltaNeutralContract (DeltaNeutralContract) -Delta and underlying price for\nDelta-Neutral combo orders.\nsecType: str = ''\nconId: int = 0\nsymbol: str = ''\nlastTradeDateOrContractMonth: str = ''\nstrike: float = 0.0\nright: str = ''\nmultiplier: str = ''\nexchange: str = ''\nprimaryExchange: str = ''\ncurrency: str = ''\nlocalSymbol: str = ''\ntradingClass: str = ''\nincludeExpired: bool = False\nsecIdType: str = ''\nsecId: str = ''\ndescription: str = ''\nissuerId: str = ''\ncomboLegsDescrip: str = ''\ncomboLegs: List[ComboLeg]\ndeltaNeutralContract: Optional[DeltaNeutralContract] = None\n\nstatic create(**kwargs)\nCreate and a return a specialized contract based on the given secType, or a general Contract if secType is\nnot given.\nReturn type\nContract\n\nisHashable()\nSee if this contract can be hashed by conId.\nNote: Bag contracts always get conId=28812380, so they\u2019re not hashable.\nReturn type\nbool\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.contract.Stock(symbol='', exchange='', currency='', **kwargs)\nStock contract.\nParameters\n-symbol (str) -Symbol name.\n-exchange (str) -Destination exchange.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\ncomboLegs: List[ComboLeg]\n\n#### class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',\nexchange='', multiplier='', currency='', **kwargs)\nOption contract.\nParameters\n-symbol (str) -Symbol name.\n-lastTradeDateOrContractMonth (str) -The option\u2019s last trading day or contract month.\n\u2013 YYYYMM format: To specify last month\n\u2013 YYYYMMDD format: To specify last trading day\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or call option. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019 or \u2018CALL\u2019.\n-exchange (str) -Destination exchange.\n-multiplier (str) -The contract multiplier.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type\nobject\n\ncomboLegs: List[ComboLeg]",
      "language": "python",
      "description": "\nContract",
      "sources": [
        "ex_0122_bbbc6522"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0123_bc6f8975",
      "code": "#### class ib_insync.contract.Future(symbol='', lastTradeDateOrContractMonth='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\n\nFuture contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]\n\n\n#### class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\nContinuous future contract.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type:dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\n*Return type: object\n\ncomboLegs: List[ComboLeg]",
      "language": "python",
      "description": "\nFuture",
      "sources": [
        "ex_0123_bc6f8975"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0123",
      "code": "class ib_insync.contract.Forex(pair='', exchange='IDEALPRO', symbol='', currency='', **kwargs)\n\nForeign exchange currency pair.\n\n**Parameters:**\n- **pair** (str) - Shortcut for specifying symbol and currency, like 'EURUSD'.\n- **exchange** (str) - Destination exchange.\n- **symbol** (str) - Base currency.\n- **currency** (str) - Quote currency.\n\npair()\nShort name of pair.\nReturn type: str\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
      "language": "python",
      "description": "Represents financial contracts for various asset types including Forex, Index, CFD, Commodity, and Crypto. Common parameters include 'symbol' (asset identifier), 'exchange' (destination exchange), and 'currency' (underlying currency). Forex contracts additionally use 'pair' as a shortcut for symbol/currency (e.g., 'EURUSD'). All contracts inherit methods to convert to dict/tuple, track non-default fields, update attributes, and manage combo legs. Forex includes a dedicated pair() method to return the currency pair name.",
      "sources": [
        "ex_0124_a85b6a7f",
        "ex_0125_2b6f6a6e",
        "ex_0126_d4626d75",
        "ex_0127_8675ebd8",
        "ex_0133_dff73d92"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Key variations:\n1. Forex uses 'pair' parameter and pair() method; others use 'symbol'.\n2. Default exchange differs (Forex: 'IDEALPRO'; others: empty).\n3. All other classes (Index, CFD, Commodity, Crypto) share identical structures except parameter names.",
      "metadata": {
        "confidence": 0.95,
        "variations": 4,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_cluster_0124",
      "code": "class ib_insync.contract.ContractType(**kwargs)\n    [Contract Type Description]\n\n    dict()\n        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\n        Return type: dict\n\n    nonDefaults()\n        For a dataclass instance get the fields that are different from the default values and return as dict.\n        Return type: dict\n\n    tuple()\n        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\n        Return type: tuple\n\n    update(*srcObjs, **kwargs)\n        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\n        Return type: object\n\n    comboLegs: List[ComboLeg]",
      "language": "python",
      "description": "Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds).",
      "sources": [
        "ex_0128_45d7fdfc",
        "ex_0130_970fbdd1",
        "ex_0131_d0953ca2",
        "ex_0132_e65c45ce"
      ],
      "tags": [
        "contract",
        "dataclass",
        "ibkr",
        "trading-api"
      ],
      "notes": "Variations occur only in contract-specific descriptions: Bond = 'Bond.', MutualFund = 'Mutual fund.', Warrant = 'Warrant option.', Bag = 'Bag contract.'. Method implementations and comboLegs attribute are identical across all contract types. Minor formatting differences exist in source docs (asterisks/spacing) but don't affect functionality.",
      "metadata": {
        "confidence": 0.95,
        "variations": 3,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0129_0c947e3f",
      "code": "class ib_insync.contract.FuturesOption(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='', exchange='', multiplier='', currency='', **kwargs)\n\nOption on a futures contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **strike** (float) - The option's strike price.\n- **right** (str) - Put or call option. Valid values are 'P', 'PUT', 'C' or 'CALL'.\n- **exchange** (str) - Destination exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type:** dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
      "language": "python",
      "description": "\nFuturesOption",
      "sources": [
        "ex_0129_0c947e3f"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0134_4bae9046",
      "code": "class ib_insync.contract.TagValue(tag, value)\n\nCreate new instance of TagValue(tag, value)",
      "language": "python",
      "description": "\n TagValue",
      "sources": [
        "ex_0134_4bae9046"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0135_71282853",
      "code": "def onConnected():\n    print(ib.accountValues())\n\nibc = IBC(974, gateway=True, tradingMode='paper')\nib = IB()\nib.connectedEvent += onConnected\nwatchdog = Watchdog(ibc, ib, port=4002)\nwatchdog.start()\nib.run()",
      "language": "python",
      "description": "class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =\n'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:\nfloat = 2, appStartupTime: float = 30, ...",
      "sources": [
        "ex_0135_71282853"
      ],
      "tags": [
        "connect",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0136_1556d437",
      "code": "import datetime\nfrom ib_insync import *\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\ncontract = Stock('TSLA', 'SMART', 'USD')\ndt = ''\nbarsList = []\nwhile True:\nbars = ib.reqHistoricalData(\ncontract,\nendDateTime=dt,\ndurationStr='10 D',\nbarSizeSetting='1 min',\nwhatToShow='MIDPOINT',\nuseRTH=True,\nformatDate=1)\nif not bars:\nbreak\nbarsList.append(bars)\ndt = bars[0].date\nprint(dt)\n# save to CSV file\nallBars = [b for bars in reversed(barsList) for b in bars]\ndf = util.df(allBars)\ndf.to_csv(contract.symbol + '.csv', index=False)",
      "language": "python",
      "description": " Fetching consecutive historical data",
      "sources": [
        "ex_0136_1556d437"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0129",
      "code": "import asyncio\nimport ib_insync as ibi\n\nclass App:\n    async def run(self):\n        self.ib = ibi.IB()\n        with await self.ib.connectAsync():\n            contracts = [\n                ibi.Stock(symbol, 'SMART', 'USD')\n                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]\n            for contract in contracts:\n                self.ib.reqMktData(contract)\n            async for tickers in self.ib.pendingTickersEvent:\n                for ticker in tickers:\n                    print(ticker)\n\n    def stop(self):\n        self.ib.disconnect()\n\napp = App()\ntry:\n    asyncio.run(app.run())\nexcept (KeyboardInterrupt, SystemExit):\n    app.stop()",
      "language": "python",
      "description": "Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway.",
      "sources": [
        "ex_0137_80aea104",
        "ex_0147_490b705b"
      ],
      "tags": [
        "async",
        "connect",
        "contract",
        "data",
        "event",
        "market data",
        "streaming",
        "real-time"
      ],
      "notes": "Both examples are functionally identical but Example 1 has proper Python indentation while Example 2 is minified/invalid. No variations in logic or parameters. Uses SMART exchange and USD currency for all contracts.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0138_fbdce807",
      "code": "allParams = ib.reqScannerParameters()\nprint(allParams)\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerData(sub)\nprint(scanData)",
      "language": "python",
      "description": " Scanner data (blocking)",
      "sources": [
        "ex_0138_fbdce807"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0139_0058769e",
      "code": "def onScanData(scanData):\nprint(scanData[0])\nprint(len(scanData))\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerSubscription(sub)\nscanData.updateEvent += onScanData\nib.sleep(60)\nib.cancelScannerSubscription(scanData)",
      "language": "python",
      "description": " Scanner data (streaming)",
      "sources": [
        "ex_0139_0058769e"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0140_c87a4a2c",
      "code": "option = Option('EOE', '20171215', 490, 'P', 'FTA', multiplier=100)\ncalc = ib.calculateImpliedVolatility(\noption, optionPrice=6.1, underPrice=525)\nprint(calc)\ncalc = ib.calculateOptionPrice(\noption, volatility=0.14, underPrice=525)\nprint(calc)",
      "language": "python",
      "description": " Option calculations",
      "sources": [
        "ex_0140_c87a4a2c"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0141_8522063f",
      "code": "eurusd = Forex('EURUSD')\nticker = ib.reqMktDepth(eurusd)\nwhile ib.sleep(5):\nprint(\n[d.price for d in ticker.domBids],\n[d.price for d in ticker.domAsks])",
      "language": "python",
      "description": " Order book",
      "sources": [
        "ex_0141_8522063f"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0142_c7128665",
      "code": "usdjpy = Forex('USDJPY')\ncd = ib.reqContractDetails(usdjpy)[0]\nprint(cd.marketRuleIds)\nrules = [\nib.reqMarketRule(ruleId)\nfor ruleId in cd.marketRuleIds.split(',')]\nprint(rules)",
      "language": "python",
      "description": " Minimum price increments",
      "sources": [
        "ex_0142_c7128665"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0143_2e49e4f1",
      "code": "newsProviders = ib.reqNewsProviders()\nprint(newsProviders)\ncodes = '+'.join(np.code for np in newsProviders)\namd = Stock('AMD', 'SMART', 'USD')\nib.qualifyContracts(amd)\nheadlines = ib.reqHistoricalNews(amd.conId, codes, '', '', 10)\nlatest = headlines[0]\nprint(latest)\narticle = ib.reqNewsArticle(latest.providerCode, latest.articleId)\nprint(article",
      "language": "python",
      "description": " News articles",
      "sources": [
        "ex_0143_2e49e4f1"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0144_a855e3c4",
      "code": "ib.reqNewsBulletins(True)\nib.sleep(5)\nprint(ib.newsBulletins())",
      "language": "python",
      "description": " News bulletins",
      "sources": [
        "ex_0144_a855e3c4"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0145_6124bc35",
      "code": "contract = Stock('INTC', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '456')\nib.sleep(2)\nprint(ticker.dividends)\nOutput:\nDividends(past12Months=1.2, next12Months=1.2, nextDate=datetime.date(2019, 2, 6),\u2423\nnextAmount=0.3)",
      "language": "python",
      "description": " Dividends",
      "sources": [
        "ex_0145_6124bc35"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0146_ac20163f",
      "code": "contract = Stock('IBM', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '258')\nib.sleep(2)\nprint(ticker.fundamentalRatios)",
      "language": "python",
      "description": " Fundamental ratios",
      "sources": [
        "ex_0146_ac20163f"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0148_f2fd5bf4",
      "code": "class TkApp:\n    \"\"\"\n    Example of integrating with Tkinter.\n    \"\"\"\n    def __init__(self):\n        self.ib = IB().connect()\n        self.root = tk.Tk()\n        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)\n        self.entry = tk.Entry(self.root, width=50)\n        self.entry.insert(0, \"Stock('TSLA', 'SMART', 'USD')\")\n        self.entry.grid()\n        self.button = tk.Button(\n            self.root, text='Get details', command=self.onButtonClick)\n        self.button.grid()\n        self.text = tk.Text(self.root)\n        self.text.grid()\n        self.loop = util.getLoop()\n\n    def onButtonClick(self):\n        contract = eval(self.entry.get())\n        cds = self.ib.reqContractDetails(contract)\n        self.text.delete(1.0, tk.END)\n        self.text.insert(tk.END, str(cds))\n\n    def run(self):\n        self._onTimeout()\n        self.loop.run_forever()\n\n    def _onTimeout(self):\n        self.root.update()\n        self.loop.call_later(0.03, self._onTimeout)\n\n    def _onDeleteWindow(self):\n        self.loop.stop()\n\n\napp = TkApp()\napp.run()",
      "language": "python",
      "description": " Integration with Tkinter",
      "sources": [
        "ex_0148_f2fd5bf4"
      ],
      "tags": [
        "connect",
        "contract",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0149_9e42986f",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Order triggers when SPY hits 450\ncontract = Stock('AAPL', 'SMART', 'USD')\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\n\n# Qualify both\ncontract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)\n\n# Create price condition\ncondition = PriceCondition(\n    condType=1,  # Price\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # True = above, False = below\n    price=450.0\n)\n\n# Create order with condition\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False\n\ntrade = ib.placeOrder(contract, order)\nprint(f\"Conditional order placed: {trade.order.orderId}\")",
      "language": "python",
      "description": " Price-Based Condition",
      "sources": [
        "ex_0149_9e42986f"
      ],
      "tags": [
        "connect",
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0150_43324d28",
      "code": "from datetime import datetime, timedelta\n\n# Order triggers at specific time\ntime_condition = TimeCondition(\n    condType=3,  # Time\n    isMore=True,\n    time=datetime.now() + timedelta(hours=1)\n)\n\norder = MarketOrder('BUY', 100)\norder.conditions = [time_condition]\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Time-Based Condition",
      "sources": [
        "ex_0150_43324d28"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0151_5d2c3705",
      "code": "# Trigger when daily volume exceeds threshold\nvolume_condition = VolumeCondition(\n    condType=4,  # Volume\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=10000000  # 10M shares\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [volume_condition]\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Volume-Based Condition",
      "sources": [
        "ex_0151_5d2c3705"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0152_4ec34ae3",
      "code": "# Order triggers when BOTH conditions met\nprice_cond = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,\n    price=450.0\n)\n\nvolume_cond = VolumeCondition(\n    condType=4,\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=5000000\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [price_cond, volume_cond]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False  # False = AND, True = OR\n\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Multiple Conditions (AND/OR)",
      "sources": [
        "ex_0152_4ec34ae3"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0144",
      "code": "order = Order()\norder.action = 'BUY'  # or 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL\n# For TRAIL: set auxPrice (fixed trail amount)\n# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent\n# For PEG MID/PEG BEST: no additional price fields\n# For REL: set lmtPrice (offset from NBBO)\norder.tif = 'GTC'  # or other time in force\n\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": "Places advanced order types in Interactive Brokers API. Covers:\n1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount\n2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)\n3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging\n4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging\n5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO\nCommon parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract.",
      "sources": [
        "ex_0154_22d3f273",
        "ex_0155_6b1a9a90",
        "ex_0156_50051a29",
        "ex_0157_92bd3785",
        "ex_0158_e5fd845a"
      ],
      "tags": [
        "order",
        "contract",
        "trailing_stop",
        "pegged_order",
        "relative_order"
      ],
      "notes": "Key variations:\n- TRAIL requires auxPrice (fixed $ trail)\n- TRAIL LIMIT requires both lmtPriceOffset ($) and trailingPercent (%)\n- PEG MID/PEG BEST require no price parameters\n- REL uses lmtPrice for NBBO offset\n- Action (BUY/SELL) varies by use case\n- All examples use GTC time-in-force but other values are possible",
      "metadata": {
        "confidence": 0.95,
        "variations": 4,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0159_02a55978",
      "code": "# Buy at market, then set multiple exit strategies\nentry_order = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry_order)\n\n# Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    # Create OCA group for exits\n    oca_group = f\"OCA_{int(time.time())}\"\n    \n    # Exit 1: Take profit at +5%\n    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)\n    exit1.ocaGroup = oca_group\n    exit1.ocaType = 1  # Cancel all on fill\n    \n    # Exit 2: Stop loss at -2%\n    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)\n    exit2.ocaGroup = oca_group\n    exit2.ocaType = 1\n    \n    # Exit 3: Trailing stop\n    exit3 = Order()\n    exit3.action = 'SELL'\n    exit3.totalQuantity = 100\n    exit3.orderType = 'TRAIL'\n    exit3.trailingPercent = 3.0\n    exit3.ocaGroup = oca_group\n    exit3.ocaType = 1\n    \n    for order in [exit1, exit2, exit3]:\n        ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Multiple Exits from Same Entry",
      "sources": [
        "ex_0159_02a55978"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0161_c633d4e2",
      "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Vwap'\norder.algoParams = [\n    TagValue('maxPctVol', '0.1'),  # Max 10% of volume\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1'),\n    TagValue('noTakeLiq', '1')\n]\n\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " VWAP (Volume-Weighted Average Price)",
      "sources": [
        "ex_0161_c633d4e2"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0162_40a89498",
      "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 1000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Adaptive'\norder.algoParams = [\n    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient\n]\n\ntrade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Adaptive (IB's Smart Routing)",
      "sources": [
        "ex_0162_40a89498"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0163_f6b52c88",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Define legs\nbuy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\n# Qualify\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\n# Create combo contract\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\n# Define legs\nleg1 = ComboLeg()\nleg1.conId = buy_call.conId\nleg1.ratio = 1\nleg1.action = 'BUY'\nleg1.exchange = 'SMART'\n\nleg2 = ComboLeg()\nleg2.conId = sell_call.conId\nleg2.ratio = 1\nleg2.action = 'SELL'\nleg2.exchange = 'SMART'\n\ncombo.comboLegs = [leg1, leg2]\n\n# Place order\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50\ntrade = ib.placeOrder(combo, order)",
      "language": "python",
      "description": " Vertical Spread (Bull Call Spread)",
      "sources": [
        "ex_0163_f6b52c88"
      ],
      "tags": [
        "connect",
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0149",
      "code": "# Four-leg strategy: sell OTM call spread + sell OTM put spread\nbuy_call = Option('SPY', '20240315', 470, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 465, 'C', 'SMART')\nbuy_put = Option('SPY', '20240315', 430, 'P', 'SMART')\nsell_put = Option('SPY', '20240315', 435, 'P', 'SMART')\n\n# Qualify all\ncontracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)\n\n# Create BAG\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put\n    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put\n]\n\n# Place as credit spread\norder = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit\ntrade = ib.placeOrder(combo, order)",
      "language": "python",
      "description": " Iron Condor",
      "sources": [
        "ex_0164_57cd3283",
        "ex_0165_ccb0bf34"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "JSON parse failed. Raw response: {\n  \"canonical_code\": \"```python\\n# Four-leg strategy: sell OTM call spread + sell OTM put spread\\nb...",
      "metadata": {
        "confidence": 0.6,
        "variations": 1
      }
    },
    {
      "id": "merged_ex_0167_405955a3",
      "code": "# Dynamic delta hedging for options position\ndef calculate_position_delta(portfolio):\n    \"\"\"Calculate total portfolio delta\"\"\"\n    total_delta = 0.0\n    \n    for item in portfolio:\n        if item.contract.secType == 'OPT':\n            # Request option computations\n            ticker = ib.reqMktData(item.contract, '', False, False)\n            ib.sleep(1)\n            \n            if ticker.modelGreeks:\n                delta = ticker.modelGreeks.delta\n                total_delta += delta * item.position\n            \n            ib.cancelMktData(item.contract)\n    \n    return total_delta\n\ndef hedge_delta(underlying_contract, target_delta=0.0):\n    \"\"\"Adjust underlying position to achieve target delta\"\"\"\n    portfolio = ib.portfolio()\n    current_delta = calculate_position_delta(portfolio)\n    \n    delta_to_hedge = current_delta - target_delta\n    \n    if abs(delta_to_hedge) > 0.1:  # Threshold\n        # Delta of stock is 1.0\n        shares_to_trade = int(delta_to_hedge * 100)  # Per contract\n        \n        if shares_to_trade > 0:\n            order = MarketOrder('SELL', abs(shares_to_trade))\n        else:\n            order = MarketOrder('BUY', abs(shares_to_trade))\n        \n        trade = ib.placeOrder(underlying_contract, order)\n        print(f\"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}\")\n        \n        return trade\n    else:\n        print(f\"Delta within tolerance: {current_delta:.2f}\")\n        return None\n\n# Run periodically\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\nwhile True:\n    hedge_delta(underlying, target_delta=0.0)\n    ib.sleep(300)  # Every 5 minutes",
      "language": "python",
      "description": " Delta Hedging Pattern",
      "sources": [
        "ex_0167_405955a3"
      ],
      "tags": [
        "contract",
        "data",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0168_01a3894d",
      "code": "from ib_insync import *\nimport logging\n\nclass IBErrorHandler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.error_log = []\n        self.ib.errorEvent += self.on_error\n        \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Centralized error handling\"\"\"\n        error_info = {\n            'time': datetime.now(),\n            'reqId': reqId,\n            'code': errorCode,\n            'message': errorString,\n            'contract': contract\n        }\n        self.error_log.append(error_info)\n        \n        # Categorize and handle\n        if errorCode in [502, 503, 504]:\n            self.handle_connection_error(errorCode, errorString)\n        elif errorCode in [200, 201, 202]:\n            self.handle_order_error(errorCode, errorString, contract)\n        elif errorCode == 162:\n            self.handle_data_error(errorCode, errorString, contract)\n        elif errorCode == 354:\n            self.handle_market_data_subscription_error(errorCode, errorString)\n        elif errorCode in [2104, 2106, 2158]:\n            # Info messages - ignore\n            pass\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def handle_connection_error(self, code, message):\n        \"\"\"Handle connection failures\"\"\"\n        logging.critical(f\"Connection error {code}: {message}\")\n        # Trigger reconnection\n        self.schedule_reconnect()\n    \n    def handle_order_error(self, code, message, contract):\n        \"\"\"Handle order rejections\"\"\"\n        logging.error(f\"Order error {code}: {message} for {contract}\")\n        # Could retry with modified params\n        # Or alert user\n    \n    def handle_data_error(self, code, message, contract):\n        \"\"\"Handle data request failures\"\"\"\n        logging.warning(f\"Data error {code}: {message} for {contract}\")\n        # Retry with different params\n    \n    def handle_market_data_subscription_error(self, code, message):\n        \"\"\"Handle market data subscription issues\"\"\"\n        logging.warning(f\"Market data error {code}: {message}\")\n        # Fall back to delayed data\n        self.ib.reqMarketDataType(3)  # Delayed\n    \n    def schedule_reconnect(self):\n        \"\"\"Schedule reconnection attempt\"\"\"\n        # Implementation in reconnection section\n        pass\n\n# Usage\nib = IB()\nerror_handler = IBErrorHandler(ib)\nib.connect('127.0.0.1', 7497, clientId=1)",
      "language": "python",
      "description": " Comprehensive Error Handler",
      "sources": [
        "ex_0168_01a3894d"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0169_53f05d1d",
      "code": "def validate_order(ib, contract, order):\n    \"\"\"Validate order before placing\"\"\"\n    errors = []\n    \n    # 1. Check contract is qualified\n    if contract.conId == 0:\n        errors.append(\"Contract not qualified\")\n    \n    # 2. Check buying power\n    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}\n    \n    if order.action == 'BUY':\n        # Estimate cost\n        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot\n        ib.sleep(1)\n        \n        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN\n            estimated_cost = ticker.ask * order.totalQuantity\n            if estimated_cost > account_values.get('BuyingPower', 0):\n                errors.append(f\"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}\")\n        \n        ib.cancelMktData(contract)\n    \n    # 3. What-if order check\n    try:\n        order_copy = Order(**{k: v for k, v in order.__dict__.items()})\n        order_copy.whatIf = True\n        \n        orderState = ib.whatIfOrder(contract, order_copy)\n        \n        if orderState.commission and orderState.commission > 0:\n            # Valid response\n            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):\n                errors.append(\"Insufficient margin\")\n        else:\n            errors.append(\"What-if order returned invalid state\")\n            \n    except Exception as e:\n        errors.append(f\"What-if validation failed: {e}\")\n    \n    # 4. Check trading hours\n    details = ib.reqContractDetails(contract)\n    if details:\n        # Parse trading hours (simplified)\n        # Would need full implementation\n        pass\n    \n    return errors\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\norder = LimitOrder('BUY', 1000, 175.0)\n\nvalidation_errors = validate_order(ib, contract, order)\nif validation_errors:\n    print(\"Order validation failed:\")\n    for error in validation_errors:\n        print(f\"  - {error}\")\nelse:\n    trade = ib.placeOrder(contract, order)\n    print(\"Order placed successfully\")",
      "language": "python",
      "description": " Order Validation Before Submission",
      "sources": [
        "ex_0169_53f05d1d"
      ],
      "tags": [
        "contract",
        "data",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0170_11393855",
      "code": "import time\nfrom functools import wraps\n\ndef retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):\n    \"\"\"Decorator for retrying failed operations\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            retries = 0\n            delay = base_delay\n            \n            while retries < max_retries:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    retries += 1\n                    if retries >= max_retries:\n                        logging.error(f\"{func.__name__} failed after {max_retries} retries: {e}\")\n                        raise\n                    \n                    logging.warning(f\"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n                    delay = min(delay * 2, max_delay)  # Exponential backoff\n            \n        return wrapper\n    return decorator\n\n# Usage\n@retry_with_backoff(max_retries=3, base_delay=2.0)\ndef place_order_with_retry(ib, contract, order):\n    \"\"\"Place order with automatic retry\"\"\"\n    trade = ib.placeOrder(contract, order)\n    \n    # Wait for submission\n    timeout = 10\n    start = time.time()\n    while trade.orderStatus.status in ['PendingSubmit', '']:\n        if time.time() - start > timeout:\n            raise TimeoutError(\"Order submission timeout\")\n        ib.sleep(0.1)\n    \n    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:\n        raise Exception(f\"Order cancelled: {trade.orderStatus.status}\")\n    \n    return trade\n\n# Usage\ntry:\n    trade = place_order_with_retry(ib, contract, order)\n    print(f\"Order placed: {trade.order.orderId}\")\nexcept Exception as e:\n    print(f\"Order failed: {e}\")",
      "language": "python",
      "description": " Retry Logic with Exponential Backoff",
      "sources": [
        "ex_0170_11393855"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0171_130315a8",
      "code": "class PositionManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.expected_positions = {}  # conId -> quantity\n        \n    def record_trade(self, trade):\n        \"\"\"Record expected position change\"\"\"\n        if trade.orderStatus.status == 'Filled':\n            conId = trade.contract.conId\n            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()\n            \n            if conId in self.expected_positions:\n                self.expected_positions[conId] += qty\n            else:\n                self.expected_positions[conId] = qty\n    \n    def reconcile(self):\n        \"\"\"Check actual vs expected positions\"\"\"\n        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}\n        \n        discrepancies = []\n        \n        # Check expected positions\n        for conId, expected_qty in self.expected_positions.items():\n            actual_qty = actual_positions.get(conId, 0)\n            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': expected_qty,\n                    'actual': actual_qty,\n                    'diff': actual_qty - expected_qty\n                })\n        \n        # Check for unexpected positions\n        for conId, actual_qty in actual_positions.items():\n            if conId not in self.expected_positions and abs(actual_qty) > 0.01:\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': 0,\n                    'actual': actual_qty,\n                    'diff': actual_qty\n                })\n        \n        if discrepancies:\n            logging.warning(f\"Position discrepancies found: {discrepancies}\")\n        \n        return discrepancies\n    \n    def reset_tracking(self):\n        \"\"\"Reset to current positions\"\"\"\n        self.expected_positions = {\n            p.contract.conId: p.position \n            for p in self.ib.positions()\n        }\n\n# Usage\npm = PositionManager(ib)\npm.reset_tracking()\n\n# Track trades\nib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)\n\n# Periodic reconciliation\nwhile True:\n    discrepancies = pm.reconcile()\n    if discrepancies:\n        # Alert or take action\n        pass\n    ib.sleep(60)",
      "language": "python",
      "description": " Position Reconciliation",
      "sources": [
        "ex_0171_130315a8"
      ],
      "tags": [
        "contract",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0172_de7fe994",
      "code": "def close_all_positions(ib, exclude_symbols=None):\n    \"\"\"Emergency position closer\"\"\"\n    exclude_symbols = exclude_symbols or []\n    \n    positions = ib.positions()\n    trades = []\n    \n    for position in positions:\n        symbol = position.contract.symbol\n        \n        if symbol in exclude_symbols:\n            continue\n        \n        qty = abs(position.position)\n        action = 'SELL' if position.position > 0 else 'BUY'\n        \n        order = MarketOrder(action, qty)\n        trade = ib.placeOrder(position.contract, order)\n        trades.append(trade)\n        \n        print(f\"Closing {action} {qty} {symbol}\")\n    \n    # Wait for all to fill\n    timeout = 30\n    start = time.time()\n    \n    while any(not t.isDone() for t in trades):\n        if time.time() - start > timeout:\n            logging.error(\"Timeout waiting for position closures\")\n            break\n        ib.sleep(0.5)\n    \n    return trades\n\n# Usage - emergency exit\nif emergency_condition:\n    close_all_positions(ib)",
      "language": "python",
      "description": " Close All Positions",
      "sources": [
        "ex_0172_de7fe994"
      ],
      "tags": [
        "contract",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0173_6fdd48c4",
      "code": "def calculate_position_size(\n    ib,\n    contract,\n    risk_per_trade_pct=0.02,  # 2% risk\n    stop_loss_pct=0.05         # 5% stop\n):\n    \"\"\"Calculate position size based on risk\"\"\"\n    \n    # Get account value\n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    # Calculate dollar risk\n    dollar_risk = net_liq * risk_per_trade_pct\n    \n    # Get current price\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if not ticker.last or ticker.last != ticker.last:  # NaN check\n        logging.error(\"Unable to get price for position sizing\")\n        return 0\n    \n    price = ticker.last\n    ib.cancelMktData(contract)\n    \n    # Calculate shares\n    # dollar_risk = shares * price * stop_loss_pct\n    shares = dollar_risk / (price * stop_loss_pct)\n    \n    # Round to nearest tradeable lot\n    if contract.secType == 'OPT':\n        shares = int(shares / 100) * 100  # Options in contracts (100 shares)\n    else:\n        shares = int(shares)\n    \n    print(f\"Position size for {contract.symbol}: {shares} shares\")\n    print(f\"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})\")\n    \n    return shares\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nshares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)\n\nif shares > 0:\n    order = LimitOrder('BUY', shares, 175.0)\n    trade = ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Position Size Calculator",
      "sources": [
        "ex_0173_6fdd48c4"
      ],
      "tags": [
        "contract",
        "data",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0174_7b2a453d",
      "code": "class DailyLossLimiter:\n    def __init__(self, ib, max_daily_loss_pct=0.05):\n        self.ib = ib\n        self.max_daily_loss_pct = max_daily_loss_pct\n        self.start_equity = None\n        self.breached = False\n        \n    def initialize(self):\n        \"\"\"Set starting equity for the day\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        self.breached = False\n        print(f\"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}\")\n    \n    def check_limit(self):\n        \"\"\"Check if daily loss limit breached\"\"\"\n        if self.breached:\n            return True\n        \n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            self.breached = True\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)\")\n            return True\n        \n        return False\n    \n    def enforce(self):\n        \"\"\"Close all positions and cancel all orders\"\"\"\n        if not self.breached:\n            return\n        \n        print(\"Enforcing daily loss limit...\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        close_all_positions(self.ib)\n        \n        print(\"All positions closed. Trading halted for the day.\")\n\n# Usage\nlimiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit\nlimiter.initialize()\n\n# Check periodically\nwhile True:\n    if limiter.check_limit():\n        limiter.enforce()\n        break\n    ib.sleep(60)",
      "language": "python",
      "description": " Daily Loss Limit",
      "sources": [
        "ex_0174_7b2a453d"
      ],
      "tags": [
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0175_d2cf5153",
      "code": "def check_position_concentration(ib, max_position_pct=0.20):\n    \"\"\"Ensure no single position exceeds % of portfolio\"\"\"\n    \n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    violations = []\n    \n    for item in ib.portfolio():\n        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0\n        \n        if position_pct > max_position_pct:\n            violations.append({\n                'symbol': item.contract.symbol,\n                'value': item.marketValue,\n                'pct': position_pct,\n                'limit': max_position_pct\n            })\n    \n    if violations:\n        logging.warning(f\"Position concentration violations: {violations}\")\n    \n    return violations\n\n# Check before placing order\ndef place_order_with_concentration_check(ib, contract, order, max_pct=0.20):\n    \"\"\"Place order only if it doesn't violate concentration\"\"\"\n    \n    # Estimate new position value\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if ticker.ask:\n        estimated_value = ticker.ask * order.totalQuantity\n        \n        account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        # Get current position\n        current_position = next(\n            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),\n            0\n        )\n        \n        new_position_value = abs(current_position + estimated_value)\n        new_pct = new_position_value / net_liq if net_liq > 0 else 0\n        \n        if new_pct > max_pct:\n            logging.error(f\"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%\")\n            ib.cancelMktData(contract)\n            return None\n    \n    ib.cancelMktData(contract)\n    return ib.placeOrder(contract, order)",
      "language": "python",
      "description": " Max Position Concentration",
      "sources": [
        "ex_0175_d2cf5153"
      ],
      "tags": [
        "contract",
        "data",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0176_65541a5c",
      "code": "import numpy as np\nimport pandas as pd\n\ndef calculate_portfolio_correlation_risk(ib, lookback_days=30):\n    \"\"\"Calculate portfolio correlation matrix\"\"\"\n    \n    portfolio = ib.portfolio()\n    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']\n    \n    # Get historical data for all positions\n    price_data = {}\n    \n    for symbol in symbols:\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = ib.qualifyContracts(contract)[0]\n        \n        bars = ib.reqHistoricalData(\n            contract,\n            endDateTime='',\n            durationStr=f'{lookback_days} D',\n            barSizeSetting='1 day',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if bars:\n            price_data[symbol] = [bar.close for bar in bars]\n    \n    # Create DataFrame\n    df = pd.DataFrame(price_data)\n    \n    # Calculate returns\n    returns = df.pct_change().dropna()\n    \n    # Correlation matrix\n    corr_matrix = returns.corr()\n    \n    # Identify highly correlated pairs\n    high_corr_threshold = 0.7\n    high_corr_pairs = []\n    \n    for i in range(len(corr_matrix.columns)):\n        for j in range(i+1, len(corr_matrix.columns)):\n            corr = corr_matrix.iloc[i, j]\n            if abs(corr) > high_corr_threshold:\n                high_corr_pairs.append({\n                    'symbol1': corr_matrix.columns[i],\n                    'symbol2': corr_matrix.columns[j],\n                    'correlation': corr\n                })\n    \n    if high_corr_pairs:\n        logging.warning(f\"High correlation detected: {high_corr_pairs}\")\n    \n    return corr_matrix, high_corr_pairs\n\n# Usage\ncorr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)\nprint(\"Portfolio Correlation Matrix:\")\nprint(corr_matrix)",
      "language": "python",
      "description": " Correlation-Based Risk",
      "sources": [
        "ex_0176_65541a5c"
      ],
      "tags": [
        "contract",
        "data",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0177_8748cfe5",
      "code": "class ReconnectionManager:\n    def __init__(self, host='127.0.0.1', port=7497, clientId=1):\n        self.host = host\n        self.port = port\n        self.clientId = clientId\n        self.ib = None\n        self.reconnect_attempts = 0\n        self.max_reconnect_attempts = 10\n        self.reconnect_delay = 5\n        self.is_connected = False\n        \n    def connect(self):\n        \"\"\"Initial connection with reconnect logic\"\"\"\n        while self.reconnect_attempts < self.max_reconnect_attempts:\n            try:\n                self.ib = IB()\n                self.ib.disconnectedEvent += self.on_disconnect\n                self.ib.errorEvent += self.on_error\n                \n                self.ib.connect(\n                    self.host,\n                    self.port,\n                    self.clientId,\n                    timeout=10\n                )\n                \n                self.is_connected = True\n                self.reconnect_attempts = 0\n                logging.info(f\"Connected to TWS at {self.host}:{self.port}\")\n                \n                # Restore subscriptions\n                self.restore_state()\n                \n                return self.ib\n                \n            except Exception as e:\n                self.reconnect_attempts += 1\n                logging.error(f\"Connection attempt {self.reconnect_attempts} failed: {e}\")\n                \n                if self.reconnect_attempts >= self.max_reconnect_attempts:\n                    logging.critical(\"Max reconnection attempts reached. Giving up.\")\n                    raise\n                \n                logging.info(f\"Retrying in {self.reconnect_delay} seconds...\")\n                time.sleep(self.reconnect_delay)\n                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        self.is_connected = False\n        logging.warning(\"Disconnected from TWS. Attempting reconnect...\")\n        \n        # Save current state\n        self.save_state()\n        \n        # Attempt reconnection\n        self.connect()\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle connection errors\"\"\"\n        if errorCode in [502, 503, 504, 1100, 1101, 1102]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n            if not self.is_connected:\n                self.on_disconnect()\n    \n    def save_state(self):\n        \"\"\"Save subscriptions and state before disconnect\"\"\"\n        if not self.ib:\n            return\n        \n        # Save tickers\n        self.saved_tickers = [\n            (ticker.contract, ticker.genericTickList) \n            for ticker in self.ib.tickers()\n        ]\n        \n        # Save positions (for monitoring)\n        self.saved_positions = [\n            (p.contract, p.position) \n            for p in self.ib.positions()\n        ]\n        \n        logging.info(f\"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions\")\n    \n    def restore_state(self):\n        \"\"\"Restore subscriptions after reconnect\"\"\"\n        if not hasattr(self, 'saved_tickers'):\n            return\n        \n        logging.info(\"Restoring market data subscriptions...\")\n        \n        # Resubscribe to tickers\n        for contract, genericTickList in self.saved_tickers:\n            try:\n                self.ib.reqMktData(contract, genericTickList, False, False)\n            except Exception as e:\n                logging.error(f\"Failed to restore ticker {contract.symbol}: {e}\")\n        \n        logging.info(\"State restored\")\n\n# Usage\nconn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)\nib = conn_mgr.connect()\n\n# Normal trading operations\n# Connection will auto-reconnect on failure",
      "language": "python",
      "description": " Auto-Reconnect Manager",
      "sources": [
        "ex_0177_8748cfe5"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "error",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0178_7a9e424a",
      "code": "class HeartbeatMonitor:\n    def __init__(self, ib, timeout=60):\n        self.ib = ib\n        self.timeout = timeout\n        self.last_update = time.time()\n        self.ib.updateEvent += self.on_update\n        \n    def on_update(self):\n        \"\"\"Reset timer on any update\"\"\"\n        self.last_update = time.time()\n    \n    def check(self):\n        \"\"\"Check if connection is alive\"\"\"\n        elapsed = time.time() - self.last_update\n        \n        if elapsed > self.timeout:\n            logging.warning(f\"No updates for {elapsed:.0f}s. Connection may be dead.\")\n            return False\n        \n        return True\n    \n    def run(self):\n        \"\"\"Run heartbeat check loop\"\"\"\n        while True:\n            if not self.check():\n                logging.error(\"Heartbeat timeout. Triggering reconnect...\")\n                # Trigger reconnection\n                break\n            \n            time.sleep(10)\n\n# Usage\nheartbeat = HeartbeatMonitor(ib, timeout=60)\n# Run in separate thread or async task",
      "language": "python",
      "description": " Heartbeat Monitor",
      "sources": [
        "ex_0178_7a9e424a"
      ],
      "tags": [
        "async",
        "connect",
        "error",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0179_0c5a4c2d",
      "code": "class PortfolioRebalancer:\n    def __init__(self, ib):\n        self.ib = ib\n        \n    def rebalance_to_target(self, target_allocations, tolerance=0.05):\n        \"\"\"\n        Rebalance portfolio to target allocations\n        \n        Args:\n            target_allocations: Dict[symbol: str, target_pct: float]\n                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}\n            tolerance: Rebalance threshold (0.05 = 5%)\n        \"\"\"\n        \n        # Validate target allocations\n        total = sum(target_allocations.values())\n        if abs(total - 1.0) > 0.01:\n            raise ValueError(f\"Target allocations must sum to 1.0, got {total}\")\n        \n        # Get current portfolio\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}\n        \n        # Calculate current allocations\n        current_allocations = {\n            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)\n            for symbol, item in portfolio.items()\n        }\n        \n        # Determine needed trades\n        trades_needed = []\n        \n        for symbol, target_pct in target_allocations.items():\n            current_pct = current_allocations.get(symbol, 0)\n            diff = target_pct - current_pct\n            \n            if abs(diff) > tolerance:\n                target_value = net_liq * target_pct\n                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0\n                value_change = target_value - current_value\n                \n                # Get current price\n                contract = Stock(symbol, 'SMART', 'USD')\n                contract = self.ib.qualifyContracts(contract)[0]\n                \n                ticker = self.ib.reqMktData(contract, '', True, False)\n                self.ib.sleep(1)\n                \n                if ticker.last and ticker.last == ticker.last:\n                    price = ticker.last\n                    shares_change = int(value_change / price)\n                    \n                    if shares_change != 0:\n                        trades_needed.append({\n                            'symbol': symbol,\n                            'contract': contract,\n                            'current_pct': current_pct,\n                            'target_pct': target_pct,\n                            'shares': shares_change,\n                            'action': 'BUY' if shares_change > 0 else 'SELL'\n                        })\n                \n                self.ib.cancelMktData(contract)\n        \n        # Execute trades\n        if not trades_needed:\n            logging.info(\"Portfolio within tolerance. No rebalancing needed.\")\n            return []\n        \n        logging.info(f\"Rebalancing {len(trades_needed)} positions...\")\n        placed_trades = []\n        \n        for trade_info in trades_needed:\n            logging.info(f\"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} \"\n                        f\"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)\")\n            \n            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))\n            trade = self.ib.placeOrder(trade_info['contract'], order)\n            placed_trades.append(trade)\n        \n        return placed_trades\n\n# Usage\ntarget = {\n    'AAPL': 0.30,\n    'GOOGL': 0.30,\n    'MSFT': 0.40\n}\n\nrebalancer = PortfolioRebalancer(ib)\ntrades = rebalancer.rebalance_to_target(target, tolerance=0.03)\n\n# Monitor fills\nfor trade in trades:\n    while not trade.isDone():\n        ib.sleep(1)\n    print(f\"{trade.contract.symbol}: {trade.orderStatus.status}\")",
      "language": "python",
      "description": " Target Allocation Rebalancer",
      "sources": [
        "ex_0179_0c5a4c2d"
      ],
      "tags": [
        "contract",
        "data",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0180_c93de700",
      "code": "class DCAScheduler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.schedules = []\n        \n    def add_schedule(self, symbol, amount_per_period, frequency_days):\n        \"\"\"\n        Add DCA schedule\n        \n        Args:\n            symbol: Stock symbol\n            amount_per_period: Dollar amount to invest\n            frequency_days: Days between purchases\n        \"\"\"\n        self.schedules.append({\n            'symbol': symbol,\n            'amount': amount_per_period,\n            'frequency': frequency_days,\n            'last_purchase': None\n        })\n    \n    def check_and_execute(self):\n        \"\"\"Check if any DCA purchases are due\"\"\"\n        from datetime import datetime, timedelta\n        \n        now = datetime.now()\n        \n        for schedule in self.schedules:\n            last = schedule['last_purchase']\n            \n            # Check if purchase is due\n            if last is None or (now - last).days >= schedule['frequency']:\n                self.execute_dca(schedule)\n                schedule['last_purchase'] = now\n    \n    def execute_dca(self, schedule):\n        \"\"\"Execute DCA purchase\"\"\"\n        symbol = schedule['symbol']\n        amount = schedule['amount']\n        \n        # Create contract\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = self.ib.qualifyContracts(contract)[0]\n        \n        # Get current price\n        ticker = self.ib.reqMktData(contract, '', True, False)\n        self.ib.sleep(1)\n        \n        if ticker.last and ticker.last == ticker.last:\n            price = ticker.last\n            shares = int(amount / price)\n            \n            if shares > 0:\n                logging.info(f\"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})\")\n                order = MarketOrder('BUY', shares)\n                trade = self.ib.placeOrder(contract, order)\n                return trade\n        \n        self.ib.cancelMktData(contract)\n        return None\n\n# Usage\ndca = DCAScheduler(ib)\ndca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days\ndca.add_schedule('VTI', 500, 14)   # $500 every 14 days\n\n# Run daily check\nwhile True:\n    dca.check_and_execute()\n    ib.sleep(86400)  # Check daily",
      "language": "python",
      "description": " Dollar-Cost Averaging",
      "sources": [
        "ex_0180_c93de700"
      ],
      "tags": [
        "contract",
        "data",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0181_61f34a96",
      "code": "class TickFilter:\n    def __init__(self, ib, contract, min_size=100):\n        self.ib = ib\n        self.contract = contract\n        self.min_size = min_size\n        self.large_trades = []\n        \n    def start(self):\n        \"\"\"Start tick-by-tick subscription with filtering\"\"\"\n        self.ticker = self.ib.reqTickByTickData(\n            self.contract,\n            'AllLast',  # All trades\n            0,\n            False\n        )\n        self.ticker.updateEvent += self.on_tick\n    \n    def on_tick(self, ticker):\n        \"\"\"Filter and process ticks\"\"\"\n        if not ticker.tickByTicks:\n            return\n        \n        latest_tick = ticker.tickByTicks[-1]\n        \n        # Filter by size\n        if latest_tick.size >= self.min_size:\n            self.large_trades.append({\n                'time': latest_tick.time,\n                'price': latest_tick.price,\n                'size': latest_tick.size\n            })\n            \n            logging.info(f\"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}\")\n    \n    def stop(self):\n        \"\"\"Stop subscription\"\"\"\n        self.ib.cancelTickByTickData(self.contract)\n    \n    def get_stats(self):\n        \"\"\"Get statistics on large trades\"\"\"\n        if not self.large_trades:\n            return None\n        \n        total_volume = sum(t['size'] for t in self.large_trades)\n        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume\n        \n        return {\n            'num_trades': len(self.large_trades),\n            'total_volume': total_volume,\n            'vwap': avg_price\n        }\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nfilter = TickFilter(ib, contract, min_size=1000)\nfilter.start()\n\n# Run for period\nib.sleep(3600)  # 1 hour\n\nfilter.stop()\nstats = filter.get_stats()\nprint(f\"Large trades: {stats}\")",
      "language": "python",
      "description": " Tick-by-Tick with Filtering",
      "sources": [
        "ex_0181_61f34a96"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0182_36544bcc",
      "code": "class VolumeProfile:\n    def __init__(self, ib, contract, num_bins=20):\n        self.ib = ib\n        self.contract = contract\n        self.num_bins = num_bins\n        self.profile = {}\n        \n    def build_from_historical(self, days=1):\n        \"\"\"Build volume profile from historical data\"\"\"\n        bars = self.ib.reqHistoricalData(\n            self.contract,\n            endDateTime='',\n            durationStr=f'{days} D',\n            barSizeSetting='5 mins',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if not bars:\n            return None\n        \n        # Get price range\n        prices = [bar.close for bar in bars]\n        min_price = min(prices)\n        max_price = max(prices)\n        \n        # Create bins\n        bin_size = (max_price - min_price) / self.num_bins\n        \n        # Accumulate volume in bins\n        for bar in bars:\n            bin_idx = int((bar.close - min_price) / bin_size)\n            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max\n            \n            bin_price = min_price + (bin_idx * bin_size)\n            \n            if bin_price not in self.profile:\n                self.profile[bin_price] = 0\n            \n            self.profile[bin_price] += bar.volume\n        \n        return self.profile\n    \n    def get_poc(self):\n        \"\"\"Get Point of Control (price with highest volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        return max(self.profile.items(), key=lambda x: x[1])\n    \n    def get_value_area(self, percent=0.70):\n        \"\"\"Get value area (prices containing X% of volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        total_volume = sum(self.profile.values())\n        target_volume = total_volume * percent\n        \n        # Sort by volume\n        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)\n        \n        accumulated_volume = 0\n        value_area_prices = []\n        \n        for price, volume in sorted_profile:\n            accumulated_volume += volume\n            value_area_prices.append(price)\n            \n            if accumulated_volume >= target_volume:\n                break\n        \n        return min(value_area_prices), max(value_area_prices)\n\n# Usage\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nvp = VolumeProfile(ib, contract, num_bins=30)\nprofile = vp.build_from_historical(days=5)\n\npoc_price, poc_volume = vp.get_poc()\nprint(f\"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume\")\n\nva_low, va_high = vp.get_value_area(percent=0.70)\nprint(f\"Value Area: ${va_low:.2f} - ${va_high:.2f}\")",
      "language": "python",
      "description": " Volume Profile Builder",
      "sources": [
        "ex_0182_36544bcc"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0183_3e821cf7",
      "code": "class MultiAccountRouter:\n    def __init__(self, host='127.0.0.1', port=7497):\n        self.connections = {}\n        self.host = host\n        self.port = port\n        \n    def add_account(self, account_name, client_id):\n        \"\"\"Add account connection\"\"\"\n        ib = IB()\n        ib.connect(self.host, self.port, client_id)\n        self.connections[account_name] = ib\n        logging.info(f\"Connected account {account_name} with clientId {client_id}\")\n    \n    def place_order_all(self, contract, order_template, quantities):\n        \"\"\"\n        Place orders across multiple accounts\n        \n        Args:\n            contract: Contract to trade\n            order_template: Base order\n            quantities: Dict[account_name, quantity]\n        \"\"\"\n        trades = {}\n        \n        for account_name, quantity in quantities.items():\n            if account_name not in self.connections:\n                logging.error(f\"Account {account_name} not connected\")\n                continue\n            \n            ib = self.connections[account_name]\n            \n            # Clone order\n            order = Order(**{k: v for k, v in order_template.__dict__.items()})\n            order.totalQuantity = quantity\n            order.account = account_name\n            \n            # Place order\n            trade = ib.placeOrder(contract, order)\n            trades[account_name] = trade\n            \n            logging.info(f\"Placed {order.action} {quantity} {contract.symbol} for {account_name}\")\n        \n        return trades\n    \n    def get_combined_portfolio(self):\n        \"\"\"Get combined portfolio across all accounts\"\"\"\n        combined = {}\n        \n        for account_name, ib in self.connections.items():\n            for item in ib.portfolio():\n                symbol = item.contract.symbol\n                \n                if symbol not in combined:\n                    combined[symbol] = {\n                        'position': 0,\n                        'market_value': 0,\n                        'unrealized_pnl': 0,\n                        'accounts': {}\n                    }\n                \n                combined[symbol]['position'] += item.position\n                combined[symbol]['market_value'] += item.marketValue\n                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL\n                combined[symbol]['accounts'][account_name] = item.position\n        \n        return combined\n    \n    def disconnect_all(self):\n        \"\"\"Disconnect all accounts\"\"\"\n        for account_name, ib in self.connections.items():\n            ib.disconnect()\n            logging.info(f\"Disconnected {account_name}\")\n\n# Usage\nrouter = MultiAccountRouter()\nrouter.add_account('Account1', client_id=1)\nrouter.add_account('Account2', client_id=2)\nrouter.add_account('Account3', client_id=3)\n\n# Place order across all accounts\ncontract = Stock('AAPL', 'SMART', 'USD')\norder_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account\n\nquantities = {\n    'Account1': 100,\n    'Account2': 200,\n    'Account3': 150\n}\n\ntrades = router.place_order_all(contract, order_template, quantities)\n\n# Monitor combined portfolio\ncombined = router.get_combined_portfolio()\nfor symbol, data in combined.items():\n    print(f\"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts\")",
      "language": "python",
      "description": " Multi-Account Order Router",
      "sources": [
        "ex_0183_3e821cf7"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0184_caee834a",
      "code": "def qualify_contracts_batch(ib, contracts, batch_size=50):\n    \"\"\"Qualify contracts in batches to avoid rate limits\"\"\"\n    qualified = []\n    \n    for i in range(0, len(contracts), batch_size):\n        batch = contracts[i:i+batch_size]\n        \n        try:\n            qualified_batch = ib.qualifyContracts(*batch)\n            qualified.extend(qualified_batch)\n        except Exception as e:\n            logging.error(f\"Batch qualification failed: {e}\")\n        \n        # Respect rate limits\n        ib.sleep(1)\n    \n    return qualified",
      "language": "python",
      "description": " Batch Contract Qualification",
      "sources": [
        "ex_0184_caee834a"
      ],
      "tags": [
        "contract",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0185_3be9f3a2",
      "code": "from collections import deque\nimport threading\n\nclass RequestQueue:\n    def __init__(self, ib, max_per_second=40):\n        self.ib = ib\n        self.queue = deque()\n        self.max_per_second = max_per_second\n        self.running = False\n        \n    def add(self, func, *args, **kwargs):\n        \"\"\"Add request to queue\"\"\"\n        self.queue.append((func, args, kwargs))\n    \n    def start(self):\n        \"\"\"Start processing queue\"\"\"\n        self.running = True\n        thread = threading.Thread(target=self._process)\n        thread.daemon = True\n        thread.start()\n    \n    def _process(self):\n        \"\"\"Process queue with rate limiting\"\"\"\n        delay = 1.0 / self.max_per_second\n        \n        while self.running:\n            if self.queue:\n                func, args, kwargs = self.queue.popleft()\n                \n                try:\n                    func(*args, **kwargs)\n                except Exception as e:\n                    logging.error(f\"Request failed: {e}\")\n                \n                time.sleep(delay)\n            else:\n                time.sleep(0.1)\n    \n    def stop(self):\n        \"\"\"Stop processing\"\"\"\n        self.running = False\n\n# Usage\nqueue = RequestQueue(ib, max_per_second=40)\nqueue.start()\n\n# Queue many requests\nfor contract in large_contract_list:\n    queue.add(ib.reqMktData, contract, '', False, False)",
      "language": "python",
      "description": " Request Queue Manager",
      "sources": [
        "ex_0185_3be9f3a2"
      ],
      "tags": [
        "contract",
        "data",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0186_740a3bd3",
      "code": "\"\"\"\nProduction Trading System Template\nFeatures: Auto-reconnect, error handling, risk management, logging\n\"\"\"\n\nimport logging\nfrom datetime import datetime, time as dt_time\nfrom ib_insync import *\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s',\n    handlers=[\n        logging.FileHandler(f'trading_{datetime.now().strftime(\"%Y%m%d\")}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass ProductionTradingSystem:\n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self.ib = None\n        self.running = False\n        \n        # Risk parameters\n        self.max_daily_loss_pct = 0.03\n        self.max_position_pct = 0.20\n        self.daily_loss_breached = False\n        \n        # State tracking\n        self.start_equity = 0\n        self.trades_today = []\n        \n    def initialize(self):\n        \"\"\"Initialize system\"\"\"\n        logging.info(\"Initializing trading system...\")\n        \n        # Connect\n        self.ib = IB()\n        self.ib.errorEvent += self.on_error\n        self.ib.disconnectedEvent += self.on_disconnect\n        \n        try:\n            self.ib.connect(self.host, self.port, self.client_id, timeout=10)\n            logging.info(\"Connected to TWS\")\n        except Exception as e:\n            logging.critical(f\"Failed to connect: {e}\")\n            return False\n        \n        # Get starting equity\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        logging.info(f\"Starting equity: ${self.start_equity:,.2f}\")\n        \n        # Setup event handlers\n        self.ib.orderStatusEvent += self.on_order_status\n        self.ib.execDetailsEvent += self.on_execution\n        \n        return True\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle errors\"\"\"\n        if errorCode in [502, 503, 504]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n        elif errorCode >= 2000:\n            # Warnings\n            logging.warning(f\"Warning {errorCode}: {errorString}\")\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        logging.warning(\"Disconnected from TWS\")\n        # Attempt reconnection logic here\n    \n    def on_order_status(self, trade):\n        \"\"\"Track order status\"\"\"\n        logging.info(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    \n    def on_execution(self, trade, fill):\n        \"\"\"Track executions\"\"\"\n        self.trades_today.append(trade)\n        logging.info(f\"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}\")\n    \n    def check_risk_limits(self):\n        \"\"\"Check if risk limits breached\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        # Daily loss check\n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%\")\n            self.daily_loss_breached = True\n            self.emergency_shutdown()\n            return False\n        \n        return True\n    \n    def emergency_shutdown(self):\n        \"\"\"Emergency shutdown - close all positions\"\"\"\n        logging.critical(\"EMERGENCY SHUTDOWN INITIATED\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        for position in self.ib.positions():\n            qty = abs(position.position)\n            action = 'SELL' if position.position > 0 else 'BUY'\n            \n            order = MarketOrder(action, qty)\n            self.ib.placeOrder(position.contract, order)\n            \n            logging.info(f\"Emergency close: {action} {qty} {position.contract.symbol}\")\n        \n        self.running = False\n    \n    def is_market_hours(self):\n        \"\"\"Check if within trading hours\"\"\"\n        now = datetime.now().time()\n        market_open = dt_time(9, 30)\n        market_close = dt_time(16, 0)\n        \n        return market_open <= now <= market_close\n    \n    def run(self):\n        \"\"\"Main trading loop\"\"\"\n        if not self.initialize():\n            return\n        \n        self.running = True\n        logging.info(\"Trading system started\")\n        \n        try:\n            while self.running:\n                # Check risk limits\n                if not self.check_risk_limits():\n                    break\n                \n                # Only trade during market hours\n                if self.is_market_hours():\n                    # Your trading logic here\n                    self.trading_logic()\n                \n                # Sleep between iterations\n                self.ib.sleep(60)  # Check every minute\n                \n        except KeyboardInterrupt:\n            logging.info(\"Shutdown requested by user\")\n        except Exception as e:\n            logging.critical(f\"Unexpected error: {e}\")\n        finally:\n            self.shutdown()\n    \n    def trading_logic(self):\n        \"\"\"Implement your trading strategy here\"\"\"\n        pass\n    \n    def shutdown(self):\n        \"\"\"Graceful shutdown\"\"\"\n        logging.info(\"Shutting down trading system...\")\n        \n        if self.ib:\n            # Cancel all market data\n            for contract in [t.contract for t in self.ib.tickers()]:\n                self.ib.cancelMktData(contract)\n            \n            # Disconnect\n            self.ib.disconnect()\n        \n        logging.info(\"Shutdown complete\")\n\n# Run the system\nif __name__ == '__main__':\n    system = ProductionTradingSystem(\n        host='127.0.0.1',\n        port=7497,\n        client_id=1\n    )\n    system.run()",
      "language": "python",
      "description": " Complete Production Trading System Template",
      "sources": [
        "ex_0186_740a3bd3"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0187_9c1600a8",
      "code": "from ib_insync import *\n\n# Jupyter notebook? Uncomment:\n# util.startLoop()\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Get account info\naccount = ib.managedAccounts()[0]\nprint(f\"Connected to account: {account}\")\n\n# Create contract\ncontract = Stock('AAPL', 'SMART', 'USD')\n\n# Get market data\nticker = ib.reqMktData(contract)\nib.sleep(2)  # Wait for data\nprint(ticker.marketPrice())\n\nib.disconnect()",
      "language": "python",
      "description": " Minimal Example",
      "sources": [
        "ex_0187_9c1600a8"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0188_8e7796b2",
      "code": "class IB:\n    \"\"\"High-level interface to Interactive Brokers\"\"\"",
      "language": "python",
      "description": " Class Definition",
      "sources": [
        "ex_0188_8e7796b2"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0189_91b1ed12",
      "code": "RequestTimeout: float = 0        # Request timeout (0 = infinite)\nRaiseRequestErrors: bool = False # Raise errors vs silent fail\nMaxSyncedSubAccounts: int = 50   # Max sub-accounts to sync",
      "language": "python",
      "description": " Class Attributes",
      "sources": [
        "ex_0189_91b1ed12"
      ],
      "tags": [
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0190_1da11b26",
      "code": "events = (\n    'connectedEvent',       # Connection established\n    'disconnectedEvent',    # Connection lost\n    'updateEvent',          # Any state update\n    'pendingTickersEvent',  # Ticker updates available\n    'barUpdateEvent',       # Real-time bar update\n    'newOrderEvent',        # New order created\n    'orderModifyEvent',     # Order modified\n    'cancelOrderEvent',     # Order cancel requested\n    'openOrderEvent',       # Open order status\n    'orderStatusEvent',     # Order status changed\n    'execDetailsEvent',     # Trade execution details\n    'commissionReportEvent',# Commission report\n    'updatePortfolioEvent', # Portfolio updated\n    'positionEvent',        # Position changed\n    'accountValueEvent',    # Account value updated\n    'accountSummaryEvent',  # Account summary updated\n    'pnlEvent',            # PnL update\n    'pnlSingleEvent',      # Single position PnL\n    'scannerDataEvent',    # Scanner data received\n    'tickNewsEvent',       # News tick\n    'newsBulletinEvent',   # News bulletin\n    'errorEvent',          # Error occurred\n    'timeoutEvent'         # Request timeout\n)",
      "language": "python",
      "description": " Events",
      "sources": [
        "ex_0190_1da11b26"
      ],
      "tags": [
        "connect",
        "error",
        "event",
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0191_a0a2d809",
      "code": "# Access current state (auto-synced)\nib.accountValues()      # List[AccountValue]\nib.portfolio()          # List[PortfolioItem]\nib.positions()          # List[Position]\nib.trades()             # List[Trade]\nib.openTrades()         # List[Trade] - open only\nib.orders()             # List[Order]\nib.openOrders()         # List[Order] - open only\nib.fills()              # List[Fill]\nib.executions()         # List[Execution]\nib.tickers()            # List[Ticker]\nib.pendingTickers()     # Set[Ticker] - with updates\nib.reqId()              # int - next request ID",
      "language": "python",
      "description": " State Properties",
      "sources": [
        "ex_0191_a0a2d809"
      ],
      "tags": [
        "order",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0192_1c37caad",
      "code": "ib.connect(\n    host: str = '127.0.0.1',\n    port: int = 7497,           # 7497=TWS, 4001=Gateway\n    clientId: int = 1,          # Unique per connection\n    timeout: float = 2.0,       # Connection timeout (0=no limit)\n    readonly: bool = False,     # Read-only mode\n    account: str = '',          # Main account for updates\n    raiseSyncErrors: bool = True # Raise sync errors\n) -> None",
      "language": "python",
      "description": " Connect (Blocking)",
      "sources": [
        "ex_0192_1c37caad"
      ],
      "tags": [
        "connect",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0193_8372747c",
      "code": "await ib.connectAsync(\n    host, port, clientId, \n    timeout, readonly, account, raiseSyncErrors\n) -> None",
      "language": "python",
      "description": " Connect (Async)",
      "sources": [
        "ex_0193_8372747c"
      ],
      "tags": [
        "async",
        "connect",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0194_217875f9",
      "code": "ib.disconnect() -> None",
      "language": "python",
      "description": " Disconnect",
      "sources": [
        "ex_0194_217875f9"
      ],
      "tags": [
        "connect"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0195_8e8c97f7",
      "code": "ib.isConnected() -> bool\nib.client.isReady() -> bool  # API ready",
      "language": "python",
      "description": " Check Connection",
      "sources": [
        "ex_0195_8e8c97f7"
      ],
      "tags": [
        "connect"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0196_6af2e413",
      "code": "ib.waitOnUpdate(timeout: float = 0) -> bool\n# Wait for network update. Returns False on timeout.\n\nib.sleep(seconds: float = 0.02) -> None\n# Sleep while keeping event loop alive\n# ALWAYS use this instead of time.sleep()",
      "language": "python",
      "description": " Wait & Sleep",
      "sources": [
        "ex_0196_6af2e413"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0197_5d3a8df7",
      "code": "ib.run()  # Run until disconnect\nawait ib.runAsync()  # Async version\n\n# Condition-based iteration\nfor update in ib.loopUntil(timeout=60):\n    if condition:\n        break",
      "language": "python",
      "description": " Loop Management",
      "sources": [
        "ex_0197_5d3a8df7"
      ],
      "tags": [
        "async",
        "connect"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0198_021797a7",
      "code": "@dataclass\nclass Contract:\n    conId: int = 0              # Unique IB contract ID\n    symbol: str = ''            # Ticker symbol\n    secType: str = ''           # Security type\n    lastTradeDateOrContractMonth: str = ''\n    strike: float = 0.0\n    right: str = ''             # 'C' or 'P' for options\n    multiplier: str = ''\n    exchange: str = ''\n    primaryExchange: str = ''\n    currency: str = ''\n    localSymbol: str = ''\n    tradingClass: str = ''\n    includeExpired: bool = False\n    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC\n    secId: str = ''\n    description: str = ''\n    issuerId: str = ''\n    comboLegsDescrip: str = ''\n    comboLegs: List = None      # For combo orders\n    deltaNeutralContract: DeltaNeutralContract = None",
      "language": "python",
      "description": " Base Contract",
      "sources": [
        "ex_0198_021797a7"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0199_47b23e16",
      "code": "Stock(\n    symbol: str,\n    exchange: str = 'SMART',\n    currency: str = 'USD',\n    primaryExchange: str = ''\n)\n\n# Examples\nStock('AAPL', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nStock('BMW', 'SMART', 'EUR', primaryExchange='IBIS')",
      "language": "python",
      "description": " Stock",
      "sources": [
        "ex_0199_47b23e16"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0200_ac6252b4",
      "code": "Forex(pair: str = 'EURUSD', exchange: str = 'IDEALPRO')\n\n# Examples\nForex('EURUSD')\nForex('GBPUSD')",
      "language": "python",
      "description": " Forex",
      "sources": [
        "ex_0200_ac6252b4"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0201_30a355c3",
      "code": "Future(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nFuture('ES', '20240920', 'GLOBEX')  # E-mini S&P\nFuture('CL', '202412', 'NYMEX')     # Crude Oil",
      "language": "python",
      "description": " Future",
      "sources": [
        "ex_0201_30a355c3"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0202_8a148020",
      "code": "Option(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    strike: float = 0.0,\n    right: str = '',            # 'C' or 'P'\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nOption('SPY', '20240920', 450, 'C', 'SMART')  # Call\nOption('AAPL', '20240315', 180, 'P', 'SMART') # Put",
      "language": "python",
      "description": " Option",
      "sources": [
        "ex_0202_8a148020"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0203_d49a58bb",
      "code": "Index(symbol: str = '', exchange: str = '')\n\n# Examples\nIndex('SPX', 'CBOE')\nIndex('VIX', 'CBOE')",
      "language": "python",
      "description": " Index",
      "sources": [
        "ex_0203_d49a58bb"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0204_93b9ec89",
      "code": "CFD(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCFD('IBUS30')",
      "language": "python",
      "description": " CFD",
      "sources": [
        "ex_0204_93b9ec89"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0205_203f5234",
      "code": "Commodity(\n    symbol: str = '',\n    exchange: str = '',\n    currency: str = ''\n)\n\n# Example\nCommodity('XAUUSD', 'SMART', 'USD')",
      "language": "python",
      "description": " Commodity",
      "sources": [
        "ex_0205_203f5234"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0206_bfa34fc6",
      "code": "Bond(secIdType: str = '', secId: str = '')\n\n# Example\nBond(secIdType='ISIN', secId='US03076KAA60')",
      "language": "python",
      "description": " Bond",
      "sources": [
        "ex_0206_bfa34fc6"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0207_163692a6",
      "code": "Crypto(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCrypto('BTC', 'PAXOS', 'USD')",
      "language": "python",
      "description": " Crypto",
      "sources": [
        "ex_0207_163692a6"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0208_0ae96c65",
      "code": "Contract(conId=270639)  # Direct lookup by IB contract ID",
      "language": "python",
      "description": " Contract by conId",
      "sources": [
        "ex_0208_0ae96c65"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0209_d000a006",
      "code": "# Resolve ambiguous contracts\ncontracts = ib.qualifyContracts(contract)\n# Returns list of fully qualified contracts\n\n# Example\nstock = Stock('AAPL', 'SMART', 'USD')\nqualified = ib.qualifyContracts(stock)[0]\nprint(qualified.conId)  # IB contract ID",
      "language": "python",
      "description": " Qualify Contracts",
      "sources": [
        "ex_0209_d000a006"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0210_84bbd4a2",
      "code": "details = ib.reqContractDetails(contract)\n# Returns List[ContractDetails]\n\n# ContractDetails fields:\n# .contract - Fully qualified contract\n# .marketName\n# .minTick\n# .priceMagnifier\n# .orderTypes\n# .validExchanges\n# .underConId\n# .longName\n# .contractMonth\n# .industry\n# .category\n# .subcategory\n# .timeZoneId\n# .tradingHours\n# .liquidHours\n# And many more...",
      "language": "python",
      "description": " Contract Details",
      "sources": [
        "ex_0210_84bbd4a2"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0211_0a67635a",
      "code": "descriptions = ib.reqMatchingSymbols('app')\n# Returns List[ContractDescription]\n# Fuzzy search for symbols",
      "language": "python",
      "description": " Match Symbols",
      "sources": [
        "ex_0211_0a67635a"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0212_944e293c",
      "code": "@dataclass\nclass Order:\n    orderId: int = 0\n    clientId: int = 0\n    permId: int = 0\n    action: str = ''            # 'BUY' or 'SELL'\n    totalQuantity: float = 0.0\n    orderType: str = ''         # See order types below\n    lmtPrice: float = 0.0\n    auxPrice: float = 0.0       # Stop price\n    tif: str = 'DAY'            # Time in force\n    \n    # Advanced fields\n    ocaGroup: str = ''          # One-Cancels-All group\n    account: str = ''\n    openClose: str = 'O'        # 'O'=open, 'C'=close\n    origin: int = 0             # 0=customer\n    orderRef: str = ''\n    transmit: bool = True       # Auto-transmit\n    parentId: int = 0           # For bracket orders\n    blockOrder: bool = False\n    sweepToFill: bool = False\n    displaySize: int = 0\n    triggerMethod: int = 0\n    outsideRth: bool = False    # Outside regular hours\n    hidden: bool = False\n    \n    # Order combos\n    goodAfterTime: str = ''\n    goodTillDate: str = ''\n    rule80A: str = ''\n    allOrNone: bool = False\n    minQty: int = None\n    percentOffset: float = None\n    overridePercentageConstraints: bool = False\n    trailStopPrice: float = None\n    trailingPercent: float = None\n    \n    # Financial advisors\n    faGroup: str = ''\n    faProfile: str = ''\n    faMethod: str = ''\n    faPercentage: str = ''\n    \n    # Institutional\n    designatedLocation: str = ''\n    exemptCode: int = -1\n    \n    # Smart routing\n    discretionaryAmt: float = 0.0\n    eTradeOnly: bool = False\n    firmQuoteOnly: bool = False\n    nbboPriceCap: float = None\n    optOutSmartRouting: bool = False\n    \n    # Pegged orders\n    stockRefPrice: float = None\n    delta: float = None\n    \n    # Volatility orders\n    volatility: float = None\n    volatilityType: int = None\n    deltaNeutralOrderType: str = ''\n    deltaNeutralAuxPrice: float = None\n    deltaNeutralConId: int = 0\n    deltaNeutralShortSale: bool = False\n    deltaNeutralShortSaleSlot: int = 0\n    deltaNeutralDesignatedLocation: str = ''\n    continuousUpdate: bool = False\n    referencePriceType: int = None\n    \n    # Conditions\n    conditions: List = None\n    conditionsIgnoreRth: bool = False\n    conditionsCancelOrder: bool = False\n    \n    # Algo orders\n    algoStrategy: str = ''\n    algoParams: List = None\n    \n    # What-if\n    whatIf: bool = False\n    \n    # Misc\n    notHeld: bool = False\n    solicited: bool = False\n    randomizeSize: bool = False\n    randomizePrice: bool = False\n    \n    # Pegged to benchmark\n    referenceContractId: int = 0\n    peggedChangeAmount: float = 0.0\n    isPeggedChangeAmountDecrease: bool = False\n    referenceChangeAmount: float = 0.0\n    referenceExchangeId: str = ''\n    adjustedOrderType: str = ''\n    \n    # Misc2\n    modelCode: str = ''\n    extOperator: str = ''\n    cashQty: float = None\n    mifid2DecisionMaker: str = ''\n    mifid2DecisionAlgo: str = ''\n    mifid2ExecutionTrader: str = ''\n    mifid2ExecutionAlgo: str = ''\n    dontUseAutoPriceForHedge: bool = False\n    \n    # Manual times (for audit)\n    manualOrderTime: str = ''\n    manualOrderCancelTime: str = ''\n    \n    # Post to ATS\n    usePriceMgmtAlgo: bool = None",
      "language": "python",
      "description": " Base Order",
      "sources": [
        "ex_0212_944e293c"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0213_59eaafe2",
      "code": "MarketOrder(action: str, totalQuantity: float, **kwargs)\n\n# Examples\norder = MarketOrder('BUY', 100)\norder = MarketOrder('SELL', 50, tif='GTC')",
      "language": "python",
      "description": " Market Order",
      "sources": [
        "ex_0213_59eaafe2"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0214_436ee625",
      "code": "LimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    **kwargs\n)\n\n# Examples\norder = LimitOrder('BUY', 100, 150.50)\norder = LimitOrder('SELL', 50, 155.00, tif='GTC')",
      "language": "python",
      "description": " Limit Order",
      "sources": [
        "ex_0214_436ee625"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0198",
      "code": "StopLimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    stopPrice: float,\n    **kwargs\n)",
      "language": "python",
      "description": "Represents stop and stop-limit order types. Stop orders become market orders when the stop price is reached. Stop-limit orders become limit orders with both a stop price (trigger) and limit price (execution constraint). Use StopOrder for basic stop-loss orders (single price trigger) and StopLimitOrder for price-controlled executions.",
      "sources": [
        "ex_0215_9836d086",
        "ex_0216_1e588943"
      ],
      "tags": [
        "order",
        "stop",
        "stop-limit"
      ],
      "notes": "Key difference: StopOrder requires only stopPrice while StopLimitOrder needs both lmtPrice and stopPrice. Example 1 demonstrates a stop-loss, Example 2 shows a stop-limit with price control.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0217_b9979312",
      "code": "BracketOrder(\n    action: str,\n    quantity: float,\n    limitPrice: float,\n    takeProfitPrice: float,\n    stopLossPrice: float\n) -> Tuple[Order, Order, Order]\n\n# Returns (parent, takeProfit, stopLoss)\n# Example\nparent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0, 160.0, 145.0\n)",
      "language": "python",
      "description": " Bracket Order",
      "sources": [
        "ex_0217_b9979312"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0218_da330b8a",
      "code": "trade = ib.placeOrder(contract: Contract, order: Order) -> Trade\n# Returns Trade object (live-updated)\n\n# Example\ncontract = Stock('AAPL', 'SMART', 'USD')\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# Trade object updated in real-time:\n# - trade.orderStatus\n# - trade.fills\n# - trade.log",
      "language": "python",
      "description": " Place Order",
      "sources": [
        "ex_0218_da330b8a"
      ],
      "tags": [
        "contract",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0220_af1ad75f",
      "code": "trade = ib.cancelOrder(order: Order) -> Trade\n\n# Cancel all orders\nib.reqGlobalCancel()",
      "language": "python",
      "description": " Cancel Order",
      "sources": [
        "ex_0220_af1ad75f"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0221_39d68f86",
      "code": "@dataclass\nclass OrderStatus:\n    orderId: int = 0\n    status: str = ''        # PendingSubmit, Submitted, Filled, Cancelled, etc.\n    filled: float = 0.0\n    remaining: float = 0.0\n    avgFillPrice: float = 0.0\n    permId: int = 0\n    parentId: int = 0\n    lastFillPrice: float = 0.0\n    clientId: int = 0\n    whyHeld: str = ''\n    mktCapPrice: float = 0.0",
      "language": "python",
      "description": " Order Status",
      "sources": [
        "ex_0221_39d68f86"
      ],
      "tags": [
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0222_3d080260",
      "code": "@dataclass\nclass Trade:\n    contract: Contract = None\n    order: Order = None\n    orderStatus: OrderStatus = None\n    fills: List[Fill] = []\n    log: List[TradeLogEntry] = []\n    \n    # Methods\n    def isActive(self) -> bool\n    def isDone(self) -> bool\n    def filled(self) -> float\n    def remaining(self) -> float",
      "language": "python",
      "description": " Trade Object",
      "sources": [
        "ex_0222_3d080260"
      ],
      "tags": [
        "contract",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0204",
      "code": "orderState = ib.whatIfOrder(contract, order)\n# Test order without placing\n# Returns OrderState with commission/margin impact\n\n# OrderState fields:\n# .initMarginBefore\n# .maintMarginBefore\n# .equityWithLoanBefore\n# .initMarginAfter\n# .maintMarginAfter\n# .equityWithLoanAfter\n# .commission\n# .minCommission\n# .maxCommission\n# .commissionCurrency",
      "language": "python",
      "description": "The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis.",
      "sources": [
        "ex_0223_b7055bc8",
        "ex_0291_302efcfd"
      ],
      "tags": [
        "contract",
        "order",
        "error",
        "margin"
      ],
      "notes": "Example 1 focuses on field structure while Example 2 emphasizes debugging order rejections. Both agree on core usage but Example 2 adds error context and debugging practices.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0224_acebfcb7",
      "code": "ticker = ib.reqMktData(\n    contract: Contract,\n    genericTickList: str = '',\n    snapshot: bool = False,\n    regulatorySnapshot: bool = False,\n    mktDataOptions: List = None\n) -> Ticker\n\n# Ticker auto-updates in real-time",
      "language": "python",
      "description": " Request Market Data (Streaming)",
      "sources": [
        "ex_0224_acebfcb7"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0225_73bbdf10",
      "code": "100 - putVolume, callVolume (options)\n101 - putOpenInterest, callOpenInterest (options)\n104 - histVolatility (options)\n105 - avOptionVolume (options)\n106 - impliedVolatility (options)\n162 - indexFuturePremium\n165 - low13week, high13week, low26week, high26week,\n      low52week, high52week, avVolume\n221 - markPrice\n225 - auctionVolume, auctionPrice, auctionImbalance\n233 - last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 - shortableShares\n258 - fundamentalRatios",
      "language": "python",
      "description": "Generic Tick List IDs:",
      "sources": [
        "ex_0225_73bbdf10"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0226_109839aa",
      "code": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract, genericTickList='233,236')\nib.sleep(2)\nprint(f\"Last: {ticker.last}\")\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Volume: {ticker.volume}\")",
      "language": "python",
      "description": "Example:",
      "sources": [
        "ex_0226_109839aa"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_cluster_0208",
      "code": "ib.cancelMktData(contract: Contract) -> None\nib.cancelMktDepth(contract: Contract) -> None",
      "language": "python",
      "description": "Cancels real-time market data subscriptions. Use cancelMktData to stop receiving market data (e.g., last price, bid/ask) for a specific contract. Use cancelMktDepth to stop receiving market depth (order book level 2) data for a specific contract. Both require the original Contract object used for subscription.",
      "sources": [
        "ex_0227_032293ce",
        "ex_0230_ad78b745"
      ],
      "tags": [
        "contract",
        "market-data",
        "market-depth"
      ],
      "notes": "cancelMktData stops standard market data streams while cancelMktDepth stops level 2 market depth data. They are separate methods for different subscription types but both require the same Contract parameter.",
      "metadata": {
        "confidence": 0.95,
        "variations": 1,
        "ai_model": "deepseek/deepseek-r1"
      }
    },
    {
      "id": "merged_ex_0228_df91b679",
      "code": "@dataclass\nclass Ticker:\n    contract: Contract = None\n    time: datetime = None\n    \n    # Bid/Ask\n    bid: float = nan\n    bidSize: float = nan\n    bidExchange: str = ''\n    ask: float = nan\n    askSize: float = nan\n    askExchange: str = ''\n    \n    # Last trade\n    last: float = nan\n    lastSize: float = nan\n    lastExchange: str = ''\n    \n    # Volume\n    volume: float = nan\n    volumeRate: float = nan\n    \n    # Prices\n    open: float = nan\n    high: float = nan\n    low: float = nan\n    close: float = nan\n    vwap: float = nan\n    \n    # Options\n    putVolume: float = nan\n    callVolume: float = nan\n    putOpenInterest: float = nan\n    callOpenInterest: float = nan\n    avOptionVolume: float = nan\n    impliedVolatility: float = nan\n    histVolatility: float = nan\n    \n    # Greeks (options)\n    delta: float = nan\n    gamma: float = nan\n    theta: float = nan\n    vega: float = nan\n    \n    # Market depth\n    domBids: List = []\n    domAsks: List = []\n    domTicks: List = []\n    \n    # Ticks\n    ticks: List = []\n    tickByTicks: List = []\n    \n    # Halted\n    halted: float = nan\n    \n    # Real-time\n    rtVolume: float = nan\n    rtTime: datetime = None\n    rtHistVolativity: float = nan\n    rtTradeVolume: float = nan\n    \n    # Methods\n    def marketPrice(self) -> float\n    def hasBidAsk(self) -> bool\n    def midpoint(self) -> float",
      "language": "python",
      "description": " Ticker Object",
      "sources": [
        "ex_0228_df91b679"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0229_ad978f61",
      "code": "ticker = ib.reqMktDepth(\n    contract: Contract,\n    numRows: int = 5,\n    isSmartDepth: bool = False,\n    mktDepthOptions: List = None\n) -> Ticker\n\n# Ticker.domBids and Ticker.domAsks auto-update",
      "language": "python",
      "description": " Market Depth (Level II)",
      "sources": [
        "ex_0229_ad978f61"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0231_1f886e3e",
      "code": "ticker = ib.reqTickByTickData(\n    contract: Contract,\n    tickType: str,  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks: int = 0,\n    ignoreSize: bool = False\n) -> Ticker\n\n# Ticker.tickByTicks auto-updates",
      "language": "python",
      "description": " Tick-by-Tick Data",
      "sources": [
        "ex_0231_1f886e3e"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0232_eea923a8",
      "code": "ib.reqMarketDataType(marketDataType: int) -> None\n# 1 = Live\n# 2 = Frozen\n# 3 = Delayed\n# 4 = Delayed-Frozen",
      "language": "python",
      "description": " Market Data Type",
      "sources": [
        "ex_0232_eea923a8"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0233_443b62c5",
      "code": "bars = ib.reqHistoricalData(\n    contract: Contract,\n    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'\n    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'\n    barSizeSetting: str = '1 hour',\n    whatToShow: str = 'TRADES', # See below\n    useRTH: bool = True,        # Regular trading hours only\n    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch\n    keepUpToDate: bool = False, # Auto-update\n    chartOptions: List = None,\n    timeout: float = 60\n) -> BarDataList\n\n# Returns BarDataList (auto-synced if keepUpToDate=True)",
      "language": "python",
      "description": " Request Historical Data",
      "sources": [
        "ex_0233_443b62c5"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0234_5c6e682d",
      "code": "S = Seconds (max 60)\nD = Days (max 365)\nW = Weeks (max 52)\nM = Months (max 12)\nY = Years (max 1)",
      "language": "python",
      "description": "Duration Strings:",
      "sources": [
        "ex_0234_5c6e682d"
      ],
      "tags": [
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0235_43901f2a",
      "code": "'1 secs', '5 secs', '10 secs', '15 secs', '30 secs',\n'1 min', '2 mins', '3 mins', '5 mins', '10 mins', '15 mins', '20 mins', '30 mins',\n'1 hour', '2 hours', '3 hours', '4 hours', '8 hours',\n'1 day', '1 week', '1 month'",
      "language": "python",
      "description": "Bar Sizes:",
      "sources": [
        "ex_0235_43901f2a"
      ],
      "tags": [
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0236_612914ff",
      "code": "'TRADES'           - Actual trades\n'MIDPOINT'         - Bid/ask midpoint\n'BID'              - Bid prices\n'ASK'              - Ask prices\n'BID_ASK'          - Bid/ask pairs\n'HISTORICAL_VOLATILITY'\n'OPTION_IMPLIED_VOLATILITY'\n'REBATE_RATE'\n'FEE_RATE'\n'YIELD_BID'\n'YIELD_ASK'\n'YIELD_BID_ASK'\n'YIELD_LAST'",
      "language": "python",
      "description": "What to Show:",
      "sources": [
        "ex_0236_612914ff"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0238_11491458",
      "code": "@dataclass\nclass Bar:\n    date: datetime\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    average: float\n    barCount: int",
      "language": "python",
      "description": " Bar Object",
      "sources": [
        "ex_0238_11491458"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0239_d5adc6d3",
      "code": "ticks = ib.reqHistoricalTicks(\n    contract: Contract,\n    startDateTime: str,\n    endDateTime: str,\n    numberOfTicks: int = 1000,\n    whatToShow: str = 'TRADES',  # 'TRADES', 'BID_ASK', 'MIDPOINT'\n    useRth: bool = True,\n    ignoreSize: bool = False,\n    miscOptions: List = None\n) -> List\n\n# Returns list of HistoricalTick objects",
      "language": "python",
      "description": " Historical Ticks",
      "sources": [
        "ex_0239_d5adc6d3"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0240_38b77bc7",
      "code": "headTimestamp = ib.reqHeadTimeStamp(\n    contract: Contract,\n    whatToShow: str = 'TRADES',\n    useRTH: bool = True,\n    formatDate: int = 1\n) -> str\n\n# Earliest available data timestamp",
      "language": "python",
      "description": " Head Timestamp",
      "sources": [
        "ex_0240_38b77bc7"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0241_a43bc6b4",
      "code": "schedule = ib.reqHistoricalSchedule(\n    contract: Contract,\n    numDays: int = 1,\n    endDateTime: str = '',\n    useRTH: bool = True\n) -> List[HistoricalSchedule]\n\n# Trading schedule for contract",
      "language": "python",
      "description": " Historical Schedule",
      "sources": [
        "ex_0241_a43bc6b4"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0242_62ca894c",
      "code": "bars = ib.reqRealTimeBars(\n    contract: Contract,\n    barSize: int = 5,           # Only 5 supported\n    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK\n    useRTH: bool = False,\n    realTimeBarsOptions: List = None\n) -> RealTimeBarList\n\n# Returns RealTimeBarList (auto-updating)\n# bars.updateEvent fires on new bar",
      "language": "python",
      "description": " Real-Time Bars",
      "sources": [
        "ex_0242_62ca894c"
      ],
      "tags": [
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0243_0587e2fb",
      "code": "ib.cancelRealTimeBars(bars: RealTimeBarList) -> None",
      "language": "python",
      "description": " Cancel Real-Time Bars",
      "sources": [
        "ex_0243_0587e2fb"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0245_21f82c32",
      "code": "accounts = ib.managedAccounts() -> List[str]\n# List of account codes",
      "language": "python",
      "description": " Managed Accounts",
      "sources": [
        "ex_0245_21f82c32"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0246_af6a41c6",
      "code": "values = ib.accountValues(account: str = '') -> List[AccountValue]\n\n# AccountValue fields:\n# .account\n# .tag      - Key name (e.g., 'NetLiquidation')\n# .value    - Value as string\n# .currency\n# .modelCode",
      "language": "python",
      "description": " Account Values",
      "sources": [
        "ex_0246_af6a41c6"
      ],
      "tags": [
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0247_c0af1b5a",
      "code": "NetLiquidation      - Total account value\nTotalCashValue      - Cash balance\nSettledCash         - Settled cash\nAccruedCash         - Accrued cash\nBuyingPower         - Buying power\nEquityWithLoanValue - Stock value + cash\nGrossPositionValue  - Total position value\nRegTEquity          - RegT equity\nRegTMargin          - RegT margin\nSMA                 - Special Memo Account\nInitMarginReq       - Initial margin\nMaintMarginReq      - Maintenance margin\nAvailableFunds      - Available funds\nExcessLiquidity     - Excess liquidity",
      "language": "python",
      "description": "Common Tags:",
      "sources": [
        "ex_0247_c0af1b5a"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0248_23c41848",
      "code": "summary = ib.reqAccountSummary() -> List[AccountValue]\n# Summary for all accounts\n\n# Or filter by tags\nsummary = ib.reqAccountSummary(\n    account: str = 'All',\n    modelCode: str = '',\n    tags: str = 'NetLiquidation,TotalCashValue,BuyingPower'\n)",
      "language": "python",
      "description": " Account Summary",
      "sources": [
        "ex_0248_23c41848"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0249_f664de43",
      "code": "portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]\n\n# PortfolioItem fields:\n# .contract\n# .position        - Quantity\n# .marketPrice     - Current price\n# .marketValue     - Position value\n# .averageCost     - Avg cost basis\n# .unrealizedPNL   - Unrealized P&L\n# .realizedPNL     - Realized P&L\n# .account",
      "language": "python",
      "description": " Portfolio",
      "sources": [
        "ex_0249_f664de43"
      ],
      "tags": [
        "contract",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0250_af167094",
      "code": "positions = ib.positions(account: str = '') -> List[Position]\n\n# Position fields:\n# .account\n# .contract\n# .position       - Quantity\n# .avgCost        - Average cost",
      "language": "python",
      "description": " Positions",
      "sources": [
        "ex_0250_af167094"
      ],
      "tags": [
        "contract",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0251_fd03c5d2",
      "code": "pnl = ib.reqPnL(account: str, modelCode: str = '') -> PnL\n# Start PnL subscription\n\n# PnL fields (live-updated):\n# .account\n# .modelCode\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n\n# Cancel\nib.cancelPnL(account: str, modelCode: str = '')",
      "language": "python",
      "description": " PnL (Profit & Loss)",
      "sources": [
        "ex_0251_fd03c5d2"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0252_1a669c09",
      "code": "pnlSingle = ib.reqPnLSingle(\n    account: str,\n    modelCode: str,\n    conId: int\n) -> PnLSingle\n\n# PnLSingle fields (live-updated):\n# .account\n# .modelCode\n# .conId\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n# .position\n# .value\n\n# Cancel\nib.cancelPnLSingle(account, modelCode, conId)",
      "language": "python",
      "description": " PnL Single Position",
      "sources": [
        "ex_0252_1a669c09"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0253_4e41919c",
      "code": "# Events use eventkit library\n\n# Subscribe to event\ndef onPendingTickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.marketPrice()}\")\n\nib.pendingTickersEvent += onPendingTickers\n\n# Unsubscribe\nib.pendingTickersEvent -= onPendingTickers\n\n# One-time handler\nib.connectedEvent += lambda: print('Connected!')",
      "language": "python",
      "description": " Event Handling",
      "sources": [
        "ex_0253_4e41919c"
      ],
      "tags": [
        "connect",
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0254_d1dc505e",
      "code": "# New order placed\nib.newOrderEvent += lambda trade: print(f'New order: {trade}')\n\n# Order modified\nib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')\n\n# Order status changed\nib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')\n\n# Execution received\nib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')\n\n# Commission report\nib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')",
      "language": "python",
      "description": " Trade Events",
      "sources": [
        "ex_0254_d1dc505e"
      ],
      "tags": [
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0255_8775dd62",
      "code": "# Ticker updates\nib.pendingTickersEvent += lambda tickers: handle_tickers(tickers)\n\n# Bar updates\nib.barUpdateEvent += lambda bars, hasNewBar: handle_bars(bars, hasNewBar)\n\n# Scanner data\nib.scannerDataEvent += lambda scanData: print(scanData)",
      "language": "python",
      "description": " Market Data Events",
      "sources": [
        "ex_0255_8775dd62"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0256_d86ab109",
      "code": "# Portfolio updates\nib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')\n\n# Position changes\nib.positionEvent += lambda position: print(f'Position: {position}')\n\n# Account value updates\nib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')\n\n# PnL updates\nib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')",
      "language": "python",
      "description": " Account Events",
      "sources": [
        "ex_0256_d86ab109"
      ],
      "tags": [
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0257_81a00951",
      "code": "# Connected\nib.connectedEvent += lambda: print('Connected to TWS')\n\n# Disconnected\nib.disconnectedEvent += lambda: print('Disconnected')\n\n# Error\nib.errorEvent += lambda reqId, errorCode, errorString, contract: \\\n    print(f'Error {errorCode}: {errorString}')",
      "language": "python",
      "description": " Connection Events",
      "sources": [
        "ex_0257_81a00951"
      ],
      "tags": [
        "connect",
        "contract",
        "error",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0258_28c76fef",
      "code": "2104 - Market data farm connection OK\n2106 - Historical data farm connection OK\n2158 - Sec-def data farm connection OK",
      "language": "python",
      "description": "Warnings (informational):",
      "sources": [
        "ex_0258_28c76fef"
      ],
      "tags": [
        "connect",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0259_e9e86cd9",
      "code": "200 - No security definition found\n201 - Order rejected\n202 - Order cancelled\n321 - Error validating request\n326 - Unable to connect (check port)\n354 - Requested market data not subscribed\n404 - Order held\n502 - Couldn't connect to TWS",
      "language": "python",
      "description": "Errors:",
      "sources": [
        "ex_0259_e9e86cd9"
      ],
      "tags": [
        "connect",
        "error",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0260_9c708f65",
      "code": "# Format for IB\nformatted = util.formatIBDatetime(dt: datetime) -> str\n# Returns: 'YYYYMMDD HH:MM:SS UTC'\n\n# Parse from IB\nparsed = util.parseIBDatetime(s: str) -> Union[date, datetime]",
      "language": "python",
      "description": " Datetime Utilities",
      "sources": [
        "ex_0260_9c708f65"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0261_45f7dcb4",
      "code": "import pandas as pd\n\n# Bars to DataFrame\ndf = util.df(bars)\n\n# List of objects to DataFrame\ndf = util.df(ib.positions())\ndf = util.df(ib.accountValues())",
      "language": "python",
      "description": " Dataframe Conversion",
      "sources": [
        "ex_0261_45f7dcb4"
      ],
      "tags": [
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0262_3d6ef144",
      "code": "# Log to console\nutil.logToConsole(level=logging.INFO)\n\n# Log to file\nutil.logToFile('ib_log.txt', level=logging.DEBUG)",
      "language": "python",
      "description": " Logging",
      "sources": [
        "ex_0262_3d6ef144"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0263_1b93afa6",
      "code": "# At start of notebook\nutil.startLoop()\n\n# Or with old notebooks\nutil.patchAsyncio()",
      "language": "python",
      "description": " Jupyter Notebooks",
      "sources": [
        "ex_0263_1b93afa6"
      ],
      "tags": [
        "async"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0264_083aaf30",
      "code": "util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'\n# Integrates asyncio with Qt event loop",
      "language": "python",
      "description": " Qt Integration",
      "sources": [
        "ex_0264_083aaf30"
      ],
      "tags": [
        "async",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0265_53e6fadb",
      "code": "def callback():\n    print('Periodic task')\n\n# Schedule every 60 seconds\nhandle = util.schedule(60, callback)\n\n# Cancel scheduled task\nhandle.cancel()",
      "language": "python",
      "description": " Schedule Periodic Tasks",
      "sources": [
        "ex_0265_53e6fadb"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0266_fab63157",
      "code": "# Iterate over time periods\nfor dt in util.timeRange(\n    start='20240101',\n    end='20240131',\n    step='1 day'\n):\n    print(dt)",
      "language": "python",
      "description": " Time Range Iterator",
      "sources": [
        "ex_0266_fab63157"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0268_1fbd5182",
      "code": "# For tick data\nticker = ib.reqMktData(contract, '233')  # Last, volume, vwap\nticker.updateEvent += lambda ticker: process_tick(ticker)\n\n# For bar data\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)",
      "language": "python",
      "description": "\u2705 GOOD - Use streaming:",
      "sources": [
        "ex_0268_1fbd5182"
      ],
      "tags": [
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0269_4d249eb8",
      "code": "time.sleep(5)  # Blocks event loop!",
      "language": "python",
      "description": "\u274c BAD:",
      "sources": [
        "ex_0269_4d249eb8"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0270_c9bcedf6",
      "code": "ib.sleep(5)  # Keeps event loop running",
      "language": "python",
      "description": "\u2705 GOOD:",
      "sources": [
        "ex_0270_c9bcedf6"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0271_fda8a0c1",
      "code": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)",
      "language": "python",
      "description": "\u274c BAD - Ambiguous:",
      "sources": [
        "ex_0271_fda8a0c1"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0272_d4da6975",
      "code": "contract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\nticker = ib.reqMktData(contract)",
      "language": "python",
      "description": "\u2705 GOOD - Qualified:",
      "sources": [
        "ex_0272_d4da6975"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0273_ee1d6f63",
      "code": "while True:\n    if ticker.last > 150:\n        break\n    ib.sleep(0.1)",
      "language": "python",
      "description": "\u274c BAD - Polling:",
      "sources": [
        "ex_0273_ee1d6f63"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0274_2dd7ade1",
      "code": "def on_price_update(ticker):\n    if ticker.last > 150:\n        take_action()\n\nticker.updateEvent += on_price_update",
      "language": "python",
      "description": "\u2705 GOOD - Event-driven:",
      "sources": [
        "ex_0274_2dd7ade1"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0275_0223f3f8",
      "code": "def on_error(reqId, errorCode, errorString, contract):\n    if errorCode == 200:\n        print(f\"Contract not found: {contract}\")\n    elif errorCode == 321:\n        print(f\"Validation error: {errorString}\")\n    # Handle other errors...\n\nib.errorEvent += on_error",
      "language": "python",
      "description": "\u2705 GOOD:",
      "sources": [
        "ex_0275_0223f3f8"
      ],
      "tags": [
        "contract",
        "error",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0276_35e97390",
      "code": "try:\n    ticker = ib.reqMktData(contract)\n    # ... do work ...\nfinally:\n    ib.cancelMktData(contract)\n    ib.disconnect()",
      "language": "python",
      "description": "\u2705 GOOD:",
      "sources": [
        "ex_0276_35e97390"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0277_e3d77231",
      "code": "# ib-insync handles throttling automatically\nfor contract in large_list:\n    ib.reqMktData(contract)\n# No manual delays needed",
      "language": "python",
      "description": "\u2705 GOOD - Built-in throttling:",
      "sources": [
        "ex_0277_e3d77231"
      ],
      "tags": [
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0279_792ef977",
      "code": "def on_disconnect():\n    print(\"Disconnected! Attempting reconnect...\")\n    reconnect_logic()\n\nib.disconnectedEvent += on_disconnect",
      "language": "python",
      "description": "\u2705 GOOD:",
      "sources": [
        "ex_0279_792ef977"
      ],
      "tags": [
        "connect",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0280_7ff23534",
      "code": "ib = IB()\nib.RequestTimeout = 30  # 30 second timeout\nib.RaiseRequestErrors = True  # Raise exceptions\n\ntry:\n    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)\nexcept asyncio.TimeoutError:\n    print(\"Connection timeout!\")",
      "language": "python",
      "description": "\u2705 GOOD:",
      "sources": [
        "ex_0280_7ff23534"
      ],
      "tags": [
        "async",
        "connect",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0281_2484482f",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        symbol = ticker.contract.symbol\n        price = ticker.marketPrice()\n        volume = ticker.volume\n        print(f\"{symbol}: ${price:.2f} | Vol: {volume}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract, '', False, False)\n\n# Run forever\nib.run()",
      "language": "python",
      "description": " Pattern: Live Ticker Monitor",
      "sources": [
        "ex_0281_2484482f"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0282_2728ae87",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\ncontract = ib.qualifyContracts(contract)[0]\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += on_bar_update\n\nib.run()",
      "language": "python",
      "description": " Pattern: Real-Time Bar Processing",
      "sources": [
        "ex_0282_2728ae87"
      ],
      "tags": [
        "connect",
        "contract",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0283_bdce8c76",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Strategy parameters\nquantity = 100\nentry_price = None\nposition = 0\n\ndef on_tick(ticker):\n    global entry_price, position\n    price = ticker.last\n    \n    if price is None or price != price:  # NaN check\n        return\n    \n    # Entry logic\n    if position == 0 and should_enter(price):\n        order = MarketOrder('BUY', quantity)\n        trade = ib.placeOrder(contract, order)\n        entry_price = price\n        position = quantity\n        print(f\"ENTRY: Buy {quantity} @ {price}\")\n    \n    # Exit logic\n    elif position > 0 and should_exit(price, entry_price):\n        order = MarketOrder('SELL', quantity)\n        trade = ib.placeOrder(contract, order)\n        profit = (price - entry_price) * quantity\n        print(f\"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}\")\n        position = 0\n        entry_price = None\n\ndef should_enter(price):\n    # Your entry logic\n    return False\n\ndef should_exit(price, entry):\n    # Your exit logic (e.g., stop loss, take profit)\n    return False\n\nticker = ib.reqMktData(contract, '233', False, False)\nticker.updateEvent += on_tick\n\nib.run()",
      "language": "python",
      "description": " Pattern: Automated Trading Strategy",
      "sources": [
        "ex_0283_bdce8c76"
      ],
      "tags": [
        "connect",
        "contract",
        "data",
        "error",
        "event",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0284_51b7c018",
      "code": "from ib_insync import *\nimport pandas as pd\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Download multiple timeframes\ntimeframes = [\n    ('1 Y', '1 day'),\n    ('6 M', '1 hour'),\n    ('30 D', '15 mins')\n]\n\nall_data = {}\nfor duration, barsize in timeframes:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=barsize,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    df = util.df(bars)\n    all_data[f'{duration}_{barsize}'] = df\n    print(f\"Downloaded {len(bars)} {barsize} bars for {duration}\")\n\n# Save to files\nfor name, df in all_data.items():\n    df.to_csv(f\"{contract.symbol}_{name}.csv\", index=False)\n\nib.disconnect()",
      "language": "python",
      "description": " Pattern: Historical Data Download",
      "sources": [
        "ex_0284_51b7c018"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0285_a059ab35",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef show_portfolio():\n    print(\"\\n=== PORTFOLIO ===\")\n    for item in ib.portfolio():\n        symbol = item.contract.symbol\n        pos = item.position\n        price = item.marketPrice\n        value = item.marketValue\n        pnl = item.unrealizedPNL\n        print(f\"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}\")\n    \n    print(\"\\n=== ACCOUNT ===\")\n    values = ib.accountValues()\n    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']\n    for value in values:\n        if value.tag in important_tags:\n            print(f\"{value.tag:20} | {value.value:15} {value.currency}\")\n\ndef on_update(item):\n    show_portfolio()\n\n# Show initial state\nshow_portfolio()\n\n# Update on changes\nib.updatePortfolioEvent += on_update\n\nib.run()",
      "language": "python",
      "description": " Pattern: Portfolio Monitor",
      "sources": [
        "ex_0285_a059ab35"
      ],
      "tags": [
        "connect",
        "contract",
        "event",
        "portfolio"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0286_c1f31f77",
      "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\n# Get option chain\nchains = ib.reqSecDefOptParams(\n    underlying.symbol,\n    '',\n    underlying.secType,\n    underlying.conId\n)\n\nprint(f\"Found {len(chains)} option chains\")\n\n# Get chain for specific exchange\nchain = next(c for c in chains if c.exchange == 'SMART')\nprint(f\"Trading class: {chain.tradingClass}\")\nprint(f\"Expirations: {sorted(chain.expirations)[:5]}\")  # First 5\nprint(f\"Strike range: {min(chain.strikes)} - {max(chain.strikes)}\")\n\n# Request contracts for specific expiration\nexpiration = sorted(chain.expirations)[0]\nstrikes = sorted([s for s in chain.strikes if 400 < s < 500])\n\ncontracts = [\n    Option('SPY', expiration, strike, right, 'SMART')\n    for strike in strikes[:5]\n    for right in ['C', 'P']\n]\n\n# Qualify and get details\ncontracts = ib.qualifyContracts(*contracts)\n\n# Request market data\nfor contract in contracts:\n    ticker = ib.reqMktData(contract, '', False, False)\n    ib.sleep(1)\n    print(f\"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}\")\n\nib.disconnect()",
      "language": "python",
      "description": " Pattern: Option Chain Analysis",
      "sources": [
        "ex_0286_c1f31f77"
      ],
      "tags": [
        "connect",
        "contract",
        "data"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0287_6fea4d44",
      "code": "# Solutions:\n# 1. Check TWS/Gateway is running\n# 2. Check correct port (7497=TWS, 4001=Gateway)\n# 3. Enable API in TWS settings\n# 4. Check firewall\n# 5. Verify clientId is unique\n\n# Test connection\nimport socket\nsock = socket.socket()\ntry:\n    sock.connect(('127.0.0.1', 7497))\n    print(\"Port is open\")\nexcept:\n    print(\"Cannot connect to port\")\nfinally:\n    sock.close()",
      "language": "python",
      "description": "Error 502: Couldn't connect to TWS",
      "sources": [
        "ex_0287_6fea4d44"
      ],
      "tags": [
        "connect",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0288_6880db86",
      "code": "# Check API settings in TWS:\n# Configuration -> API -> Settings\n# - Enable ActiveX and Socket Clients\n# - Socket port: 7497 (TWS) or 4001 (Gateway)\n# - Trusted IPs: 127.0.0.1\n# - Master API client ID: (optional)",
      "language": "python",
      "description": "Error 326: Unable to connect",
      "sources": [
        "ex_0288_6880db86"
      ],
      "tags": [
        "connect",
        "contract",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0290_5eea209b",
      "code": "# Don't use waitOnUpdate() loop for ticks - data loss!\n\n# \u274c BAD\nwhile True:\n    ib.waitOnUpdate()\n    # Some ticks lost!\n\n# \u2705 GOOD - Use events\nticker.updateEvent += lambda t: process(t)",
      "language": "python",
      "description": "Missing tick data",
      "sources": [
        "ex_0290_5eea209b"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0292_6d4e3880",
      "code": "# Check:\n# 1. Correct clientId\n# 2. \"Download open orders on connection\" enabled in TWS\n# 3. Use ib.openOrders() not ib.reqOpenOrders()\n\n# Sync orders\nib.reqOpenOrders()  # Legacy, can be stale\nib.openOrders()     # Better - auto-synced",
      "language": "python",
      "description": "Orders not showing",
      "sources": [
        "ex_0292_6d4e3880"
      ],
      "tags": [
        "connect",
        "order"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0293_aec1b4a0",
      "code": "# Common causes:\n# 1. Requesting too much data\n# 2. Invalid date range\n# 3. Contract not found\n# 4. No data available for period\n\n# Solution: Break into chunks\ndt = ''\nall_bars = []\nwhile True:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime=dt,\n        durationStr='30 D',\n        barSizeSetting='1 hour',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    if not bars:\n        break\n    all_bars.extend(bars)\n    dt = bars[0].date\n    ib.sleep(1)  # Respect rate limits",
      "language": "python",
      "description": "Error 162: Historical Market Data Service error",
      "sources": [
        "ex_0293_aec1b4a0"
      ],
      "tags": [
        "contract",
        "data",
        "error"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0294_41afd91b",
      "code": "# Solutions:\n# 1. Reduce simultaneous requests\n# 2. Use batch requests where possible\n# 3. Increase TWS memory allocation\n# 4. Use keepUpToDate for live bars instead of repeated requests\n\n# Increase TWS memory:\n# Configuration -> Settings -> Memory Allocation -> 4096 MB",
      "language": "python",
      "description": "Slow responses",
      "sources": [
        "ex_0294_41afd91b"
      ],
      "tags": [],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0295_b291fa9b",
      "code": "# IB throttles automatically at 45 req/sec\n# Monitor throttle events:\n\ndef on_throttle_start():\n    print(\"Throttling started\")\n\ndef on_throttle_end():\n    print(\"Throttling ended\")\n\nib.client.throttleStart += on_throttle_start\nib.client.throttleEnd += on_throttle_end",
      "language": "python",
      "description": "Too many requests",
      "sources": [
        "ex_0295_b291fa9b"
      ],
      "tags": [
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0296_3cf79bd0",
      "code": "# At start of notebook:\nutil.startLoop()\n\n# If still issues:\nutil.patchAsyncio()\n\n# For old notebooks:\nimport nest_asyncio\nnest_asyncio.apply()",
      "language": "python",
      "description": "Event loop conflicts",
      "sources": [
        "ex_0296_3cf79bd0"
      ],
      "tags": [
        "async",
        "event"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    },
    {
      "id": "merged_ex_0297_f097284e",
      "code": "# Cancel unused tickers\nfor contract in old_contracts:\n    ib.cancelMktData(contract)\n\n# Clear refs\ndel ticker",
      "language": "python",
      "description": "Ticker accumulation",
      "sources": [
        "ex_0297_f097284e"
      ],
      "tags": [
        "contract"
      ],
      "notes": "Single example, no duplicates found",
      "metadata": {
        "confidence": 1.0,
        "variations": 0
      }
    }
  ],
  "original_count": 297,
  "merged_count": 272,
  "deduplication_ratio": 0.08417508417508418,
  "clusters": [
    {
      "cluster_id": "cluster_0000",
      "examples": [
        {
          "id": "ex_0001_73157af0",
          "code": "from ib_insync import *\norder = MarketOrder('BUY', 100)",
          "language": "python",
          "context": " Market Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 7,
          "heading": "Market Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0001_73157af0"
    },
    {
      "cluster_id": "cluster_0001",
      "examples": [
        {
          "id": "ex_0002_8770c7ad",
          "code": "order = LimitOrder('BUY', 100, 175.50)",
          "language": "python",
          "context": " Limit Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 13,
          "heading": "Limit Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0002_8770c7ad"
    },
    {
      "cluster_id": "cluster_0002",
      "examples": [
        {
          "id": "ex_0003_3baa2883",
          "code": "order = StopOrder('SELL', 100, 170.00)  # Stop loss",
          "language": "python",
          "context": " Stop Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 18,
          "heading": "Stop Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0003_3baa2883"
    },
    {
      "cluster_id": "cluster_0003",
      "examples": [
        {
          "id": "ex_0004_1edc2880",
          "code": "parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 175.0,\n    takeProfitPrice=185.0,\n    stopLossPrice=170.0\n)\n\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Bracket Order (Entry + Exits)",
          "source_file": "ib_orders_reference.md",
          "line_number": 23,
          "heading": "Bracket Order (Entry + Exits)",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        },
        {
          "id": "ex_0278_3d95d75e",
          "code": "parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0,\n    takeProfitPrice=160.0,\n    stopLossPrice=145.0\n)\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1424,
          "heading": "8. Use Bracket Orders for Protection",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.9724469160768453,
      "canonical": "ex_0004_1edc2880"
    },
    {
      "cluster_id": "cluster_0004",
      "examples": [
        {
          "id": "ex_0005_a46437c8",
          "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # 2%\norder.tif = 'GTC'",
          "language": "python",
          "context": " Trailing Stop",
          "source_file": "ib_orders_reference.md",
          "line_number": 35,
          "heading": "Trailing Stop",
          "tags": [
            "order"
          ]
        },
        {
          "id": "ex_0153_fcded4d3",
          "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # Trail by 2%\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Trailing Stop Loss (Percentage)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 125,
          "heading": "Trailing Stop Loss (Percentage)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.8990291262135923,
      "canonical": "ex_0005_a46437c8"
    },
    {
      "cluster_id": "cluster_0005",
      "examples": [
        {
          "id": "ex_0006_ce50b185",
          "code": "# Trigger when SPY hits 450\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\ntrigger_contract = ib.qualifyContracts(trigger_contract)[0]\n\ncondition = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # Above price\n    price=450.0\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]",
          "language": "python",
          "context": " Conditional Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 45,
          "heading": "Conditional Order",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0006_ce50b185"
    },
    {
      "cluster_id": "cluster_0006",
      "examples": [
        {
          "id": "ex_0007_aba79f2a",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST')\n]",
          "language": "python",
          "context": " TWAP (Large Orders)",
          "source_file": "ib_orders_reference.md",
          "line_number": 63,
          "heading": "TWAP (Large Orders)",
          "tags": [
            "order"
          ]
        },
        {
          "id": "ex_0160_aae7547e",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000  # Large order\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\n# TWAP algo\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1')\n]\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " TWAP (Time-Weighted Average Price)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 239,
          "heading": "TWAP (Time-Weighted Average Price)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.89610912858294,
      "canonical": "ex_0007_aba79f2a"
    },
    {
      "cluster_id": "cluster_0007",
      "examples": [
        {
          "id": "ex_0008_d7830359",
          "code": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\norder = LimitOrder('BUY', 100, 175.0)\ntrade = ib.placeOrder(contract, order)\n\n# Wait for fill\nwhile not trade.isDone():\n    ib.sleep(0.1)\n\nprint(f\"Status: {trade.orderStatus.status}\")",
          "language": "python",
          "context": " Basic Pattern",
          "source_file": "ib_orders_reference.md",
          "line_number": 80,
          "heading": "Basic Pattern",
          "tags": [
            "connect",
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0008_d7830359"
    },
    {
      "cluster_id": "cluster_0008",
      "examples": [
        {
          "id": "ex_0009_55344dab",
          "code": "# Check buying power first\norder_copy = Order(**{k: v for k, v in order.__dict__.items()})\norder_copy.whatIf = True\n\norderState = ib.whatIfOrder(contract, order_copy)\nif orderState.commission > 0:\n    trade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " With Validation",
          "source_file": "ib_orders_reference.md",
          "line_number": 98,
          "heading": "With Validation",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0009_55344dab"
    },
    {
      "cluster_id": "cluster_0009",
      "examples": [
        {
          "id": "ex_0010_7e8f1098",
          "code": "ib.cancelOrder(order)",
          "language": "python",
          "context": " Cancel Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 111,
          "heading": "Cancel Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0010_7e8f1098"
    },
    {
      "cluster_id": "cluster_0010",
      "examples": [
        {
          "id": "ex_0011_18b44996",
          "code": "ib.reqGlobalCancel()",
          "language": "python",
          "context": " Cancel All",
          "source_file": "ib_orders_reference.md",
          "line_number": 116,
          "heading": "Cancel All",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0011_18b44996"
    },
    {
      "cluster_id": "cluster_0011",
      "examples": [
        {
          "id": "ex_0012_ae79ffd3",
          "code": "order.lmtPrice = 176.0\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Modify Order",
          "source_file": "ib_orders_reference.md",
          "line_number": 121,
          "heading": "Modify Order",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0219_e7868613",
          "code": "# Modify existing order\norder.lmtPrice = 151.0\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Modify Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 584,
          "heading": "Modify Order",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.9669908307863295,
      "canonical": "ex_0012_ae79ffd3"
    },
    {
      "cluster_id": "cluster_0012",
      "examples": [
        {
          "id": "ex_0013_489b83e2",
          "code": "def on_order_status(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n\nib.orderStatusEvent += on_order_status",
          "language": "python",
          "context": " Monitor Status",
          "source_file": "ib_orders_reference.md",
          "line_number": 127,
          "heading": "Monitor Status",
          "tags": [
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0013_489b83e2"
    },
    {
      "cluster_id": "cluster_0013",
      "examples": [
        {
          "id": "ex_0014_cbe2f695",
          "code": "option = Option('SPY', '20240315', 450, 'C', 'SMART')\noption = ib.qualifyContracts(option)[0]\norder = LimitOrder('BUY', 10, 5.50)\ntrade = ib.placeOrder(option, order)",
          "language": "python",
          "context": " Single Option",
          "source_file": "ib_orders_reference.md",
          "line_number": 137,
          "heading": "Single Option",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0014_cbe2f695"
    },
    {
      "cluster_id": "cluster_0014",
      "examples": [
        {
          "id": "ex_0015_e4716efb",
          "code": "buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')\n]\n\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread\ntrade = ib.placeOrder(combo, order)",
          "language": "python",
          "context": " Vertical Spread",
          "source_file": "ib_orders_reference.md",
          "line_number": 145,
          "heading": "Vertical Spread",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0166_08a5d66a",
          "code": "# Sell near-term, buy far-term (same strike)\nnear_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nfar_call = Option('SPY', '20240615', 450, 'C', 'SMART')\n\ncontracts = ib.qualifyContracts(near_call, far_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='SELL', exchange='SMART'),\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='BUY', exchange='SMART'),\n]\n\norder = LimitOrder('BUY', 10, 0.75)\ntrade = ib.placeOrder(combo, order)",
          "language": "python",
          "context": " Calendar Spread",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 397,
          "heading": "Calendar Spread",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.8808432316746925,
      "canonical": "ex_0015_e4716efb"
    },
    {
      "cluster_id": "cluster_0015",
      "examples": [
        {
          "id": "ex_0016_8c2fb027",
          "code": "'DAY'    # Day order (default)\n'GTC'    # Good till cancelled\n'IOC'    # Immediate or cancel\n'GTD'    # Good till date\n'FOK'    # Fill or kill",
          "language": "python",
          "context": " Time In Force",
          "source_file": "ib_orders_reference.md",
          "line_number": 167,
          "heading": "Time In Force",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0016_8c2fb027"
    },
    {
      "cluster_id": "cluster_0016",
      "examples": [
        {
          "id": "ex_0017_6a11bf25",
          "code": "# 1. Enter position\nentry = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry)\n\n# 2. Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    avg_price = entry_trade.orderStatus.avgFillPrice\n    \n    # 3. Set stop loss\n    stop = StopOrder('SELL', 100, avg_price * 0.98)  # 2% stop\n    ib.placeOrder(contract, stop)\n    \n    # 4. Set take profit\n    target = LimitOrder('SELL', 100, avg_price * 1.05)  # 5% profit\n    ib.placeOrder(contract, target)",
          "language": "python",
          "context": " Position Entry with Protection",
          "source_file": "ib_orders_reference.md",
          "line_number": 178,
          "heading": "Position Entry with Protection",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0017_6a11bf25"
    },
    {
      "cluster_id": "cluster_0017",
      "examples": [
        {
          "id": "ex_0018_ce1ccb8b",
          "code": "# Scale in\nfor qty in [25, 25, 25, 25]:\n    order = LimitOrder('BUY', qty, price)\n    ib.placeOrder(contract, order)\n    ib.sleep(300)  # 5 min between orders\n\n# Scale out\ntotal_position = 100\nfor pct in [0.25, 0.25, 0.25, 0.25]:\n    qty = int(total_position * pct)\n    order = LimitOrder('SELL', qty, price)\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Scale In/Out",
          "source_file": "ib_orders_reference.md",
          "line_number": 200,
          "heading": "Scale In/Out",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0018_ce1ccb8b"
    },
    {
      "cluster_id": "cluster_0018",
      "examples": [
        {
          "id": "ex_0019_2cc9e38b",
          "code": "def place_order_safe(ib, contract, order):\n    try:\n        trade = ib.placeOrder(contract, order)\n        \n        # Wait with timeout\n        timeout = 10\n        start = time.time()\n        while trade.orderStatus.status == 'PendingSubmit':\n            if time.time() - start > timeout:\n                ib.cancelOrder(order)\n                raise TimeoutError(\"Order submission timeout\")\n            ib.sleep(0.1)\n        \n        return trade\n    except Exception as e:\n        print(f\"Order failed: {e}\")\n        return None",
          "language": "python",
          "context": " Error Handling",
          "source_file": "ib_orders_reference.md",
          "line_number": 217,
          "heading": "Error Handling",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0019_2cc9e38b"
    },
    {
      "cluster_id": "cluster_0019",
      "examples": [
        {
          "id": "ex_0020_eb569bed",
          "code": "while True:\n    bars = ib.reqHistoricalData(...)  # DON'T POLL!\n    time.sleep(5)",
          "language": "python",
          "context": "\u274c NEVER DO THIS:",
          "source_file": "ib_data_reference.md",
          "line_number": 9,
          "heading": "\u26a0\ufe0f CRITICAL RULE",
          "tags": [
            "data"
          ]
        },
        {
          "id": "ex_0267_ecb56a32",
          "code": "while True:\n    bars = ib.reqHistoricalData(...)\n    time.sleep(5)  # Also wrong - blocks event loop!",
          "language": "python",
          "context": "\u274c BAD - Don't poll historical data:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1320,
          "heading": "1. Use Real-Time Feeds, Not Repeated Historical Requests",
          "tags": [
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0020_eb569bed"
    },
    {
      "cluster_id": "cluster_0020",
      "examples": [
        {
          "id": "ex_0021_b4426143",
          "code": "# For ticks\nticker = ib.reqMktData(contract)\nticker.updateEvent += process_tick\n\n# For bars  \nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += process_bar",
          "language": "python",
          "context": "\u2705 ALWAYS DO THIS:",
          "source_file": "ib_data_reference.md",
          "line_number": 16,
          "heading": "\u26a0\ufe0f CRITICAL RULE",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0021_b4426143"
    },
    {
      "cluster_id": "cluster_0021",
      "examples": [
        {
          "id": "ex_0022_a3f0f5a9",
          "code": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Start streaming\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data\nib.sleep(2)\n\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Last: {ticker.last}\")\nprint(f\"Volume: {ticker.volume}\")",
          "language": "python",
          "context": " Basic Ticker (Streaming)",
          "source_file": "ib_data_reference.md",
          "line_number": 31,
          "heading": "Basic Ticker (Streaming)",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0022_a3f0f5a9"
    },
    {
      "cluster_id": "cluster_0022",
      "examples": [
        {
          "id": "ex_0023_e4cf6f06",
          "code": "def on_ticker_update(ticker):\n    print(f\"{ticker.contract.symbol}: ${ticker.last:.2f}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_ticker_update",
          "language": "python",
          "context": " With Event Handler",
          "source_file": "ib_data_reference.md",
          "line_number": 51,
          "heading": "With Event Handler",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0023_e4cf6f06"
    },
    {
      "cluster_id": "cluster_0023",
      "examples": [
        {
          "id": "ex_0024_0e65c2b1",
          "code": "# Request additional data\nticker = ib.reqMktData(\n    contract,\n    genericTickList='233,236',  # Volume, shortable shares\n    snapshot=False\n)\n\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}\")\nprint(f\"RT Volume: {ticker.rtVolume}\")",
          "language": "python",
          "context": " Generic Ticks (Extra Data)",
          "source_file": "ib_data_reference.md",
          "line_number": 60,
          "heading": "Generic Ticks (Extra Data)",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0024_0e65c2b1"
    },
    {
      "cluster_id": "cluster_0024",
      "examples": [
        {
          "id": "ex_0025_b431b910",
          "code": "100 - Option volume\n101 - Option open interest  \n104 - Historical volatility\n106 - Implied volatility\n165 - 52-week high/low\n221 - Mark price\n233 - Last, volume, VWAP\n236 - Shortable shares\n258 - Fundamental ratios",
          "language": "python",
          "context": " Generic Tick IDs",
          "source_file": "ib_data_reference.md",
          "line_number": 74,
          "heading": "Generic Tick IDs",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0025_b431b910"
    },
    {
      "cluster_id": "cluster_0025",
      "examples": [
        {
          "id": "ex_0026_bff1f5f7",
          "code": "ib.cancelMktData(contract)",
          "language": "python",
          "context": " Cancel Streaming",
          "source_file": "ib_data_reference.md",
          "line_number": 87,
          "heading": "Cancel Streaming",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0026_bff1f5f7"
    },
    {
      "cluster_id": "cluster_0026",
      "examples": [
        {
          "id": "ex_0027_f3914538",
          "code": "bars = ib.reqRealTimeBars(\n    contract,\n    barSize=5,              # Always 5 seconds\n    whatToShow='TRADES',    # TRADES, MIDPOINT, BID, ASK\n    useRTH=False\n)\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"{bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close} V:{bar.volume}\")\n\nbars.updateEvent += on_bar_update\n\n# Cancel when done\nib.cancelRealTimeBars(bars)",
          "language": "python",
          "context": " Real-Time Bars (5-Second Updates)",
          "source_file": "ib_data_reference.md",
          "line_number": 95,
          "heading": "Real-Time Bars (5-Second Updates)",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0027_f3914538"
    },
    {
      "cluster_id": "cluster_0027",
      "examples": [
        {
          "id": "ex_0028_df8dcf24",
          "code": "bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',          # '' = now\n    durationStr='30 D',      # 30 days\n    barSizeSetting='1 hour',\n    whatToShow='TRADES',\n    useRTH=True              # Regular hours only\n)\n\n# Convert to pandas\ndf = util.df(bars)\nprint(df.head())",
          "language": "python",
          "context": " Basic Historical Request",
          "source_file": "ib_data_reference.md",
          "line_number": 119,
          "heading": "Basic Historical Request",
          "tags": [
            "contract",
            "data"
          ]
        },
        {
          "id": "ex_0237_f1541456",
          "code": "contract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='30 D',\n    barSizeSetting='1 hour',\n    whatToShow='MIDPOINT',\n    useRTH=True\n)\n\n# Convert to pandas\nimport pandas as pd\ndf = util.df(bars)\nprint(df.head())",
          "language": "python",
          "context": "Example:",
          "source_file": "ib_complete_reference.md",
          "line_number": 906,
          "heading": "Returns BarDataList (auto-synced if keepUpToDate=True)",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 0.8653299057412167,
      "canonical": "ex_0028_df8dcf24"
    },
    {
      "cluster_id": "cluster_0028",
      "examples": [
        {
          "id": "ex_0029_6e6893b1",
          "code": "'60 S'  - 60 seconds\n'1 D'   - 1 day\n'2 W'   - 2 weeks\n'6 M'   - 6 months\n'1 Y'   - 1 year",
          "language": "python",
          "context": " Duration Options",
          "source_file": "ib_data_reference.md",
          "line_number": 135,
          "heading": "Duration Options",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0029_6e6893b1"
    },
    {
      "cluster_id": "cluster_0029",
      "examples": [
        {
          "id": "ex_0030_b39d58cf",
          "code": "'1 secs', '5 secs', '15 secs', '30 secs'\n'1 min', '5 mins', '15 mins', '30 mins'\n'1 hour', '4 hours'\n'1 day', '1 week', '1 month'",
          "language": "python",
          "context": " Bar Sizes",
          "source_file": "ib_data_reference.md",
          "line_number": 144,
          "heading": "Bar Sizes",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0030_b39d58cf"
    },
    {
      "cluster_id": "cluster_0030",
      "examples": [
        {
          "id": "ex_0031_809d444a",
          "code": "'TRADES'    - Actual trades (default)\n'MIDPOINT'  - Bid/ask midpoint\n'BID'       - Bid prices\n'ASK'       - Ask prices",
          "language": "python",
          "context": " What to Show",
          "source_file": "ib_data_reference.md",
          "line_number": 152,
          "heading": "What to Show",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0031_809d444a"
    },
    {
      "cluster_id": "cluster_0031",
      "examples": [
        {
          "id": "ex_0032_34b0e6c2",
          "code": "bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    keepUpToDate=True  # \u2190 Auto-update!\n)\n\nbars.updateEvent += lambda bars, hasNewBar: print(f\"Updated: {hasNewBar}\")",
          "language": "python",
          "context": " Keep Historical Updated (Live)",
          "source_file": "ib_data_reference.md",
          "line_number": 160,
          "heading": "Keep Historical Updated (Live)",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0032_34b0e6c2"
    },
    {
      "cluster_id": "cluster_0032",
      "examples": [
        {
          "id": "ex_0033_b6bbded7",
          "code": "ticker = ib.reqTickByTickData(\n    contract,\n    tickType='AllLast',  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks=0,\n    ignoreSize=False\n)\n\ndef on_tick(ticker):\n    if ticker.tickByTicks:\n        tick = ticker.tickByTicks[-1]\n        print(f\"Tick: {tick.time} {tick.price} x {tick.size}\")\n\nticker.updateEvent += on_tick",
          "language": "python",
          "context": " Tick-by-Tick Data",
          "source_file": "ib_data_reference.md",
          "line_number": 178,
          "heading": "Tick-by-Tick Data",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0033_b6bbded7"
    },
    {
      "cluster_id": "cluster_0033",
      "examples": [
        {
          "id": "ex_0034_785d16e2",
          "code": "ticker = ib.reqMktDepth(\n    contract,\n    numRows=10,\n    isSmartDepth=False\n)\n\nib.sleep(2)\n\nprint(\"Bids:\")\nfor bid in ticker.domBids:\n    print(f\"  {bid.price} x {bid.size}\")\n\nprint(\"Asks:\")\nfor ask in ticker.domAsks:\n    print(f\"  {ask.price} x {ask.size}\")\n\n# Cancel\nib.cancelMktDepth(contract)",
          "language": "python",
          "context": " Market Depth (Level II)",
          "source_file": "ib_data_reference.md",
          "line_number": 198,
          "heading": "Market Depth (Level II)",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0034_785d16e2"
    },
    {
      "cluster_id": "cluster_0034",
      "examples": [
        {
          "id": "ex_0035_c23ecc05",
          "code": "contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: ${ticker.marketPrice():.2f}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract)\n\nib.run()  # Run event loop",
          "language": "python",
          "context": " Multiple Tickers Pattern",
          "source_file": "ib_data_reference.md",
          "line_number": 223,
          "heading": "Multiple Tickers Pattern",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0035_c23ecc05"
    },
    {
      "cluster_id": "cluster_0035",
      "examples": [
        {
          "id": "ex_0036_b007e6a8",
          "code": "# 1 = Live (subscription required)\n# 2 = Frozen (snapshot)\n# 3 = Delayed (free, 15-min delay)\n# 4 = Delayed-Frozen\n\nib.reqMarketDataType(3)  # Use delayed data (free)",
          "language": "python",
          "context": " Market Data Type",
          "source_file": "ib_data_reference.md",
          "line_number": 249,
          "heading": "Market Data Type",
          "tags": []
        },
        {
          "id": "ex_0289_2973e326",
          "code": "# Your account lacks market data subscription\n# Options:\n# 1. Subscribe to market data in account management\n# 2. Use reqMarketDataType(3) for delayed data\n# 3. Use reqMarketDataType(4) for frozen delayed\n\nib.reqMarketDataType(3)  # Delayed data (free)",
          "language": "python",
          "context": "Error 354: Requested market data not subscribed",
          "source_file": "ib_complete_reference.md",
          "line_number": 1732,
          "heading": "Market Data Issues",
          "tags": [
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0036_b007e6a8"
    },
    {
      "cluster_id": "cluster_0036",
      "examples": [
        {
          "id": "ex_0037_86e01f21",
          "code": "def price_alert(ticker, target_price, above=True):\n    \"\"\"Alert when price crosses threshold\"\"\"\n    def check_price(ticker):\n        if not ticker.last or ticker.last != ticker.last:\n            return\n        \n        if above and ticker.last >= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} above ${target_price}\")\n            ticker.updateEvent -= check_price  # Unsubscribe\n        elif not above and ticker.last <= target_price:\n            print(f\"ALERT: {ticker.contract.symbol} below ${target_price}\")\n            ticker.updateEvent -= check_price\n    \n    ticker.updateEvent += check_price\n\n# Usage\nticker = ib.reqMktData(contract)\nprice_alert(ticker, 180.0, above=True)",
          "language": "python",
          "context": " Price Alert System",
          "source_file": "ib_data_reference.md",
          "line_number": 263,
          "heading": "Price Alert System",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0037_86e01f21"
    },
    {
      "cluster_id": "cluster_0037",
      "examples": [
        {
          "id": "ex_0038_342563ba",
          "code": "class MovingAverage:\n    def __init__(self, period=20):\n        self.period = period\n        self.prices = []\n    \n    def update(self, price):\n        self.prices.append(price)\n        if len(self.prices) > self.period:\n            self.prices.pop(0)\n    \n    def value(self):\n        return sum(self.prices) / len(self.prices) if self.prices else None\n\nma20 = MovingAverage(20)\n\ndef on_bar(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        ma20.update(bar.close)\n        if ma20.value():\n            print(f\"Price: {bar.close:.2f} | MA20: {ma20.value():.2f}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += on_bar",
          "language": "python",
          "context": " Moving Average Calculator",
          "source_file": "ib_data_reference.md",
          "line_number": 285,
          "heading": "Moving Average Calculator",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0038_342563ba"
    },
    {
      "cluster_id": "cluster_0038",
      "examples": [
        {
          "id": "ex_0039_6faded7e",
          "code": "class OHLCTracker:\n    def __init__(self):\n        self.open = None\n        self.high = None\n        self.low = None\n        self.close = None\n    \n    def update(self, price):\n        if self.open is None:\n            self.open = price\n        \n        if self.high is None or price > self.high:\n            self.high = price\n        \n        if self.low is None or price < self.low:\n            self.low = price\n        \n        self.close = price\n    \n    def reset(self):\n        self.open = self.high = self.low = self.close = None\n\ntracker = OHLCTracker()\n\ndef on_tick(ticker):\n    if ticker.last:\n        tracker.update(ticker.last)\n        print(f\"O:{tracker.open} H:{tracker.high} L:{tracker.low} C:{tracker.close}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += on_tick",
          "language": "python",
          "context": " OHLC Tracker",
          "source_file": "ib_data_reference.md",
          "line_number": 313,
          "heading": "OHLC Tracker",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0039_6faded7e"
    },
    {
      "cluster_id": "cluster_0039",
      "examples": [
        {
          "id": "ex_0040_8452a621",
          "code": "# Blocking interface - simple and direct\nfrom ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)  # Blocks until complete",
          "language": "python",
          "context": "Every request method exists in two versions. Blocking methods like reqHistoricalData() wait for completion and return results directly. Asynchronous methods like reqHistoricalDataAsync() return corout...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 19,
          "heading": "The dual interface architecture",
          "tags": [
            "async",
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0040_8452a621"
    },
    {
      "cluster_id": "cluster_0040",
      "examples": [
        {
          "id": "ex_0041_e5acebcb",
          "code": "# Asynchronous interface - non-blocking\nimport asyncio\nfrom ib_insync import *\n\nasync def main():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking\n    \nasyncio.run(main())",
          "language": "python",
          "context": "ib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)   Blocks until complete\n",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 28,
          "heading": "Blocking interface - simple and direct",
          "tags": [
            "async",
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0041_e5acebcb"
    },
    {
      "cluster_id": "cluster_0041",
      "examples": [
        {
          "id": "ex_0042_4c1e2894",
          "code": "# WRONG - freezes everything\nimport time\nticker = ib.reqMktData(contract)\ntime.sleep(5)  # Event loop frozen, no updates processed\nprint(ticker.last)  # May be empty\n\n# CORRECT - allows message processing\nticker = ib.reqMktData(contract)\nib.sleep(5)  # Framework processes updates in background\nprint(ticker.last)  # Contains current data",
          "language": "python",
          "context": "The golden rule: never use time.sleep()\u2014always use ib.sleep(). Blocking Python's sleep freezes the event loop, preventing message processing and causing data accumulation. The ib.sleep() method yields...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 45,
          "heading": "Event loop management patterns",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0042_4c1e2894"
    },
    {
      "cluster_id": "cluster_0042",
      "examples": [
        {
          "id": "ex_0043_5d3bba14",
          "code": "# Jupyter notebook setup\nfrom ib_insync import *\n\nutil.startLoop()  # Enables nested event loops\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n# Can now use blocking methods directly in notebook cells",
          "language": "python",
          "context": "For Jupyter notebooks and environments with existing event loops, use util.startLoop() or util.patchAsyncio() to enable nested event loops via the nestasyncio package.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 60,
          "heading": "CORRECT - allows message processing",
          "tags": [
            "async",
            "connect",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0043_5d3bba14"
    },
    {
      "cluster_id": "cluster_0043",
      "examples": [
        {
          "id": "ex_0044_cff8313a",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef onTicker(ticker):\n    print(f\"Price update: {ticker.contract.symbol} @ {ticker.last}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTicker\n\nib.run()  # Runs event loop indefinitely",
          "language": "python",
          "context": "For applications that run indefinitely monitoring markets or managing positions, use the ib.run() method to keep the event loop active. Set up event handlers first, then call run() to process events u...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 74,
          "heading": "Long-running applications with continuous event loops",
          "tags": [
            "connect",
            "contract",
            "data",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0044_cff8313a"
    },
    {
      "cluster_id": "cluster_0044",
      "examples": [
        {
          "id": "ex_0045_4e24d1aa",
          "code": "# Synchronous event handler\ndef onOrderStatus(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    if trade.isDone():\n        print(f\"Filled at: {trade.orderStatus.avgFillPrice}\")\n\nib.orderStatusEvent += onOrderStatus\n\n# Asynchronous event handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        print(f\"New bar: {bars[-1]}\")\n        # Can use await inside async handlers\n        await ib.qualifyContractsAsync(contract)\n\nbars.updateEvent += onBarUpdate",
          "language": "python",
          "context": "ibinsync uses the eventkit library for its event system. Events fire asynchronously and you subscribe using the += operator. Event handlers can be either synchronous functions or async coroutines.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 93,
          "heading": "Event handling in async contexts",
          "tags": [
            "async",
            "contract",
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0045_4e24d1aa"
    },
    {
      "cluster_id": "cluster_0045",
      "examples": [
        {
          "id": "ex_0046_d613ad24",
          "code": "contract = Forex('EURUSD')\nticker = ib.reqMktData(contract)\n\nasync def onTickerUpdate(ticker):\n    print(f\"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}\")\n    \nticker.updateEvent += onTickerUpdate",
          "language": "python",
          "context": "Ticker-specific events provide fine-grained control over individual market data subscriptions:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 114,
          "heading": "Asynchronous event handler",
          "tags": [
            "async",
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0046_d613ad24"
    },
    {
      "cluster_id": "cluster_0046",
      "examples": [
        {
          "id": "ex_0047_02297e7d",
          "code": "# Unsubscribe\nticker.updateEvent -= onTickerUpdate\n\n# One-time handler\n@ticker.updateEvent.once\ndef onFirstUpdate(ticker):\n    print(f\"First update received: {ticker.last}\")",
          "language": "python",
          "context": "Unsubscribe from events using the -= operator, and use the @event.once decorator for one-time handlers that automatically unsubscribe after firing.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 126,
          "heading": "Asynchronous event handler",
          "tags": [
            "async",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0047_02297e7d"
    },
    {
      "cluster_id": "cluster_0047",
      "examples": [
        {
          "id": "ex_0048_4f262d22",
          "code": "async def get_multiple_contracts():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    contracts = [\n        Stock('AAPL', 'SMART', 'USD'),\n        Stock('GOOGL', 'SMART', 'USD'),\n        Stock('MSFT', 'SMART', 'USD')\n    ]\n    \n    # Request all contract details concurrently\n    results = await asyncio.gather(*[\n        ib.reqContractDetailsAsync(c) for c in contracts\n    ])\n    \n    return results",
          "language": "python",
          "context": "Leverage asyncio.gather() to execute multiple requests concurrently, dramatically reducing total execution time for batch operations.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 140,
          "heading": "Concurrent operations with asyncio",
          "tags": [
            "async",
            "connect",
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0048_4f262d22"
    },
    {
      "cluster_id": "cluster_0048",
      "examples": [
        {
          "id": "ex_0049_17c31825",
          "code": "async def monitor_multiple_tickers():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    async def watch_ticker(contract):\n        ticker = ib.reqMktData(contract)\n        await ib.sleep(1)\n        return ticker\n    \n    # Create tasks for concurrent execution\n    tasks = [\n        asyncio.create_task(watch_ticker(Forex('EURUSD'))),\n        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),\n        asyncio.create_task(watch_ticker(Forex('USDJPY')))\n    ]\n    \n    tickers = await asyncio.gather(*tasks)\n    return tickers",
          "language": "python",
          "context": "Use asyncio.createtask() for truly concurrent execution of independent operations:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 161,
          "heading": "Concurrent operations with asyncio",
          "tags": [
            "async",
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0049_17c31825"
    },
    {
      "cluster_id": "cluster_0049",
      "examples": [
        {
          "id": "ex_0050_6a97af6f",
          "code": "# WRONG - blocks event loop in callback\ndef onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        ib.qualifyContracts(contract)  # Blocking!\n\n# CORRECT - use async handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        await ib.qualifyContractsAsync(contract)",
          "language": "python",
          "context": "Blocking callbacks: Never make blocking calls inside event handlers. Use async versions of methods with await, or schedule the blocking work separately.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 188,
          "heading": "Critical async pitfalls to avoid",
          "tags": [
            "async",
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0050_6a97af6f"
    },
    {
      "cluster_id": "cluster_0050",
      "examples": [
        {
          "id": "ex_0051_76c1e159",
          "code": "# WRONG - misses rapid ticks\nwhile True:\n    ib.waitOnUpdate()\n    print(ticker.last)\n\n# CORRECT - captures all updates\ndef onTicker(ticker):\n    print(ticker.last)\n    \nticker.updateEvent += onTicker",
          "language": "python",
          "context": "Missing tick data with waitOnUpdate(): The waitOnUpdate() method can miss rapid updates because ticks from the first update get cleared before processing. Always use event handlers for tick data colle...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 204,
          "heading": "CORRECT - use async handler",
          "tags": [
            "async",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0051_76c1e159"
    },
    {
      "cluster_id": "cluster_0051",
      "examples": [
        {
          "id": "ex_0052_e56ea900",
          "code": "# Internal architecture (conceptual)\nIB Instance\n    \u2514\u2500\u2500 Wrapper Instance (single source of truth)\n        \u251c\u2500\u2500 accountValues (dict)\n        \u251c\u2500\u2500 acctSummary (dict)\n        \u251c\u2500\u2500 portfolio (defaultdict)\n        \u251c\u2500\u2500 positions (defaultdict)\n        \u251c\u2500\u2500 trades (dict)\n        \u251c\u2500\u2500 tickers (dict)\n        \u2514\u2500\u2500 [other state collections]\n    \u2514\u2500\u2500 Client Instance (network communication)",
          "language": "python",
          "context": "The IB class provides the user-facing interface, but internally delegates all state storage to the Wrapper. This Wrapper maintains dictionaries for account values, portfolio items, positions, trades, ...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 231,
          "heading": "The Wrapper as central state container",
          "tags": [
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0052_e56ea900"
    },
    {
      "cluster_id": "cluster_0052",
      "examples": [
        {
          "id": "ex_0053_127607b2",
          "code": "# CORRECT - access live state\ndef check_positions():\n    positions = ib.positions()\n    for pos in positions:\n        print(f\"{pos.contract.symbol}: {pos.position}\")\n\n# WRONG - storing stale copies\ncached_positions = ib.positions()  # Snapshot becomes stale\n# Later...\nprint(cached_positions)  # Likely outdated",
          "language": "python",
          "context": "The critical pattern: never store copies of state in long-lived variables. Always call IB methods to access current state. Stored copies become stale as the Wrapper updates in the background.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 251,
          "heading": "Always access fresh state, never cache",
          "tags": [
            "contract",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0053_127607b2"
    },
    {
      "cluster_id": "cluster_0053",
      "examples": [
        {
          "id": "ex_0054_2b50dee3",
          "code": "# Trade object is automatically updated\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# trade.orderStatus updates automatically in background\ndef check_order_status():\n    if trade.orderStatus.status == 'Filled':\n        print(\"Order filled!\")\n    elif trade.isDone():\n        print(\"Order completed\")",
          "language": "python",
          "context": "The returned objects themselves\u2014Ticker, Trade, Position, Portfolio\u2014are live references that the framework updates automatically. A Ticker object from reqMktData() continuously updates its bid, ask, an...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 266,
          "heading": "Later...",
          "tags": [
            "contract",
            "data",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0054_2b50dee3"
    },
    {
      "cluster_id": "cluster_0054",
      "examples": [
        {
          "id": "ex_0055_3cb13bff",
          "code": "def onPositionUpdate(position):\n    print(f\"Position: {position.contract.symbol}: {position.position}\")\n\nib.positionEvent += onPositionUpdate\n\ndef onPortfolioUpdate(item):\n    print(f\"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}\")\n\nib.updatePortfolioEvent += onPortfolioUpdate",
          "language": "python",
          "context": "Use events for real-time updates rather than polling. The framework fires events whenever state changes, allowing immediate reaction without constant checking.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 283,
          "heading": "Event-driven updates for real-time monitoring",
          "tags": [
            "contract",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0055_3cb13bff"
    },
    {
      "cluster_id": "cluster_0055",
      "examples": [
        {
          "id": "ex_0056_43a0d333",
          "code": "def onUpdate():\n    positions = ib.positions()\n    print(f\"Current positions: {len(positions)}\")\n\nib.updateEvent += onUpdate",
          "language": "python",
          "context": "The global updateEvent fires on any state change, useful for triggering comprehensive checks:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 297,
          "heading": "Event-driven updates for real-time monitoring",
          "tags": [
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0056_43a0d333"
    },
    {
      "cluster_id": "cluster_0056",
      "examples": [
        {
          "id": "ex_0057_0fc7542b",
          "code": "def long_calculation():\n    for i in range(1000):\n        result = expensive_operation()\n        \n        # Periodically yield to allow state updates\n        if i % 100 == 0:\n            ib.sleep(0)\n        \n        # State may have changed during sleep\n        current_positions = ib.positions()",
          "language": "python",
          "context": "When performing calculations or processing that takes significant time, yield control to the event loop periodically using ib.sleep(0). This allows the Wrapper to process incoming messages and update ...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 309,
          "heading": "Yielding control in long operations",
          "tags": [
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0057_0fc7542b"
    },
    {
      "cluster_id": "cluster_0057",
      "examples": [
        {
          "id": "ex_0058_425a6b9f",
          "code": "# All portfolio items across accounts\nall_portfolio = ib.portfolio()\n\n# Portfolio for specific account\naccount_portfolio = ib.portfolio(account='U1234567')\n\n# All positions\nall_positions = ib.positions()\n\n# Positions for specific account\naccount_positions = ib.positions(account='U1234567')\n\n# Iterate through positions\nfor position in ib.positions():\n    symbol = position.contract.symbol\n    qty = position.position\n    avg_cost = position.avgCost\n    print(f\"{symbol}: {qty} @ ${avg_cost}\")",
          "language": "python",
          "context": " Patterns for accessing portfolio and positions",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 324,
          "heading": "Patterns for accessing portfolio and positions",
          "tags": [
            "contract",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0058_425a6b9f"
    },
    {
      "cluster_id": "cluster_0058",
      "examples": [
        {
          "id": "ex_0059_7013efa0",
          "code": "# Get all open orders\nopen_orders = ib.orders()\n\n# Get all trades (open and completed from this session)\nall_trades = ib.trades()\n\n# Get all fills from this session\nfills = ib.fills()\n\n# Request all open orders including from other clients\nib.reqAllOpenOrders()",
          "language": "python",
          "context": " Trade and order management state",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 347,
          "heading": "Trade and order management state",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0059_7013efa0"
    },
    {
      "cluster_id": "cluster_0059",
      "examples": [
        {
          "id": "ex_0060_374afa70",
          "code": "# WRONG - threading with asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nexecutor = ThreadPoolExecutor(max_workers=2)\nexecutor.submit(ib.positions)  # Will fail!\n\n# CORRECT - use asyncio tasks\nasync def fetch_multiple_contracts():\n    tasks = [\n        ib.qualifyContractsAsync(contract1),\n        ib.qualifyContractsAsync(contract2),\n        ib.qualifyContractsAsync(contract3)\n    ]\n    results = await asyncio.gather(*tasks)\n    return results",
          "language": "python",
          "context": "ibinsync uses asyncio and is not thread-safe. All operations should occur on the main event loop thread. Use asyncio tasks for concurrency within the event loop, not traditional threading.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 365,
          "heading": "Thread safety and concurrency",
          "tags": [
            "async",
            "contract",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0060_374afa70"
    },
    {
      "cluster_id": "cluster_0060",
      "examples": [
        {
          "id": "ex_0061_f269a415",
          "code": "class TradingBot:\n    def __init__(self, ib):\n        self.ib = ib\n        self._positions_cache = None\n        self._cache_time = None\n        \n    def get_positions(self, max_age=1.0):\n        \"\"\"Get positions with short-term caching\"\"\"\n        now = time.time()\n        if (self._positions_cache is None or \n            self._cache_time is None or \n            now - self._cache_time > max_age):\n            self._positions_cache = self.ib.positions()\n            self._cache_time = now\n        return self._positions_cache",
          "language": "python",
          "context": "Caching with incorrect invalidation: If you must cache state for performance, implement short-lived caching with explicit refresh logic.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 388,
          "heading": "Common anti-patterns and mistakes",
          "tags": [
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0061_f269a415"
    },
    {
      "cluster_id": "cluster_0061",
      "examples": [
        {
          "id": "ex_0062_4ca1eb17",
          "code": "def get_price():\n    if not ib.isConnected():\n        raise ConnectionError(\"Not connected to IB\")\n    ticker = ib.reqMktData(contract)\n    ib.sleep(2)\n    if ticker.last:\n        return ticker.last\n    raise ValueError(\"No price data available\")",
          "language": "python",
          "context": "Not checking connection state: Always verify connection before state access.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 408,
          "heading": "Common anti-patterns and mistakes",
          "tags": [
            "connect",
            "contract",
            "data",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0062_4ca1eb17"
    },
    {
      "cluster_id": "cluster_0062",
      "examples": [
        {
          "id": "ex_0063_228c81f6",
          "code": "from ib_insync import *\nimport logging\n\nclass IBDataManager:\n    \"\"\"Demonstrates best practices for single source of truth pattern\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self._setup_logging()\n        self._setup_events()\n    \n    def _setup_logging(self):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n    \n    def _setup_events(self):\n        self.ib.connectedEvent += self._on_connected\n        self.ib.disconnectedEvent += self._on_disconnected\n        self.ib.positionEvent += self._on_position\n        self.ib.updatePortfolioEvent += self._on_portfolio\n    \n    def connect(self):\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(\"Connected to IB\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _on_connected(self):\n        self.logger.info(\"Connection established\")\n        self.ib.reqAccountSummary()\n    \n    def _on_disconnected(self):\n        self.logger.warning(\"Disconnected from IB\")\n    \n    def _on_position(self, position):\n        self.logger.info(f\"Position update: {position.contract.symbol}\")\n    \n    def _on_portfolio(self, item):\n        self.logger.info(f\"Portfolio update: {item.contract.symbol}\")\n    \n    def get_current_positions(self):\n        \"\"\"Get current positions (always fresh from single source)\"\"\"\n        if not self.ib.isConnected():\n            raise ConnectionError(\"Not connected\")\n        return self.ib.positions()\n    \n    def get_position_for_symbol(self, symbol):\n        \"\"\"Get position for specific symbol\"\"\"\n        for pos in self.get_current_positions():\n            if pos.contract.symbol == symbol:\n                return pos\n        return None",
          "language": "python",
          "context": " Production-ready state manager",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 421,
          "heading": "Production-ready state manager",
          "tags": [
            "connect",
            "contract",
            "error",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0063_228c81f6"
    },
    {
      "cluster_id": "cluster_0063",
      "examples": [
        {
          "id": "ex_0064_bdc1144a",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Create and qualify contract\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Create and place market order\norder = MarketOrder('BUY', 100)\ntrade = ib.placeOrder(contract, order)\n\n# Monitor order status\nprint(f\"Order status: {trade.orderStatus.status}\")",
          "language": "python",
          "context": "Market orders execute immediately at the current market price with no price protection. They're the simplest order type but carry slippage risk in volatile markets.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 492,
          "heading": "Market orders",
          "tags": [
            "connect",
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0064_bdc1144a"
    },
    {
      "cluster_id": "cluster_0064",
      "examples": [
        {
          "id": "ex_0065_1584a6ea",
          "code": "def order_status_callback(trade):\n    if trade.orderStatus.status == 'Filled':\n        fill = trade.fills[-1]\n        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '\n              f'{fill.execution.shares} @ {fill.execution.avgPrice}')\n\ntrade.filledEvent += order_status_callback",
          "language": "python",
          "context": "Market orders often execute so quickly that intermediate status callbacks are skipped. Always monitor execDetails events rather than relying solely on orderStatus for market orders.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 512,
          "heading": "Monitor order status",
          "tags": [
            "contract",
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0065_1584a6ea"
    },
    {
      "cluster_id": "cluster_0065",
      "examples": [
        {
          "id": "ex_0066_d7c5ce88",
          "code": "# Basic limit order\nlimit_order = LimitOrder('BUY', 100, 150.00)\ntrade = ib.placeOrder(contract, limit_order)\n\n# Limit order with time-in-force\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.tif = 'GTD'  # Good Till Date\nlimit_order.goodTillDate = '20240331 23:59:59'\ntrade = ib.placeOrder(contract, limit_order)\n\n# Allow outside regular trading hours\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.outsideRth = True\ntrade = ib.placeOrder(contract, limit_order)",
          "language": "python",
          "context": "Limit orders execute only at the specified price or better, providing price protection but no guarantee of execution. Set time-in-force parameters to control order lifespan.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 526,
          "heading": "Limit orders",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0066_d7c5ce88"
    },
    {
      "cluster_id": "cluster_0066",
      "examples": [
        {
          "id": "ex_0067_f66f09e8",
          "code": "# Trailing stop with fixed dollar amount\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.auxPrice = 2.0  # Trail by $2\ntrailing_order.trailStopPrice = 150.0  # Initial trigger price\n\ntrade = ib.placeOrder(contract, trailing_order)\n\n# Trailing stop with percentage\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.trailingPercent = 5.0  # Trail by 5%\n\ntrade = ib.placeOrder(contract, trailing_order)",
          "language": "python",
          "context": "Trailing stops follow favorable price movement, maintaining a specified distance from the highest price reached (for sells) or lowest price (for buys). They protect profits while allowing continued up...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 551,
          "heading": "Trailing stop orders",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0067_f66f09e8"
    },
    {
      "cluster_id": "cluster_0067",
      "examples": [
        {
          "id": "ex_0068_68d1eeb1",
          "code": "trail_limit_order = Order()\ntrail_limit_order.orderType = 'TRAIL LIMIT'\ntrail_limit_order.totalQuantity = 100\ntrail_limit_order.action = 'SELL'\ntrail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop\ntrail_limit_order.auxPrice = 2.0  # Trail amount\ntrail_limit_order.trailStopPrice = 150.0\n\ntrade = ib.placeOrder(contract, trail_limit_order)",
          "language": "python",
          "context": "Trailing stop limit orders trigger a limit order (rather than market order) when the stop is hit, providing more control but risking non-execution:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 574,
          "heading": "Trailing stop with percentage",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0068_68d1eeb1"
    },
    {
      "cluster_id": "cluster_0068",
      "examples": [
        {
          "id": "ex_0069_97afc54d",
          "code": "# Using the helper method (recommended)\norders = [\n    LimitOrder('BUY', 100, 150.00),\n    LimitOrder('BUY', 100, 149.00),\n    LimitOrder('BUY', 100, 148.00)\n]\n\noca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)\n\nfor order in oca_orders:\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": "OCO orders link multiple orders such that when one executes, the others automatically cancel. Use for scenarios like placing buy orders at multiple price levels where you only want one fill.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 592,
          "heading": "OCO (One-Cancels-Other) orders",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0069_97afc54d"
    },
    {
      "cluster_id": "cluster_0069",
      "examples": [
        {
          "id": "ex_0070_e2d9a68a",
          "code": "oca_group_name = 'MyOCAGroup_123'\n\norder1 = LimitOrder('BUY', 100, 150.00)\norder1.ocaGroup = oca_group_name\norder1.ocaType = 2  # Proportional reduction with block\norder1.transmit = False\n\norder2 = LimitOrder('BUY', 100, 149.00)\norder2.ocaGroup = oca_group_name\norder2.ocaType = 2\norder2.transmit = False\n\norder3 = LimitOrder('BUY', 100, 148.00)\norder3.ocaGroup = oca_group_name\norder3.ocaType = 2\norder3.transmit = True  # Last order triggers transmission\n\nib.placeOrder(contract, order1)\nib.placeOrder(contract, order2)\nib.placeOrder(contract, order3)",
          "language": "python",
          "context": "Manual OCO setup provides more control over individual order parameters:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 608,
          "heading": "Using the helper method (recommended)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0070_e2d9a68a"
    },
    {
      "cluster_id": "cluster_0070",
      "examples": [
        {
          "id": "ex_0071_a5aa41ea",
          "code": "# Using the helper function (recommended)\nbracket = ib.bracketOrder(\n    'BUY',\n    quantity=100,\n    limitPrice=150.00,\n    takeProfitPrice=155.00,\n    stopLossPrice=145.00\n)\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": "Bracket orders combine an entry order with both profit target and stop loss orders, providing complete position management in a single atomic operation. The children (profit and stop) only activate af...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 639,
          "heading": "Bracket orders",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0071_a5aa41ea"
    },
    {
      "cluster_id": "cluster_0071",
      "examples": [
        {
          "id": "ex_0072_20869a92",
          "code": "bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)\nbracket[0].orderType = 'MKT'\nbracket[0].lmtPrice = 0\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": "For market entry instead of limit entry, modify the parent order:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 655,
          "heading": "Using the helper function (recommended)",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0072_20869a92"
    },
    {
      "cluster_id": "cluster_0072",
      "examples": [
        {
          "id": "ex_0073_68026665",
          "code": "parent = Order()\nparent.orderId = ib.client.getReqId()\nparent.action = 'BUY'\nparent.orderType = 'LMT'\nparent.totalQuantity = 100\nparent.lmtPrice = 150.00\nparent.transmit = False\n\ntakeProfit = Order()\ntakeProfit.orderId = parent.orderId + 1\ntakeProfit.action = 'SELL'\ntakeProfit.orderType = 'LMT'\ntakeProfit.totalQuantity = 100\ntakeProfit.lmtPrice = 155.00\ntakeProfit.parentId = parent.orderId\ntakeProfit.transmit = False\n\nstopLoss = Order()\nstopLoss.orderId = parent.orderId + 2\nstopLoss.action = 'SELL'\nstopLoss.orderType = 'STP'\nstopLoss.auxPrice = 145.00\nstopLoss.totalQuantity = 100\nstopLoss.parentId = parent.orderId\nstopLoss.transmit = True  # Last order triggers all\n\nib.placeOrder(contract, parent)\nib.placeOrder(contract, takeProfit)\nib.placeOrder(contract, stopLoss)",
          "language": "python",
          "context": "Manual bracket construction for full control:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 666,
          "heading": "Using the helper function (recommended)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0073_68026665"
    },
    {
      "cluster_id": "cluster_0073",
      "examples": [
        {
          "id": "ex_0074_62270345",
          "code": "from typing import NamedTuple\n\nclass BracketOrderTwoTargets(NamedTuple):\n    parent: Order\n    takeProfit1: Order\n    takeProfit2: Order\n    stopLoss: Order\n\ndef bracket_two_targets(action, quantity, limit_price, \n                       tp_price1, tp_price2, sl_price, ib):\n    \"\"\"Create bracket with two take-profit targets\"\"\"\n    \n    parent = LimitOrder(action, quantity, limit_price)\n    parent.orderId = ib.client.getReqId()\n    parent.transmit = False\n    \n    # First take profit (half position)\n    takeProfit1 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price1\n    )\n    takeProfit1.orderId = parent.orderId + 1\n    takeProfit1.parentId = parent.orderId\n    takeProfit1.transmit = False\n    \n    # Second take profit (remaining half)\n    takeProfit2 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price2\n    )\n    takeProfit2.orderId = parent.orderId + 2\n    takeProfit2.parentId = parent.orderId\n    takeProfit2.transmit = False\n    \n    # Stop loss for full position\n    stopLoss = StopOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity,\n        sl_price\n    )\n    stopLoss.orderId = parent.orderId + 3\n    stopLoss.parentId = parent.orderId\n    stopLoss.transmit = True\n    \n    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)\n\n# Usage\nbracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)\nfor order in bracket:\n    ib.placeOrder(contract, order)",
          "language": "python",
          "context": "Scale out of positions by setting multiple take-profit levels:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 704,
          "heading": "Bracket with multiple profit targets",
          "tags": [
            "contract",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0074_62270345"
    },
    {
      "cluster_id": "cluster_0074",
      "examples": [
        {
          "id": "ex_0075_d96e77e8",
          "code": "contract = Forex('GBPUSD')\nib.qualifyContracts(contract)\n\n# Place entry order\nparent_order = MarketOrder('BUY', 25000)\ntrade = ib.placeOrder(contract, parent_order)\n\n# Wait for fill\nib.sleep(1)\nwhile trade.orderStatus.status != 'Filled':\n    ib.waitOnUpdate()\n\n# Calculate levels based on actual fill price\nfill_price = trade.orderStatus.avgFillPrice\nstop_loss_price = fill_price - 0.0015\ntake_profit_price = fill_price + 0.0020\n\n# Place child orders\nstop_loss_order = StopOrder('SELL', 25000, stop_loss_price)\ntake_profit_order = LimitOrder('SELL', 25000, take_profit_price)\n\nib.placeOrder(contract, stop_loss_order)\nib.placeOrder(contract, take_profit_order)",
          "language": "python",
          "context": "For strategies requiring exact profit/loss ratios based on actual fill price, place the entry order first, then calculate and submit bracket orders:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 763,
          "heading": "Dynamic bracket based on fill price",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0075_d96e77e8"
    },
    {
      "cluster_id": "cluster_0075",
      "examples": [
        {
          "id": "ex_0076_c4ff8d3a",
          "code": "# Trade object attributes\ntrade.order          # The original order\ntrade.orderStatus    # Current status object\ntrade.fills          # List of fills\ntrade.log            # Log of status changes\ntrade.isActive()     # Is order still active\ntrade.isDone()       # Is order complete\n\n# Order status values\n# PendingSubmit, PendingCancel, PreSubmitted, Submitted, \n# Filled, Cancelled, Inactive, ApiPending\n\n# Event callbacks for monitoring\ndef on_fill(trade, fill):\n    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')\n\ntrade.fillEvent += on_fill\n\ndef on_filled(trade):\n    total = sum(f.execution.shares for f in trade.fills)\n    avg_price = trade.orderStatus.avgFillPrice\n    print(f'Complete: {total} shares @ avg {avg_price}')\n\ntrade.filledEvent += on_filled\n\ndef on_status(trade):\n    print(f'Status: {trade.orderStatus.status}')\n\ntrade.statusEvent += on_status",
          "language": "python",
          "context": " Order status monitoring",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 791,
          "heading": "Order status monitoring",
          "tags": [
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0076_c4ff8d3a"
    },
    {
      "cluster_id": "cluster_0076",
      "examples": [
        {
          "id": "ex_0077_85f6c0d1",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Recommended method\ncontract = Future('ES', '202506', 'CME')\n\n# With additional parameters\ncontract = Future(\n    symbol='ES',\n    lastTradeDateOrContractMonth='202506',\n    exchange='CME',\n    localSymbol='ESM6',\n    multiplier='50',\n    currency='USD'\n)",
          "language": "python",
          "context": "The Future class provides the cleanest syntax for futures contracts:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 837,
          "heading": "Creating futures contracts",
          "tags": [
            "connect",
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0077_85f6c0d1"
    },
    {
      "cluster_id": "cluster_0077",
      "examples": [
        {
          "id": "ex_0078_1e17e8a5",
          "code": "contract = Contract()\ncontract.secType = 'FUT'\ncontract.symbol = 'MNQ'\ncontract.exchange = 'CME'\ncontract.currency = 'USD'\ncontract.localSymbol = 'MNQZ5'",
          "language": "python",
          "context": "The generic Contract class requires more verbose setup:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 859,
          "heading": "With additional parameters",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0078_1e17e8a5"
    },
    {
      "cluster_id": "cluster_0078",
      "examples": [
        {
          "id": "ex_0079_8c44b68b",
          "code": "contract = Contract(conId=495512516)",
          "language": "python",
          "context": "Using conId (contract identifier) provides the most precise identification when known:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 870,
          "heading": "With additional parameters",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0079_8c44b68b"
    },
    {
      "cluster_id": "cluster_0079",
      "examples": [
        {
          "id": "ex_0080_52d6cf6d",
          "code": "# Single contract\ncontract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\n# Multiple contracts concurrently\ncontracts = [\n    Future('ES', '202506', 'CME'),\n    Future('NQ', '202506', 'CME'),\n    Future('CL', '202506', 'NYMEX')\n]\nqualified = ib.qualifyContracts(*contracts)",
          "language": "python",
          "context": "Qualification sends a contract details request to IB servers, fills in missing fields (especially conId, localSymbol, multiplier, exact expiry date, tradingClass), and returns a list of successfully q...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 895,
          "heading": "The qualifyContracts method",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0080_52d6cf6d"
    },
    {
      "cluster_id": "cluster_0080",
      "examples": [
        {
          "id": "ex_0081_642b54b4",
          "code": "contract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\nif qualified:\n    contract = qualified[0]\n    print(f\"ConId: {contract.conId}\")\n    print(f\"Local Symbol: {contract.localSymbol}\")\n    print(f\"Expiry: {contract.lastTradeDateOrContractMonth}\")",
          "language": "python",
          "context": "The method updates the contract object in-place when successful:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 911,
          "heading": "Multiple contracts concurrently",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0081_642b54b4"
    },
    {
      "cluster_id": "cluster_0081",
      "examples": [
        {
          "id": "ex_0082_b5e51137",
          "code": "# Too vague - multiple matches\ncontract = Future('ES', exchange='CME')\nib.qualifyContracts(contract)\n# Warning: Ambiguous contract, possibles are [Future('ES', '202506'), ...]\n\n# Specific - unambiguous\ncontract = Future('ES', '202506', 'CME')\nib.qualifyContracts(contract)  # Success\n\n# Or use localSymbol\ncontract = Future('ES', exchange='CME', localSymbol='ESM6')\nib.qualifyContracts(contract)  # Success\n\n# Or use conId (most precise)\ncontract = Contract(conId=495512516)\nib.qualifyContracts(contract)  # Always unambiguous",
          "language": "python",
          "context": "When multiple contracts match your specification, qualifyContracts() logs a warning with possible matches. The solution: be more specific with contract details.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 926,
          "heading": "Handling ambiguous contracts",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0082_b5e51137"
    },
    {
      "cluster_id": "cluster_0082",
      "examples": [
        {
          "id": "ex_0083_62498bd6",
          "code": "def validate_futures_contract(ib, contract):\n    \"\"\"Validate and qualify a futures contract\"\"\"\n    try:\n        qualified = ib.qualifyContracts(contract)\n        if not qualified:\n            print(f\"ERROR: Contract could not be qualified\")\n            return None\n        \n        contract = qualified[0]\n        print(f\"\u2713 Qualified: {contract.localSymbol}\")\n        print(f\"  ConId: {contract.conId}\")\n        print(f\"  Expiry: {contract.lastTradeDateOrContractMonth}\")\n        return contract\n    except Exception as e:\n        print(f\"ERROR: {e}\")\n        return None\n\n# Usage\ncontract = Future('ES', '202506', 'CME')\nvalidated = validate_futures_contract(ib, contract)\nif validated:\n    order = MarketOrder('BUY', 1)\n    trade = ib.placeOrder(validated, order)",
          "language": "python",
          "context": "Always validate and handle qualification failures before placing orders:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 949,
          "heading": "Validation before trading",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0083_62498bd6"
    },
    {
      "cluster_id": "cluster_0083",
      "examples": [
        {
          "id": "ex_0084_7ced81f4",
          "code": "contract = Future('ES', '202506', 'CME')\ndetails_list = ib.reqContractDetails(contract)\n\nfor details in details_list:\n    print(f\"ConId: {details.contract.conId}\")\n    print(f\"Local Symbol: {details.contract.localSymbol}\")\n    print(f\"Expiry: {details.contract.lastTradeDateOrContractMonth}\")\n    print(f\"Multiplier: {details.contract.multiplier}\")\n    print(f\"Min Tick: {details.minTick}\")\n    print(f\"Market Name: {details.marketName}\")",
          "language": "python",
          "context": "Use reqContractDetails() to get comprehensive contract information beyond basic qualification:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 979,
          "heading": "Contract detail retrieval",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0084_7ced81f4"
    },
    {
      "cluster_id": "cluster_0084",
      "examples": [
        {
          "id": "ex_0085_ff9da4c6",
          "code": "# Request data for expired contract\ncontract = Future('ES', '202012', 'CME')\ncontract.includeExpired = True\n\nqualified = ib.qualifyContracts(contract)\nif qualified:\n    bars = ib.reqHistoricalData(\n        qualified[0],\n        endDateTime='',\n        durationStr='1 Y',\n        barSizeSetting='1 day',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    print(f\"Retrieved {len(bars)} bars\")",
          "language": "python",
          "context": "The includeExpired flag enables access to expired futures data for up to 2 years after expiration. This works only for historical data requests and contract details, not for real-time data or order pl...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 996,
          "heading": "Handling expired contracts",
          "tags": [
            "contract",
            "data",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0085_ff9da4c6"
    },
    {
      "cluster_id": "cluster_0085",
      "examples": [
        {
          "id": "ex_0086_5032bbea",
          "code": "from datetime import datetime\n\ndef get_front_month_contract(ib, symbol, exchange):\n    \"\"\"Get the front month futures contract\"\"\"\n    contract = Future(symbol, exchange=exchange)\n    contract_details = ib.reqContractDetails(contract)\n    \n    if not contract_details:\n        return None\n    \n    now = datetime.now()\n    active_contracts = []\n    \n    for details in contract_details:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(expiry_str, '%Y%m')\n        \n        if expiry > now:\n            active_contracts.append((expiry, details.contract))\n    \n    if not active_contracts:\n        return None\n    \n    # Sort and return front month\n    active_contracts.sort(key=lambda x: x[0])\n    front_month = active_contracts[0][1]\n    \n    qualified = ib.qualifyContracts(front_month)\n    return qualified[0] if qualified else None\n\n# Usage\nes_front = get_front_month_contract(ib, 'ES', 'CME')\nprint(f\"Front month: {es_front.localSymbol}\")",
          "language": "python",
          "context": "Implement automatic front month detection to handle contract rollovers:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1018,
          "heading": "Futures rollover strategies",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0086_5032bbea"
    },
    {
      "cluster_id": "cluster_0086",
      "examples": [
        {
          "id": "ex_0087_bdec6e72",
          "code": "def check_rollover_needed(contract, days_before=5):\n    \"\"\"Check if rollover needed\"\"\"\n    expiry_str = contract.lastTradeDateOrContractMonth\n    if len(expiry_str) == 8:\n        expiry = datetime.strptime(expiry_str, '%Y%m%d')\n    else:\n        expiry = datetime.strptime(expiry_str + '01', '%Y%m%d')\n    \n    days_to_expiry = (expiry - datetime.now()).days\n    return days_to_expiry <= days_before",
          "language": "python",
          "context": "Check if rollover is needed based on days to expiry:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1059,
          "heading": "Usage",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0087_bdec6e72"
    },
    {
      "cluster_id": "cluster_0087",
      "examples": [
        {
          "id": "ex_0088_0333ca26",
          "code": "# Continuous futures (historical data only)\ncont_future = ContFuture('ES', 'CME')\nib.qualifyContracts(cont_future)\n\nbars = ib.reqHistoricalData(\n    cont_future,\n    endDateTime='',\n    durationStr='2 Y',\n    barSizeSetting='1 day',\n    whatToShow='TRADES',\n    useRTH=True\n)",
          "language": "python",
          "context": "ContFuture provides rolled contract data for backtesting but has significant limitations:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1076,
          "heading": "Continuous futures limitations",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0088_0333ca26"
    },
    {
      "cluster_id": "cluster_0088",
      "examples": [
        {
          "id": "ex_0089_aa3f4ca5",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Subscribe to market data\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data to populate\nib.sleep(2)\n\n# Access real-time data\nprint(f\"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}\")",
          "language": "python",
          "context": "The most common method for real-time tick data, reqMktData() subscribes to continuous price updates for a contract:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1121,
          "heading": "Market data streaming with reqMktData",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0089_aa3f4ca5"
    },
    {
      "cluster_id": "cluster_0089",
      "examples": [
        {
          "id": "ex_0090_63eb797f",
          "code": "# Request time & sales data\nticker = ib.reqMktData(contract, '233', False, False)\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}\")",
          "language": "python",
          "context": "The genericTickList parameter requests specific data fields using tick IDs: 100 (options volume), 101 (options open interest), 106 (implied volatility), 165 (52-week high/low), 233 (time & sales with ...",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1142,
          "heading": "Access real-time data",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0090_63eb797f"
    },
    {
      "cluster_id": "cluster_0090",
      "examples": [
        {
          "id": "ex_0091_57100ddd",
          "code": "contract = Forex('EURUSD')\n\n# Request 5-second bars\nbars = ib.reqRealTimeBars(\n    contract,\n    5,              # Bar size (only 5 seconds supported)\n    'MIDPOINT',     # Can be TRADES, MIDPOINT, BID, or ASK\n    False           # useRTH\n)\n\n# Access bars list\nprint(bars[-1])  # Most recent bar",
          "language": "python",
          "context": "Provides 5-second aggregated bars, the only bar size supported by Interactive Brokers for real-time bar streaming:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1153,
          "heading": "Real-time bars with reqRealTimeBars",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0091_57100ddd"
    },
    {
      "cluster_id": "cluster_0091",
      "examples": [
        {
          "id": "ex_0092_27c9aee2",
          "code": "contract = Stock('TSLA', 'SMART', 'USD')\n\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    formatDate=1,\n    keepUpToDate=True  # Enables live updates\n)\n\n# Bars continue updating automatically",
          "language": "python",
          "context": "Historical bars with keepUpToDate=True continue updating in real-time after the initial historical data loads:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1172,
          "heading": "Streaming historical bars",
          "tags": [
            "contract",
            "data"
          ]
        },
        {
          "id": "ex_0244_39f6deda",
          "code": "bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    keepUpToDate=True  # \u2190 Keep updating\n)\n\n# bars.updateEvent fires on changes",
          "language": "python",
          "context": " Keep Historical Updated",
          "source_file": "ib_complete_reference.md",
          "line_number": 1006,
          "heading": "Keep Historical Updated",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 0.876750700280112,
      "canonical": "ex_0092_27c9aee2"
    },
    {
      "cluster_id": "cluster_0092",
      "examples": [
        {
          "id": "ex_0093_43b2c4bd",
          "code": "contract = Forex('EURUSD')\n\nticker = ib.reqTickByTickData(\n    contract,\n    'BidAsk',  # Can be Last, AllLast, BidAsk, or MidPoint\n    0,         # numberOfTicks (0 = unlimited)\n    False      # ignoreSize\n)\n\n# Access tick-by-tick data\nprint(ticker.tickByTicks)",
          "language": "python",
          "context": "The most granular data stream, providing every individual tick from the exchange. Limited to 3 simultaneous subscriptions per client:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1193,
          "heading": "Tick-by-tick data",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0093_43b2c4bd"
    },
    {
      "cluster_id": "cluster_0093",
      "examples": [
        {
          "id": "ex_0094_b590c4c9",
          "code": "contract = Forex('EURUSD')\n\nticker = ib.reqMktDepth(contract)\nib.sleep(2)\n\n# Access order book\nprint(\"Bids:\", [(d.price, d.size) for d in ticker.domBids[:5]])\nprint(\"Asks:\", [(d.price, d.size) for d in ticker.domAsks[:5]])",
          "language": "python",
          "context": "Order book (Level II) data showing bid and ask depth. Requires Level II market data subscription:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1211,
          "heading": "Market depth streaming",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0094_b590c4c9"
    },
    {
      "cluster_id": "cluster_0094",
      "examples": [
        {
          "id": "ex_0095_c4cd43da",
          "code": "def onTickerUpdate(ticker):\n    print(f\"{ticker.contract.symbol}: Last {ticker.last}\")\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTickerUpdate\n\nib.run()",
          "language": "python",
          "context": "Individual ticker events for ticker-specific logic:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1228,
          "heading": "Event-driven data processing",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0095_c4cd43da"
    },
    {
      "cluster_id": "cluster_0095",
      "examples": [
        {
          "id": "ex_0096_ed4bca13",
          "code": "contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\ndef onPendingTickers(tickers):\n    \"\"\"Called when any subscribed ticker has new data\"\"\"\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.last}\")\n\nib.pendingTickersEvent += onPendingTickers\nib.run()",
          "language": "python",
          "context": "Global pendingTickersEvent for monitoring multiple tickers efficiently:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1241,
          "heading": "Event-driven data processing",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0096_ed4bca13"
    },
    {
      "cluster_id": "cluster_0096",
      "examples": [
        {
          "id": "ex_0097_3e1b5da3",
          "code": "def onBarUpdate(bars, hasNewBar):\n    \"\"\"\n    bars: BarDataList containing all bars\n    hasNewBar: Boolean indicating if a new bar was added\n    \"\"\"\n    if hasNewBar:\n        latest = bars[-1]\n        print(f\"New bar: O={latest.open}, H={latest.high}, \"\n              f\"L={latest.low}, C={latest.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += onBarUpdate\nib.run()",
          "language": "python",
          "context": "Bar update events for streaming bar data:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1262,
          "heading": "Event-driven data processing",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0097_3e1b5da3"
    },
    {
      "cluster_id": "cluster_0097",
      "examples": [
        {
          "id": "ex_0098_3c54380f",
          "code": "import pandas as pd\n\ncontracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\n# Create DataFrame\ndf = pd.DataFrame(\n    index=[c.pair() for c in contracts],\n    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']\n)\n\ndef onPendingTickers(tickers):\n    for t in tickers:\n        df.loc[t.contract.pair()] = (\n            t.bidSize, t.bid, t.ask, t.askSize, \n            t.high, t.low, t.close\n        )\n    print(df)\n\nib.pendingTickersEvent += onPendingTickers\nib.sleep(30)",
          "language": "python",
          "context": "Combine ibinsync with pandas for structured data handling:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1282,
          "heading": "Processing multiple tickers with pandas",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0098_3c54380f"
    },
    {
      "cluster_id": "cluster_0098",
      "examples": [
        {
          "id": "ex_0099_24d7046c",
          "code": "# WRONG - blocks everything\nimport time\n\ndef onTickerUpdate(ticker):\n    time.sleep(5)  # Frozen!\n    process(ticker)\n\n# CORRECT - yields control\ndef onTickerUpdate(ticker):\n    ib.sleep(0)  # Yields to allow message processing\n    process(ticker)",
          "language": "python",
          "context": "Never use time.sleep() in callbacks or main code\u2014it freezes the event loop and prevents message processing. Always use ib.sleep() to yield control.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1311,
          "heading": "The critical rule: never block the event loop",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0099_24d7046c"
    },
    {
      "cluster_id": "cluster_0099",
      "examples": [
        {
          "id": "ex_0100_bd27cf80",
          "code": "def onTickerUpdate(ticker):\n    for i in range(1000):\n        process_chunk(i)\n        if i % 100 == 0:\n            ib.sleep(0)  # Yield every 100 iterations",
          "language": "python",
          "context": "For long-running operations, yield control periodically:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1327,
          "heading": "CORRECT - yields control",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0100_bd27cf80"
    },
    {
      "cluster_id": "cluster_0100",
      "examples": [
        {
          "id": "ex_0101_46f5524b",
          "code": "for contract in large_contract_list:\n    ticker = ib.reqMktData(contract)\n    ib.sleep(0.02)  # Small delay between requests",
          "language": "python",
          "context": "ibinsync automatically throttles requests to 45 requests per second, compatible with TWS/Gateway 974+. No manual intervention needed for individual requests, but spread out batch operations:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1339,
          "heading": "Request throttling and memory management",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0101_46f5524b"
    },
    {
      "cluster_id": "cluster_0101",
      "examples": [
        {
          "id": "ex_0102_2681b27b",
          "code": "active_subscriptions = set()\nMAX_SUBSCRIPTIONS = 95  # Leave margin\n\ndef subscribe_with_limit(contract):\n    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:\n        # Unsubscribe oldest\n        oldest = active_subscriptions.pop()\n        ib.cancelMktData(oldest)\n    \n    ticker = ib.reqMktData(contract)\n    active_subscriptions.add(contract)\n    return ticker",
          "language": "python",
          "context": "Interactive Brokers limits concurrent subscriptions: typically 100 for market data lines, only 3 for tick-by-tick data.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1351,
          "heading": "Managing subscription limits",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0102_2681b27b"
    },
    {
      "cluster_id": "cluster_0102",
      "examples": [
        {
          "id": "ex_0103_922900ca",
          "code": "class TickerManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.contracts = {}\n        \n    def subscribe(self, symbol, exchange='SMART', currency='USD'):\n        contract = Stock(symbol, exchange, currency)\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract)\n        ticker.updateEvent += self.onUpdate\n        \n        self.tickers[symbol] = ticker\n        self.contracts[symbol] = contract\n        return ticker\n    \n    def unsubscribe(self, symbol):\n        if symbol in self.tickers:\n            self.ib.cancelMktData(self.contracts[symbol])\n            del self.tickers[symbol]\n            del self.contracts[symbol]\n    \n    def onUpdate(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n\n# Usage\nmanager = TickerManager(ib)\nmanager.subscribe('AAPL')\nmanager.subscribe('GOOGL')",
          "language": "python",
          "context": "Encapsulate subscription management in a reusable class:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1370,
          "heading": "Ticker manager pattern",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0103_922900ca"
    },
    {
      "cluster_id": "cluster_0103",
      "examples": [
        {
          "id": "ex_0104_14f4249a",
          "code": "# WRONG\ncontract1 = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract1)\n\ncontract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!\nib.cancelMktData(contract2)  # Won't work\n\n# CORRECT\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nib.cancelMktData(contract)  # Use same object",
          "language": "python",
          "context": "Critical: Use the same contract object for cancellation that you used for subscription. Creating a new identical contract won't work\u2014object identity matters.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1408,
          "heading": "Properly unsubscribing and cleanup",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0104_14f4249a"
    },
    {
      "cluster_id": "cluster_0104",
      "examples": [
        {
          "id": "ex_0105_d552e908",
          "code": "ib.cancelMktData(contract)\nib.cancelRealTimeBars(bars)\nib.cancelHistoricalData(bars)\nib.cancelTickByTickData(contract, 'BidAsk')\nib.cancelMktDepth(contract)",
          "language": "python",
          "context": "Cancel different data types with specific methods:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1424,
          "heading": "CORRECT",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0105_d552e908"
    },
    {
      "cluster_id": "cluster_0105",
      "examples": [
        {
          "id": "ex_0106_f97028f9",
          "code": "ticker.updateEvent += handler\n# Later...\nticker.updateEvent -= handler\nib.cancelMktData(contract)",
          "language": "python",
          "context": "Remove event handlers before unsubscribing to prevent memory leaks:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1434,
          "heading": "CORRECT",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0106_f97028f9"
    },
    {
      "cluster_id": "cluster_0106",
      "examples": [
        {
          "id": "ex_0107_7cda9f41",
          "code": "def shutdown():\n    # Cancel all subscriptions\n    for contract in active_contracts:\n        ib.cancelMktData(contract)\n    \n    # Allow cancellations to process\n    ib.sleep(1)\n    \n    # Disconnect\n    ib.disconnect()\n\ntry:\n    ib.run()\nfinally:\n    shutdown()",
          "language": "python",
          "context": "Proper shutdown procedure:",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1443,
          "heading": "Later...",
          "tags": [
            "connect",
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0107_7cda9f41"
    },
    {
      "cluster_id": "cluster_0107",
      "examples": [
        {
          "id": "ex_0108_aa9a9920",
          "code": "# WRONG - ticks cleared before checking\nticker = ib.reqMktData(contract)\nib.sleep(5)\nprint(ticker.ticks)  # Likely empty\n\n# CORRECT - process in event\ndef onUpdate(ticker):\n    for tick in ticker.ticks:\n        process_tick(tick)\n\nticker.updateEvent += onUpdate",
          "language": "python",
          "context": "Not processing ticks immediately: The ticker.ticks list is automatically cleared after each update\u2014process ticks in event handlers when they arrive.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1469,
          "heading": "Common mistakes causing data loss",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0108_aa9a9920"
    },
    {
      "cluster_id": "cluster_0108",
      "examples": [
        {
          "id": "ex_0109_76fc649a",
          "code": "def onBarUpdate(bars, hasNewBar):\n    if len(bars) > 1000:\n        # Keep only last 1000 bars\n        del bars[:len(bars)-1000]",
          "language": "python",
          "context": "Accumulating historical bars: When using keepUpToDate=True, limit buffer size to prevent unbounded memory growth.",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1485,
          "heading": "CORRECT - process in event",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0109_76fc649a"
    },
    {
      "cluster_id": "cluster_0109",
      "examples": [
        {
          "id": "ex_0110_385aac72",
          "code": "from ib_insync import *\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nclass TradingSystem:\n    def __init__(self):\n        self.ib = IB()\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def connect(self):\n        self.ib.connect('127.0.0.1', 7497, clientId=1)\n        self.ib.errorEvent += self.onError\n        self.ib.pendingTickersEvent += self.onPendingTickers\n        \n    def subscribe(self, symbol):\n        contract = Stock(symbol, 'SMART', 'USD')\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract, '', False, False)\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n    def onPendingTickers(self, tickers):\n        for ticker in tickers:\n            self.process_ticker(ticker)\n            \n    def process_ticker(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n        \n        # Always yield control in callbacks\n        self.ib.sleep(0)\n        \n    def onError(self, reqId, errorCode, errorString, contract):\n        logging.error(f\"Error {errorCode}: {errorString}\")\n        \n    def shutdown(self):\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n        self.ib.sleep(1)\n        self.ib.disconnect()\n        \n    def run(self):\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            print(\"Shutting down...\")\n        finally:\n            self.shutdown()\n\n# Usage\nif __name__ == '__main__':\n    system = TradingSystem()\n    system.connect()\n    system.subscribe('AAPL')\n    system.subscribe('GOOGL')\n    system.run()",
          "language": "python",
          "context": " Production-ready streaming system",
          "source_file": "ib_insync_complete_guide.md",
          "line_number": 1496,
          "heading": "Production-ready streaming system",
          "tags": [
            "connect",
            "contract",
            "data",
            "error",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0110_385aac72"
    },
    {
      "cluster_id": "cluster_0110",
      "examples": [
        {
          "id": "ex_0111_6bf39739",
          "code": "from ib_insync import *\n\n# Connect to IB\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Correct approach for E-mini S&P 500 futures\nes_contract = Future(symbol='ES', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Micro E-mini Nasdaq-100 futures\nmnq_contract = Future(symbol='MNQ', lastTradeDateOrContractMonth='202506', exchange='CME')\n\n# Correct approach for Crude Oil futures\ncl_contract = Future(symbol='CL', lastTradeDateOrContractMonth='202506', exchange='NYMEX')\n\n# Qualify the contracts\nqualified_contracts = ib.qualifyContracts(es_contract, mnq_contract, cl_contract)",
          "language": "python",
          "context": "When working with futures contracts in ibinsync, accurate exchange specification is critical. Here's the current correct approach:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 7,
          "heading": "Accurate Futures Contract Qualification",
          "tags": [
            "connect",
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0111_6bf39739"
    },
    {
      "cluster_id": "cluster_0111",
      "examples": [
        {
          "id": "ex_0112_0d08872d",
          "code": "def get_qualified_futures_contract(ib, symbol, expiry, exchange):\n    \"\"\"Get a fully qualified futures contract ready for trading\"\"\"\n    contract = Future(symbol=symbol, \n                     lastTradeDateOrContractMonth=expiry,\n                     exchange=exchange)\n    \n    # Request complete contract details\n    qualified = ib.qualifyContracts(contract)\n    \n    if not qualified:\n        print(f\"ERROR: Could not qualify {symbol} contract\")\n        return None\n        \n    # Return the fully qualified contract\n    return qualified[0]\n\n# Example usage\nes_contract = get_qualified_futures_contract(ib, 'ES', '202506', 'CME')\nprint(f\"ConId: {es_contract.conId}, LocalSymbol: {es_contract.localSymbol}\")",
          "language": "python",
          "context": "For real-time futures trading, always fully qualify your contracts to ensure proper execution:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 40,
          "heading": "Single Source of Truth for Contract Specifications",
          "tags": [
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0112_0d08872d"
    },
    {
      "cluster_id": "cluster_0112",
      "examples": [
        {
          "id": "ex_0113_777eef12",
          "code": "def get_contract_by_symbol(ib, local_symbol):\n    \"\"\"Get contract using local symbol (e.g., 'ESM6')\"\"\"\n    # Parse the local symbol\n    root = ''.join([c for c in local_symbol if c.isalpha()])\n    suffix = ''.join([c for c in local_symbol if not c.isalpha()])\n    \n    # Extract month code and year\n    month_code = suffix[0] if len(suffix) > 0 else ''\n    year_code = suffix[1:] if len(suffix) > 1 else ''\n    \n    # Create generic contract\n    contract = Contract()\n    contract.secType = 'FUT'\n    contract.symbol = root\n    contract.exchange = get_exchange_for_symbol(root)  # Helper function\n    contract.localSymbol = local_symbol\n    \n    # Qualify the contract\n    qualified = ib.qualifyContracts(contract)\n    return qualified[0] if qualified else None\n\ndef get_exchange_for_symbol(symbol):\n    \"\"\"Get correct exchange for common futures symbols\"\"\"\n    exchanges = {\n        'ES': 'CME', 'MES': 'CME', 'NQ': 'CME', 'MNQ': 'CME',\n        'RTY': 'CME', 'M2K': 'CME', 'YM': 'CBOT', 'MYM': 'CBOT',\n        'CL': 'NYMEX', 'GC': 'NYMEX', 'SI': 'NYMEX', 'HG': 'NYMEX',\n        'ZB': 'CBOT', 'ZN': 'CBOT', 'ZF': 'CBOT', 'ZT': 'CBOT',\n        '6E': 'CME', '6A': 'CME', '6B': 'CME', '6J': 'CME'\n    }\n    return exchanges.get(symbol, 'SMART')",
          "language": "python",
          "context": "| Month | Code | Example |\n|-------|------|---------|\n| January | F | ESF6 (ES Jan 2026) |\n| February | G | ESG6 (ES Feb 2026) |\n| March | H | ESH6 (ES Mar 2026) |\n| April | J | ESJ6 (ES Apr 2026) |\n|...",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 81,
          "heading": "Handling Contract Month Codes",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0113_777eef12"
    },
    {
      "cluster_id": "cluster_0113",
      "examples": [
        {
          "id": "ex_0114_dcf476f2",
          "code": "# Trailing stop for ES futures\ndef place_es_trailing_stop(ib, action, quantity, trail_amount):\n    \"\"\"Place a trailing stop order for ES futures\"\"\"\n    # Get current front month ES contract\n    es = get_front_month_contract(ib, 'ES', 'CME')\n    \n    # Create trailing stop order\n    order = Order()\n    order.action = action  # 'BUY' or 'SELL'\n    order.orderType = 'TRAIL'\n    order.totalQuantity = quantity\n    order.auxPrice = trail_amount  # Trail amount in points\n    \n    # Place the order\n    trade = ib.placeOrder(es, order)\n    return trade\n\n# Market-Limit OCO for MNQ futures\ndef place_mnq_market_limit_oco(ib, action, quantity, limit_price):\n    \"\"\"Place a market-limit OCO order for MNQ futures\"\"\"\n    # Get current front month MNQ contract\n    mnq = get_front_month_contract(ib, 'MNQ', 'CME')\n    \n    # Create OCO orders\n    market_order = MarketOrder(action, quantity)\n    limit_order = LimitOrder(action, quantity, limit_price)\n    \n    # Set up OCO group\n    oca_group = f\"MNQ_OCO_{int(time.time())}\"  # Unique group ID\n    \n    market_order.ocaGroup = oca_group\n    market_order.ocaType = 2  # Proportional\n    \n    limit_order.ocaGroup = oca_group\n    limit_order.ocaType = 2\n    \n    # Place orders\n    trade1 = ib.placeOrder(mnq, market_order)\n    trade2 = ib.placeOrder(mnq, limit_order)\n    \n    return [trade1, trade2]",
          "language": "python",
          "context": "For futures trading, complex order types like OCO and trailing stops require careful setup:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 119,
          "heading": "Complex Order Types for Futures",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0114_dcf476f2"
    },
    {
      "cluster_id": "cluster_0114",
      "examples": [
        {
          "id": "ex_0115_e6c51488",
          "code": "class FuturesDataManager:\n    \"\"\"Manage real-time data for multiple futures contracts\"\"\"\n    \n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def subscribe(self, symbol, exchange='CME'):\n        \"\"\"Subscribe to real-time market data for a futures contract\"\"\"\n        # Get front month contract\n        contract = get_front_month_contract(self.ib, symbol, exchange)\n        \n        if not contract:\n            print(f\"Error: Could not find front month contract for {symbol}\")\n            return None\n            \n        # Request market data\n        ticker = self.ib.reqMktData(contract, '', False, False)\n        \n        # Store references\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n        return ticker\n        \n    def get_price(self, symbol):\n        \"\"\"Get current price for a subscribed symbol\"\"\"\n        if symbol not in self.tickers:\n            return None\n            \n        ticker = self.tickers[symbol]\n        \n        # Use last or midpoint price\n        if ticker.last:\n            return ticker.last\n        elif ticker.bid and ticker.ask:\n            return (ticker.bid + ticker.ask) / 2\n        else:\n            return None\n    \n    def get_contracts_expiring_soon(self, days_threshold=10):\n        \"\"\"Get list of contracts expiring soon\"\"\"\n        expiring_soon = []\n        now = datetime.now()\n        \n        for contract in self.active_contracts:\n            expiry_str = contract.lastTradeDateOrContractMonth\n            \n            if len(expiry_str) == 8:  # YYYYMMDD format\n                expiry = datetime.strptime(expiry_str, '%Y%m%d')\n            else:  # YYYYMM format\n                expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n                \n            days_to_expiry = (expiry - now).days\n            \n            if days_to_expiry <= days_threshold:\n                expiring_soon.append((contract, days_to_expiry))\n                \n        return expiring_soon\n        \n    def cleanup(self):\n        \"\"\"Unsubscribe from all market data\"\"\"\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n            \n        self.tickers.clear()\n        self.active_contracts.clear()",
          "language": "python",
          "context": "For live futures data, proper subscription management is essential:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 167,
          "heading": "Efficient Futures Data Streaming",
          "tags": [
            "contract",
            "data",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0115_e6c51488"
    },
    {
      "cluster_id": "cluster_0115",
      "examples": [
        {
          "id": "ex_0116_d1d3b777",
          "code": "def get_continuous_futures_data(ib, symbol, exchange, duration='1 Y', bar_size='1 day'):\n    \"\"\"Get historical data for continuous futures contract\"\"\"\n    # Create a ContFuture for historical data\n    contract = ContFuture(symbol, exchange)\n    ib.qualifyContracts(contract)\n    \n    # Request historical data\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=bar_size,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    \n    return bars\n\n# Get front month based on volume/open interest\ndef get_most_liquid_contract(ib, symbol, exchange):\n    \"\"\"Get the most liquid contract based on volume and open interest\"\"\"\n    # Get all active contracts for this symbol\n    contract = Future(symbol, exchange=exchange)\n    details_list = ib.reqContractDetails(contract)\n    \n    if not details_list:\n        return None\n    \n    # Filter out expired contracts\n    now = datetime.now()\n    active_contracts = []\n    \n    for details in details_list:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        \n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(f\"{expiry_str}01\", '%Y%m%d')\n            \n        if expiry > now:\n            active_contracts.append(details.contract)\n    \n    if not active_contracts:\n        return None\n    \n    # Get volume data for each contract\n    contract_data = []\n    \n    for contract in active_contracts:\n        ticker = ib.reqMktData(contract, '100,101', False, False)  # Request volume and OI\n        ib.sleep(1)  # Allow data to populate\n        \n        contract_data.append({\n            'contract': contract,\n            'volume': ticker.volume or 0,\n            'openInterest': ticker.openInterest or 0\n        })\n        \n        # Cancel the market data request\n        ib.cancelMktData(contract)\n    \n    # Sort by combined volume and open interest\n    contract_data.sort(key=lambda x: x['volume'] + x['openInterest'], reverse=True)\n    \n    # Return the most liquid contract\n    return contract_data[0]['contract'] if contract_data else None",
          "language": "python",
          "context": "For continuous futures analysis, use a combination of reqHistoricalData and dynamic front-month tracking:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 242,
          "heading": "Working with Continuous Futures Contracts",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0116_d1d3b777"
    },
    {
      "cluster_id": "cluster_0116",
      "examples": [
        {
          "id": "ex_0117_03a78138",
          "code": "class FuturesTradingSystem:\n    \"\"\"Complete futures trading system with proper state management\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        \n        self.active_contracts = {}  # symbol -> contract\n        self.active_orders = {}     # orderId -> order\n        self.active_positions = {}  # symbol -> position\n        \n        # Setup logger\n        self.logger = self._setup_logger()\n        \n    def _setup_logger(self):\n        logger = logging.getLogger('FuturesTradingSystem')\n        logger.setLevel(logging.INFO)\n        \n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        \n        return logger\n        \n    def connect(self):\n        \"\"\"Connect to IB and initialize state\"\"\"\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(f\"Connected to IB ({self.host}:{self.port})\")\n            \n            # Setup event handlers\n            self.ib.errorEvent += self._handle_error\n            self.ib.positionEvent += self._handle_position\n            self.ib.orderStatusEvent += self._handle_order_status\n            \n            # Initialize positions\n            self._update_positions()\n            \n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _update_positions(self):\n        \"\"\"Update current positions\"\"\"\n        positions = self.ib.positions()\n        \n        for position in positions:\n            if position.contract.secType == 'FUT':\n                symbol = position.contract.symbol\n                self.active_positions[symbol] = position\n                self.logger.info(f\"Current position: {symbol}: {position.position}\")\n    \n    def _handle_position(self, position):\n        \"\"\"Handle position updates\"\"\"\n        if position.contract.secType == 'FUT':\n            symbol = position.contract.symbol\n            self.active_positions[symbol] = position\n            self.logger.info(f\"Position update: {symbol}: {position.position}\")\n    \n    def _handle_order_status(self, trade):\n        \"\"\"Handle order status updates\"\"\"\n        orderId = trade.order.orderId\n        status = trade.orderStatus.status\n        \n        self.logger.info(f\"Order {orderId} status: {status}\")\n        \n        # Store active orders\n        if status in ['Submitted', 'PreSubmitted', 'PendingSubmit']:\n            self.active_orders[orderId] = trade\n        # Remove completed orders\n        elif status in ['Filled', 'Cancelled', 'Inactive']:\n            if orderId in self.active_orders:\n                del self.active_orders[orderId]\n    \n    def _handle_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle error events\"\"\"\n        self.logger.error(f\"Error {errorCode}: {errorString}\")\n        \n        # Handle connection issues\n        if errorCode in [1100, 1101, 1102]:\n            self.logger.critical(\"Connection issue detected!\")\n    \n    def get_contract(self, symbol, expiry, exchange):\n        \"\"\"Get a fully qualified futures contract\"\"\"\n        contract_key = f\"{symbol}_{expiry}_{exchange}\"\n        \n        # Use cached contract if available\n        if contract_key in self.active_contracts:\n            return self.active_contracts[contract_key]\n            \n        # Otherwise qualify a new one\n        contract = Future(symbol=symbol, \n                         lastTradeDateOrContractMonth=expiry,\n                         exchange=exchange)\n        \n        qualified = self.ib.qualifyContracts(contract)\n        \n        if not qualified:\n            self.logger.error(f\"Failed to qualify contract: {symbol} {expiry}\")\n            return None\n            \n        qualified_contract = qualified[0]\n        self.active_contracts[contract_key] = qualified_contract\n        \n        return qualified_contract\n    \n    def place_market_order(self, symbol, expiry, exchange, action, quantity):\n        \"\"\"Place market order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = MarketOrder(action, quantity)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} market order for {quantity} {symbol}\")\n        return trade\n    \n    def place_limit_order(self, symbol, expiry, exchange, action, quantity, price):\n        \"\"\"Place limit order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        order = LimitOrder(action, quantity, price)\n        trade = self.ib.placeOrder(contract, order)\n        \n        self.logger.info(f\"Placed {action} limit order for {quantity} {symbol} @ {price}\")\n        return trade\n    \n    def place_bracket_order(self, symbol, expiry, exchange, action, quantity, \n                          entry_price, profit_price, stop_price):\n        \"\"\"Place bracket order for futures contract\"\"\"\n        contract = self.get_contract(symbol, expiry, exchange)\n        \n        if not contract:\n            return None\n            \n        # Create bracket orders\n        bracket = self.ib.bracketOrder(\n            action,\n            quantity,\n            entry_price,\n            profit_price,\n            stop_price\n        )\n        \n        # Place all orders\n        trades = []\n        for order in bracket:\n            trade = self.ib.placeOrder(contract, order)\n            trades.append(trade)\n        \n        self.logger.info(f\"Placed bracket order for {quantity} {symbol}\")\n        return trades\n    \n    def cancel_all_orders(self):\n        \"\"\"Cancel all open orders\"\"\"\n        open_trades = self.ib.openTrades()\n        for trade in open_trades:\n            if not trade.isDone():\n                self.ib.cancelOrder(trade.order)\n                self.logger.info(f\"Cancelled order {trade.order.orderId}\")\n    \n    def get_position(self, symbol):\n        \"\"\"Get current position for symbol\"\"\"\n        return self.active_positions.get(symbol)\n    \n    def close_position(self, symbol):\n        \"\"\"Close position for symbol\"\"\"\n        position = self.get_position(symbol)\n        \n        if not position or position.position == 0:\n            self.logger.info(f\"No position to close for {symbol}\")\n            return None\n        \n        # Create closing order\n        action = 'SELL' if position.position > 0 else 'BUY'\n        quantity = abs(position.position)\n        \n        return self.place_market_order(\n            symbol,\n            position.contract.lastTradeDateOrContractMonth,\n            position.contract.exchange,\n            action,\n            quantity\n        )\n    \n    def run(self):\n        \"\"\"Run the system indefinitely\"\"\"\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            self.logger.info(\"Shutting down...\")\n        finally:\n            # Cleanup on exit\n            self.cancel_all_orders()\n            self.ib.disconnect()\n            self.logger.info(\"Disconnected from IB\")",
          "language": "python",
          "context": "Here's a more comprehensive structure for a futures trading system:",
          "source_file": "ib_insync_futures_update.md",
          "line_number": 316,
          "heading": "Production-Ready Futures Trading System",
          "tags": [
            "connect",
            "contract",
            "error",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0117_03a78138"
    },
    {
      "cluster_id": "cluster_0117",
      "examples": [
        {
          "id": "ex_0118_9050e9e9",
          "code": "pip install ib_insync\n\n\nfrom ib_insync import *\n# util.startLoop() # uncomment this line when in a notebook\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\ncontract, endDateTime='', durationStr='30 D',\nbarSizeSetting='1 hour', whatToShow='MIDPOINT', useRTH=True)\n\n# convert to pandas dataframe:\ndf = util.df(bars)\nprint(df)",
          "language": "python",
          "context": " Code Examples\n- Fetching consecutive historical data\n- Async streaming ticks\n- Scanner data (blocking)\n- Scanner data (streaming)\n- Option calculations\n- Order book\n- Minimum price increments\n- News ...",
          "source_file": "pdf_extract.md",
          "line_number": 33,
          "heading": "Code Examples",
          "tags": [
            "async",
            "connect",
            "contract",
            "data",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0118_9050e9e9"
    },
    {
      "cluster_id": "cluster_0118",
      "examples": [
        {
          "id": "ex_0119_672d75df",
          "code": "events = ('connectedEvent', 'disconnectedEvent', 'updateEvent',\n          'pendingTickersEvent', 'barUpdateEvent', 'newOrderEvent', 'orderModifyEvent',\n          'cancelOrderEvent', 'openOrderEvent', 'orderStatusEvent', 'execDetailsEvent',\n          'commissionReportEvent', 'updatePortfolioEvent', 'positionEvent',\n          'accountValueEvent', 'accountSummaryEvent', 'pnlEvent', 'pnlSingleEvent',\n          'scannerDataEvent', 'tickNewsEvent', 'newsBulletinEvent', 'errorEvent',\n          'timeoutEvent')\n\nRequestTimeout: float = 0\nRaiseRequestErrors: bool = False\nMaxSyncedSubAccounts: int = 50\nTimezoneTWS = None\n\n#### connect(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\nConnect to a running TWS or IB gateway application. After the connection is made the client is fully synchronized and ready to serve requests.\n**This method is blocking.**\n**Parameters:**\n- **host** (str) - Host name or IP address.\n- **port** (int) - Port number.\n- **clientId** (int) - ID number to use for this client; must be unique per connection. Setting clientId=0 will automatically merge manual TWS trading with this client.\n- **timeout** (float) - If establishing the connection takes longer than timeout seconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n- **readonly** (bool) - Set to True when API is in read-only mode.\n- **account** (str) - Main account to receive updates for.\n- \n#### disconnect()\nDisconnect from a TWS or IB gateway application. This will clear all session state.\n\n#### isConnected()\nIs there an API connection to TWS or IB gateway?\n**Return type:** bool\n\n#### static run(*, timeout=None)\nBy default run the event loop forever.\nWhen awaitables (like Tasks, Futures or coroutines) are given then run the event loop until each has completed and return their results.\nAn optional timeout (in seconds) can be given that will raise asyncio.TimeoutError if the awaitables are not ready within the timeout period.\n\n#### static schedule(callback, *args)\nSchedule the callback to be run at the given time with the given arguments. This will return the Event Handle.\n**Parameters:**\n- **time** (Union[time, datetime]) - Time to run callback. If given as datetime.time then use today as date.\n- **callback** (Callable) - Callable scheduled to run.\n- **args** - Arguments for to call callback with.\n\n#### static sleep()\nWait for the given amount of seconds while everything still keeps processing in the background. Never use `time.sleep()`.\n**Parameters:**\n- **secs** (float) - Time in seconds to wait.\n**Return type:** bool\n\n#### static timeRange(end, step)\nIterator that waits periodically until certain time points are reached while yielding those time points.\n**Parameters:**\n- **start** (Union[time, datetime]) - Start time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **end** (Union[time, datetime]) - End time, can be specified as datetime.datetime, or as datetime.time in which case today is used as the date\n- **step** (float) - The number of seconds of each period\n**Return type:** Iterator[datetime]\n\n#### static timeRangeAsync(end, step)\nAsync version of timeRange().\n**Return type:** AsyncIterator[datetime]\n\n#### static waitUntil()\nWait until the given time t is reached.\n**Parameters:**\n- **t** (Union[time, datetime]) - The time t can be specified as datetime.datetime, or as datetime.time in which case today is used as the date.\n**Return type:** bool\n\n#### waitOnUpdate(timeout=0)\nWait on any new update to arrive from the network.\n**Parameters:**\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used\n**Note:** A loop with waitOnUpdate should not be used to harvest tick data from tickers, since some ticks can go missing. This happens when multiple updates occur almost simultaneously; The ticks from the first update are then cleared. Use events instead to prevent this.\n**Return type:** bool\n**Returns:** True if not timed-out, False otherwise.\n\n#### loopUntil(condition=None, timeout=0)\nIterate until condition is met, with optional timeout in seconds. The yielded value is that of the condition or False when timed out.\n**Parameters:**\n- **condition** - Predicate function that is tested after every network update.\n- **timeout** (float) - Maximum time in seconds to wait. If 0 then no timeout is used.\n**Return type:** Iterator[object]\n\n#### setTimeout(timeout=60)\nSet a timeout for receiving messages from TWS/IBG, emitting timeoutEvent if there is no incoming data for too long.\nThe timeout fires once per connected session but can be set again after firing or after a reconnect.\n**Parameters:**\n- **timeout** (float) - Timeout in seconds.\n\n#### managedAccounts()\nList of account names.\n**Return type:** List[str]\n\n#### accountValues(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### accountSummary(account='')\nList of account values for the given account, or of all accounts if account is left blank.\n**This method is blocking on first run, non-blocking after that.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[AccountValue]\n\n#### portfolio()\nList of portfolio items of the default account.\n**Return type:** List[PortfolioItem]\n\n#### positions(account='')\nList of positions for the given account, or of all accounts if account is left blank.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n**Return type:** List[Position]\n\n#### pnl(account='', modelCode='')\nList of subscribed PnL objects (profit and loss), optionally filtered by account and/or modelCode. The PnL objects are kept live updated.\n**Parameters:**\n- **account** - If specified, filter for this account name.\n- **modelCode** - If specified, filter for this account model.\n**Return type:** List[PnL]\n\n#### pnlSingle(account='', modelCode='', conId=0)\nList of subscribed PnLSingle objects (profit and loss for single positions). The PnLSingle objects are kept live updated.\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n- **conId** (int) - If specified, filter for this contract ID.\n**Return type:** List[PnLSingle]\n\n#### trades()\nList of all order trades from this session.\n**Return type:** List[Trade]\n\n#### openTrades()\nList of all open order trades.\n**Return type:** List[Trade]\n\n#### orders()\nList of all orders from this session.\n**Return type:** List[Order]\n\n#### openOrders()\nList of all open orders.\n**Return type:** List[Order]\n\n#### fills()\nList of all fills from this session.\n**Return type:** List[Fill]\n\n#### executions()\nList of all executions from this session.\n**Return type:** List[Execution]\n\n#### ticker(contract)\nGet ticker of the given contract. It must have been requested before with reqMktData with the same contract object. The ticker may not be ready yet if called directly after reqMktData().\n**Parameters:**\n- **contract** (Contract) - Contract to get ticker for.\n**Return type:** Ticker\n\n#### tickers()\nGet a list of all tickers.\n**Return type:** List[Ticker]\n\n#### pendingTickers()\nGet a list of all tickers that have pending ticks or domTicks.\n**Return type:** List[Ticker]\n\n#### realtimeBars()\nGet a list of all live updated bars. These can be 5 second realtime bars or live updated historical bars.\n**Return type:** List[Union[BarDataList, RealTimeBarList]]\n\n#### newsTicks()\nList of ticks with headline news. The article itself can be retrieved with reqNewsArticle().\n**Return type:** List[NewsTick]\n\n#### newsBulletins()\nList of IB news bulletins.\n**Return type:** List[NewsBulletin]\n\n#### reqTickers(*contracts, regulatorySnapshot=False)\nRequest and return a list of snapshot tickers. The list is returned when all tickers are ready.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to get tickers for.\n- **regulatorySnapshot** (bool) - Request NBBO snapshots (may incur a fee).\n**Return type:** List[Ticker]\n\n#### qualifyContracts(*contracts)\nFully qualify the given contracts in-place. This will fill in the missing fields in the contract, especially the conId. Returns a list of contracts that have been successfully qualified.\n**This method is blocking.**\n**Parameters:**\n- **contracts** (Contract) - Contracts to qualify.\n**Return type:** List[Contract]\n\n#### bracketOrder(action, quantity, limitPrice, takeProfitPrice, stopLossPrice, **kwargs)\nCreate a limit order that is bracketed by a take-profit order and a stop-loss order. Submit the bracket like:\n\nfor o in bracket:\n    ib.placeOrder(contract, o)\n**Parameters:**\n- **action** (str) - 'BUY' or 'SELL'.\n- **quantity** (float) - Size of order.\n- **limitPrice** (float) - Limit price of entry order.\n- **takeProfitPrice** (float) - Limit price of profit order.\n- **stopLossPrice** (float) - Stop price of loss order.\n**Return type:** BracketOrder\n\n#### static oneCancelsAll(orders, ocaGroup, ocaType)\nPlace the trades in the same One Cancels All (OCA) group.\nhttps://interactivebrokers.github.io/tws-api/oca.html\n**Parameters:**\n- **orders** (List[Order]) - The orders that are to be placed together.\n**Return type:** List[Order]\n\n#### whatIfOrder(contract, order)\nRetrieve commission and margin impact without actually placing the order. The given order will not be modified in any way.\n**This method is blocking.**\n**Parameters:**\n- **contract** (Contract) - Contract to test.\n- **order** (Order) - Order to test.\n**Return type:** OrderState\n\n#### placeOrder(contract, order)\nPlace a new order or modify an existing order. Returns a Trade that is kept live updated with status changes, fills, etc.\n**Parameters:**\n- **contract** (Contract) - Contract to use for order.\n- **order** (Order) - The order to be placed.\n**Return type:** Trade\n\n#### cancelOrder(order, manualCancelOrderTime='')\nCancel the order and return the Trade it belongs to.\n**Parameters:**\n- **order** (Order) - The order to be canceled.\n- **manualCancelOrderTime** (str) - For audit trail.\n**Return type:** Trade\n\n#### reqGlobalCancel()\nCancel all active trades including those placed by other clients or TWS/IB gateway.\n\n#### reqCurrentTime()\nRequest TWS current time.\n**This method is blocking.**\n**Return type:** datetime\n\n#### reqAccountUpdates(account='')\nThis is called at startup - no need to call again. Request account and portfolio values of the account and keep updated. Returns when both account values and portfolio are filled.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n\n#### reqAccountUpdatesMulti(account='', modelCode='')\nIt is recommended to use accountValues() instead. Request account values of multiple accounts and keep updated.\n**This method is blocking.**\n**Parameters:**\n- **account** (str) - If specified, filter for this account name.\n- **modelCode** (str) - If specified, filter for this account model.\n\n#### reqAccountSummary()\nIt is recommended to use accountSummary() instead. Request account values for all accounts and keep them updated. Returns when account summary is filled.\n**This method is blocking.**\n\n#### reqAutoOpenOrders(autoBind=True)\nBind manual TWS orders so that they can be managed from this client. The clientId must be 0 and the TWS API setting \"Use negative numbers to bind automatic orders\" must be checked. This request is automatically called when clientId=0.\nhttps://interactivebrokers.github.io/tws-api/open_orders.html https://interactivebrokers.github.io/tws-api/modifying_orders.html\n\n**Parameters:**\n- **autoBind** (bool) - Set binding on or off.\n\n#### reqOpenOrders()\nRequest and return a list of open orders. This method can give stale information where a new open order is not reported or an already filled or cancelled order is reported as open. It is recommended to use the more reliable and much faster openTrades() or openOrders() methods instead.\n**This method is blocking.**\n**Return type:** List[Order]\n\n#### reqAllOpenOrders()\nRequest and return a list of all open orders over all clients. Note that the orders of other clients will not be kept in sync, use the master clientId mechanism instead to see other client's orders that are kept in sync.\n**Return type:** List[Order]\n\n#### reqCompletedOrders(apiOnly)\nRequest and return a list of completed trades.\n**Parameters:**\n- **apiOnly** (bool) - Request only API orders (not manually placed TWS orders).\n**Return type:** List[Trade]\n\n#### reqExecutions(execFilter=None)\nIt is recommended to use fills() or executions() instead. Request and return a list of fills.\n**This method is blocking.**\n**Parameters:**\n- **execFilter** (Optional[ExecutionFilter]) - If specified, return executions that match the filter.\n**Return type:** List[Fill]\n\n#### reqPositions()\nIt is recommended to use positions() instead. Request and return a list of positions for all accounts.\n**This method is blocking.**\n**Return type:** List[Position]\n\n#### reqPnL(account, modelCode='')\nStart a subscription for profit and loss events. Returns a PnL object that is kept live updated. The result can also be queried from pnl().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - If specified, filter for this account model.\n**Return type:** PnL\n\n#### cancelPnL(account, modelCode='')\nCancel PnL subscription.\n**Parameters:**\n- **account** - Cancel for this account.\n- **modelCode** (str) - If specified, cancel for this account model.\n\n#### reqPnLSingle(account, modelCode, conId)\nStart a subscription for profit and loss events for single positions. Returns a PnLSingle object that is kept live updated. The result can also be queried from pnlSingle().\nhttps://interactivebrokers.github.io/tws-api/pnl.html\n**Parameters:**\n- **account** (str) - Subscribe to this account.\n- **modelCode** (str) - Filter for this account model.\n- **conId** (int) - Filter for this contract ID.\n**Return type:** PnLSingle\n\n#### cancelPnLSingle(account, modelCode, conId)\nCancel PnLSingle subscription for the given account, modelCode and conId.\n**Parameters:**\n- **account** (str) - Cancel for this account name.\n- **modelCode** (str) - Cancel for this account model.\n- **conId** (int) - Cancel for this contract ID.\n\n#### reqContractDetails(contract)\nGet a list of contract details that match the given contract. If the returned list is empty then the contract is not known; If the list has multiple values then the contract is ambiguous. The fully qualified contract is available in the the ContractDetails.contract attribute.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/contract_details.html\n**Parameters:**\n- **contract** (Contract) - The contract to get details for.\n**Return type:** List[ContractDetails]\n\n#### reqMatchingSymbols(pattern)\nRequest contract descriptions of contracts that match a pattern.\n**This method is blocking.**\nhttps://interactivebrokers.github.io/tws-api/matching_symbols.html\n**Parameters:**\npattern (str) -The first few letters of the ticker symbol, or for longer strings a character\nsequence matching a word in the security name.\nReturn type\nList[ContractDescription]\n\n#### reqMarketRule(marketRuleId)\nRequest price increments rule.\nhttps://interactivebrokers.github.io/tws-api/minimum_increment.html\nParameters\nmarketRuleId (int) -ID of market rule. The market rule IDs for a contract can be ob-\ntained via reqContractDetails() from ContractDetails.marketRuleIds, which con-\ntains a comma separated string of market rule IDs.\nReturn type\nPriceIncrement\n\n#### reqRealTimeBars(contract, barSize, whatToShow, useRTH, realTimeBarsOptions=[])\nRequest realtime 5 second bars.\nhttps://interactivebrokers.github.io/tws-api/realtime_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-barSize (int) -Must be 5.\n-whatToShow (str) -Specifies the source for constructing bars. Can be \u2018TRADES\u2019, \u2018MID-\nPOINT\u2019, \u2018BID\u2019 or \u2018ASK\u2019.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-realTimeBarsOptions (List[TagValue]) -Unknown.\nReturn type\nRealTimeBarList\n\n#### cancelRealTimeBars(bars)\nCancel the realtime bars subscription.\nParameters\nbars (RealTimeBarList) -The bar list that was obtained from reqRealTimeBars.\n\n#### reqHistoricalData(contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate=1, keepUpToDate=False, chartOptions=[], timeout=60)\nRequest historical bar data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_bars.html\nParameters\n-contract (Contract) -Contract of interest.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-durationStr (str) -Time span of all the bars. Examples: \u201860 S\u2019, \u201830 D\u2019, \u201813 W\u2019, \u20186 M\u2019,\n\u201810 Y\u2019.\n-barSizeSetting (str) -Time period of one bar. Must be one of: \u20181 secs\u2019, \u20185 secs\u2019, \u201810\nsecs\u2019 15 secs\u2019, \u201830 secs\u2019, \u20181 min\u2019, \u20182 mins\u2019, \u20183 mins\u2019, \u20185 mins\u2019, \u201810 mins\u2019, \u201815 mins\u2019, \u201820\nmins\u2019, \u201830 mins\u2019, \u20181 hour\u2019, \u20182 hours\u2019, \u20183 hours\u2019, \u20184 hours\u2019, \u20188 hours\u2019, \u20181 day\u2019, \u20181 week\u2019, \u20181\nmonth\u2019.\n-whatToShow (str) -Specifies the source for constructing bars. Must be one\nof: \u2018TRADES\u2019, \u2018MIDPOINT\u2019, \u2018BID\u2019, \u2018ASK\u2019, \u2018BID_ASK\u2019, \u2018ADJUSTED_LAST\u2019, \u2018HIS-\nTORICAL_VOLATILITY\u2019, \u2018OPTION_IMPLIED_VOLATILITY\u2019, \u2018REBATE_RATE\u2019,\n\u2018FEE_RATE\u2019, \u2018YIELD_BID\u2019, \u2018YIELD_ASK\u2019, \u2018YIELD_BID_ASK\u2019, \u2018YIELD_LAST\u2019. For\n\u2018SCHEDULE\u2019 use reqHistoricalSchedule().\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -For an intraday request setting to 2 will cause the returned date fields\nto be timezone-aware datetime.datetime with UTC timezone, instead of local timezone as\nused by TWS.\n-keepUpToDate (bool) -If True then a realtime subscription is started to keep the bars\nupdated; endDateTime must be set empty (\u2018\u2019) then.\n-chartOptions (List[TagValue]) -Unknown.\n-timeout (float) -Timeout in seconds after which to cancel the request and return an\nempty bar series. Set to 0 to wait indefinitely.\nReturn type\nBarDataList\n\n#### cancelHistoricalData(bars)\nCancel the update subscription for the historical bars.\nParameters\nbars (BarDataList) -The bar list that was obtained from reqHistoricalData with a\nkeepUpToDate subscription.\n\n\n#### reqHistoricalSchedule(contract, numDays, endDateTime='', useRTH=True)\nRequest historical schedule.\nThis method is blocking.\nParameters\n-contract (Contract) -Contract of interest.\n-numDays (int) -Number of days.\n-endDateTime (Union[datetime, date, str, None]) -Can be set to \u2018\u2019 to indicate the\ncurrent time, or it can be given as a datetime.date or datetime.datetime, or it can be given\nas a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no timezone is given then the TWS login\ntimezone is used.\n-useRTH (bool) -If True then show schedule for Regular Trading Hours, if False then for\nextended hours.\nReturn type\nHistoricalSchedule\n\n#### reqHistoricalTicks(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nRequest historical ticks. The time resolution of the ticks is one second.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/historical_time_and_sales.html\nParameters\n-contract (Contract) -Contract to query.\n-startDateTime (Union[str, date]) -Can be given as a datetime.date or date-\ntime.datetime, or it can be given as a string in \u2018yyyyMMdd HH:mm:ss\u2019 format. If no\ntimezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -One of startDateTime or endDateTime can be\ngiven, the other must be blank.\n-numberOfTicks (int) -Number of ticks to request (1000 max). The actual result can\ncontain a bit more to accommodate all ticks in the latest second.\n-whatToShow (str) -One of \u2018Bid_Ask\u2019, \u2018Midpoint\u2019 or \u2018Trades\u2019.\n-useRTH -If True then only show data from within Regular Trading Hours, if False then\nshow all data.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\n-miscOptions (List[TagValue]) -Unknown.\nReturn type\nList\n\n#### reqMarketDataType(marketDataType)\nSet the market data type used for reqMktData().\nParameters\nmarketDataType (int) -One of:\n-1 = Live\n-2 = Frozen\n-3 = Delayed\n-4 = Delayed frozen\nhttps://interactivebrokers.github.io/tws-api/market_data_type.html\nreqHeadTimeStamp(contract, whatToShow, useRTH, formatDate=1)\nGet the datetime of earliest available historical data for the contract.\nParameters\n-contract (Contract) -Contract of interest.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-formatDate (int) -If set to 2 then the result is returned as a timezone-aware date-\ntime.datetime with UTC timezone.\nReturn type\ndatetime\n\n#### reqMktData(contract, genericTickList='', snapshot=False, regulatorySnapshot=False,\nmktDataOptions=None)\nSubscribe to tick data or request a snapshot. Returns the Ticker that holds the market data. The ticker will\ninitially be empty and gradually (after a couple of seconds) be filled.\nhttps://interactivebrokers.github.io/tws-api/md_request.html\nParameters\n-contract (Contract) -Contract of interest.\n-genericTickList (str) -Comma separated IDs of desired generic ticks that will cause\ncorresponding Ticker fields to be filled:\n\nID  Ticker fields\n100 putVolume, callVolume (for options)\n101 putOpenInterest, callOpenInterest (for options)\n104 histVolatility (for options)\n105 avOptionVolume (for options)\n106 impliedVolatility (for options)\n162 indexFuturePremium\n165 low13week, high13week, low26week, high26week, low52week,\nhigh52week, avVolume\n221 markPrice\n225 auctionVolume, auctionPrice, auctionImbalance\n233 last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 shortableShares\n258 fundamentalRatios (of type ib_insync.objects.FundamentalRatios)\n293 tradeCount\n294 tradeRate\n295 volumeRate\n375 rtTradeVolume\n411 rtHistVolatility\n456 dividends (of type ib_insync.objects.Dividends)\n588 futuresOpenInterest\n\n-snapshot (bool) -If True then request a one-time snapshot, otherwise subscribe to a\nstream of realtime tick data.\n-regulatorySnapshot (bool) -Request NBBO snapshot (may incur a fee).\n-mktDataOptions (Optional[List[TagValue]]) -Unknown\nReturn type\nTicker\n\n#### cancelMktData(contract)\nUnsubscribe from realtime streaming tick data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\nreqTickByTickData(contract, tickType, numberOfTicks=0, ignoreSize=False)\nSubscribe to tick-by-tick data and return the Ticker that holds the ticks in ticker.tickByTicks.\nhttps://interactivebrokers.github.io/tws-api/tick_data.html\nParameters\n-contract (Contract) -Contract of interest.\n-tickType (str) -One of \u2018Last\u2019, \u2018AllLast\u2019, \u2018BidAsk\u2019 or \u2018MidPoint\u2019.\n-numberOfTicks (int) -Number of ticks or 0 for unlimited.\n-ignoreSize (bool) -Ignore bid/ask ticks that only update the size.\nReturn type\nTicker\n\n#### cancelTickByTickData(contract, tickType)\nUnsubscribe from tick-by-tick data\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqSmartComponents(bboExchange)\nObtain mapping from single letter codes to exchange names.\nNote: The exchanges must be open when using this request, otherwise an empty list is returned.\nReturn type\nList[SmartComponent]\n\n#### reqMktDepthExchanges()\nGet those exchanges that have have multiple market makers (and have ticks returned with marketMaker\ninfo).\nReturn type\nList[DepthMktDataDescription]\n\n#### reqMktDepth(contract, numRows=5, isSmartDepth=False, mktDepthOptions=None)\nSubscribe to market depth data (a.k.a. DOM, L2 or order book).\nhttps://interactivebrokers.github.io/tws-api/market_depth.html\nParameters\n-contract (Contract) -Contract of interest.\n-numRows (int) -Number of depth level on each side of the order book (5 max).\n-isSmartDepth (bool) -Consolidate the order book across exchanges.\n-mktDepthOptions -Unknown.\nReturn type\nTicker\nReturns\nThe Ticker that holds the market depth in ticker.domBids and ticker.domAsks and the\nlist of MktDepthData in ticker.domTicks.\n\n#### cancelMktDepth(contract, isSmartDepth=False)\nUnsubscribe from market depth data.\nParameters\ncontract (Contract) -The exact contract object that was used to subscribe with.\n\n#### reqHistogramData(contract, useRTH, period)\nRequest histogram data.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/histograms.html\nParameters\n-contract (Contract) -Contract to query.\n-useRTH (bool) -If True then only show data from within Regular Trading Hours, if False\nthen show all data.\n-period (str) -Period of which data is being requested, for example \u20183 days\u2019.\nReturn type\nList[HistogramData]\n\n#### reqFundamentalData(contract, reportType, fundamentalDataOptions=[])\nGet fundamental data of a contract in XML format.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/fundamentals.html\nParameters\n-contract (Contract) -Contract to query.\n-reportType (str) \u2013\n\u2013 \u2018ReportsFinSummary\u2019: Financial summary\n\u2013 \u2019ReportsOwnership\u2019: Company\u2019s ownership\n\u2013 \u2019ReportSnapshot\u2019: Company\u2019s financial overview\n\u2013 \u2019ReportsFinStatements\u2019: Financial Statements\n\u2013 \u2019RESC\u2019: Analyst Estimates\n\u2013 \u2019CalendarReport\u2019: Company\u2019s calendar\n-fundamentalDataOptions (List[TagValue]) -Unknown\nReturn type\nstr\n\n#### reqScannerData(subscription, scannerSubscriptionOptions=[], scannerSubscriptionFilterOptions=[])\nDo a blocking market scan by starting a subscription and canceling it after the initial list of results are in.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -Basic filters.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Advanced generic filters.\nReturn type\nScanDataList\n\n#### reqScannerSubscription(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nSubscribe to market scan data.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\n-subscription (ScannerSubscription) -What to scan for.\n-scannerSubscriptionOptions (List[TagValue]) -Unknown.\n-scannerSubscriptionFilterOptions (List[TagValue]) -Unknown.\nReturn type\nScanDataList\n\n#### cancelScannerSubscription(dataList)\nCancel market data subscription.\nhttps://interactivebrokers.github.io/tws-api/market_scanners.html\nParameters\ndataList (ScanDataList) -The scan data list that was obtained from\nreqScannerSubscription().\n\n#### reqScannerParameters()\nRequests an XML list of scanner parameters.\nThis method is blocking.\nReturn type\nstr\n\n#### calculateImpliedVolatility(contract, optionPrice, underPrice, implVolOptions=[])\nCalculate the volatility given the option price.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-optionPrice (float) -Option price to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions (List[TagValue]) -Unknown\nReturn type\nOptionComputation\n\n#### calculateOptionPrice(contract, volatility, underPrice, optPrcOptions=[])\nCalculate the option price given the volatility.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/option_computations.html\nParameters\n-contract (Contract) -Option contract.\n-volatility (float) -Option volatility to use in calculation.\n-underPrice (float) -Price of the underlier to use in calculation\n-implVolOptions -Unknown\nReturn type\nOptionComputation\n\n#### reqSecDefOptParams(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nGet the option chain.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-underlyingSymbol (str) -Symbol of underlier contract.\n-futFopExchange (str) -Exchange (only for FuturesOption, otherwise leave blank).\n-underlyingSecType (str) -The type of the underlying security, like \u2018STK\u2019 or \u2018FUT\u2019.\n-underlyingConId (int) -conId of the underlying contract.\nReturn type\nList[OptionChain]\n\n#### exerciseOptions(contract, exerciseAction, exerciseQuantity, account, override)\nExercise an options contract.\nhttps://interactivebrokers.github.io/tws-api/options.html\nParameters\n-contract (Contract) -The option contract to be exercised.\n-exerciseAction (int) \u2013\n\u2013 1 = exercise the option\n\u2013 2 = let the option lapse\n-exerciseQuantity (int) -Number of contracts to be exercised.\n-account (str) -Destination account.\n-override (int) \u2013\n\u2013 0 = no override\n\u2013 1 = override the system\u2019s natural action\n\n#### reqNewsProviders()\nGet a list of news providers.\nThis method is blocking.\nReturn type\nList[NewsProvider]\n\n#### reqNewsArticle(providerCode, articleId, newsArticleOptions=None)\nGet the body of a news article.\nThis method is blocking.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\n-providerCode (str) -Code indicating news provider, like \u2018BZ\u2019 or \u2018FLY\u2019.\n-articleId (str) -ID of the specific article.\n-newsArticleOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nNewsArticle\n\n#### reqHistoricalNews(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nGet historical news headline.\nhttps://interactivebrokers.github.io/tws-api/news.html\nThis method is blocking.\nParameters\n-conId (int) -Search news articles for contract with this conId.\n-providerCodes (str) -A \u2018+\u2019-separated list of provider codes, like \u2018BZ+FLY\u2019.\n-startDateTime (Union[str, date]) -The (exclusive) start of the date range. Can be\ngiven as a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-endDateTime (Union[str, date]) -The (inclusive) end of the date range. Can be given\nas a datetime.date or datetime.datetime, or it can be given as a string in \u2018yyyyMMdd\nHH:mm:ss\u2019 format. If no timezone is given then the TWS login timezone is used.\n-totalResults (int) -Maximum number of headlines to fetch (300 max).\n-historicalNewsOptions (Optional[List[TagValue]]) -Unknown.\nReturn type\nHistoricalNews\n\n#### reqNewsBulletins(allMessages)\nSubscribe to IB news bulletins.\nhttps://interactivebrokers.github.io/tws-api/news.html\nParameters\nallMessages (bool) -If True then fetch all messages for the day.\n\n#### cancelNewsBulletins()\nCancel subscription to IB news bulletins.\n\n#### requestFA(faDataType)\nRequests to change the FA configuration.\nThis method is blocking.\nParameters\nfaDataType (int) \u2013\n-1 = Groups: Offer traders a way to create a group of accounts and apply a single allocation\nmethod to all accounts in the group.\n-2 = Profiles: Let you allocate shares on an account-by-account basis using a predefined\ncalculation value.\n-3 = Account Aliases: Let you easily identify the accounts by meaningful names rather than\naccount numbers.\n\n#### replaceFA(faDataType, xml)\nReplaces Financial Advisor\u2019s settings.\nParameters\n-faDataType (int) -See requestFA().\n-xml (str) -The XML-formatted configuration string.\n\n#### reqUserInfo()\nGet the White Branding ID of the user.\nReturn type\nstr\n\n#### async connectAsync(host='127.0.0.1', port=7497, clientId=1, timeout=4, readonly=False, account='')\n\n#### async qualifyContractsAsync(*contracts)\nReturn type\nList[Contract]\n\n#### async reqTickersAsync(*contracts, regulatorySnapshot=False)\nReturn type\nList[Ticker]\n\n#### whatIfOrderAsync(contract, order)\nReturn type\nAwaitable[OrderState]\n\n#### reqCurrentTimeAsync()\nReturn type\nAwaitable[datetime]\n\n#### reqAccountUpdatesAsync(account)\nReturn type\nAwaitable[None]\n\n#### reqAccountUpdatesMultiAsync(account, modelCode='')\nReturn type\nAwaitable[None]\n\n#### async accountSummaryAsync(account='')\nReturn type\nList[AccountValue]\n\n#### reqAccountSummaryAsync()\nReturn type\nAwaitable[None]\n\n#### reqOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqAllOpenOrdersAsync()\nReturn type\nAwaitable[List[Order]]\n\n#### reqCompletedOrdersAsync(apiOnly)\nReturn type\nAwaitable[List[Trade]]\n\n#### reqExecutionsAsync(execFilter=None)\nReturn type\nAwaitable[List[Fill]]\n\n#### reqPositionsAsync()\nReturn type\nAwaitable[List[Position]]\n\n#### reqContractDetailsAsync(contract)\nReturn type\nAwaitable[List[ContractDetails]]\n\n#### async reqMatchingSymbolsAsync(pattern)\nReturn type\nOptional[List[ContractDescription]]\n\n#### async reqMarketRuleAsync(marketRuleId)\nReturn type\nOptional[List[PriceIncrement]]\n\n#### async reqHistoricalDataAsync(contract, endDateTime, durationStr, barSizeSetting, whatToShow,\nuseRTH, formatDate=1, keepUpToDate=False, chartOptions=[],\ntimeout=60)\nReturn type\nBarDataList\n\n#### reqHistoricalScheduleAsync(contract, numDays, endDateTime='', useRTH=True)\nReturn type\nAwaitable[HistoricalSchedule]\n\n#### reqHistoricalTicksAsync(contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize=False, miscOptions=[])\nReturn type\nAwaitable[List]\n\n#### reqHeadTimeStampAsync(contract, whatToShow, useRTH, formatDate)\nReturn type\nAwaitable[datetime]\n\n#### reqSmartComponentsAsync(bboExchange)\n\n#### reqMktDepthExchangesAsync()\nReturn type\nAwaitable[List[DepthMktDataDescription]]\n\n#### reqHistogramDataAsync(contract, useRTH, period)\nReturn type\nAwaitable[List[HistogramData]]\n\n#### reqFundamentalDataAsync(contract, reportType, fundamentalDataOptions=[])\nReturn type\nAwaitable[str]\n\n#### async reqScannerDataAsync(subscription, scannerSubscriptionOptions=[],\nscannerSubscriptionFilterOptions=[])\nReturn type\nScanDataList\n\n#### reqScannerParametersAsync()\nReturn type\nAwaitable[str]\n\n#### async calculateImpliedVolatilityAsync(contract, optionPrice, underPrice, implVolOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### async calculateOptionPriceAsync(contract, volatility, underPrice, optPrcOptions=[])\nReturn type\nOptional[OptionComputation]\n\n#### reqSecDefOptParamsAsync(underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\nReturn type\nAwaitable[List[OptionChain]]\n\n#### reqNewsProvidersAsync()\nReturn type\nAwaitable[List[NewsProvider]]\n\n#### reqNewsArticleAsync(providerCode, articleId, newsArticleOptions)\nReturn type\nAwaitable[NewsArticle\n\n#### async reqHistoricalNewsAsync(conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions=None)\nReturn type\nOptional[HistoricalNews]\n\n#### async requestFAAsync(faDataType)\nreqUserInfoAsync()",
          "language": "python",
          "context": "Note: It is not advisable to place new requests inside an event handler as it may lead to too much recursion.",
          "source_file": "pdf_extract.md",
          "line_number": 114,
          "heading": "class ib_insync.ib.IB",
          "tags": [
            "async",
            "connect",
            "contract",
            "data",
            "error",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0119_672d75df"
    },
    {
      "cluster_id": "cluster_0119",
      "examples": [
        {
          "id": "ex_0120_61a75e07",
          "code": "Socket client for communicating with Interactive Brokers.\n\n#### class ib_insync.client.Client(wrapper)\nReplacement for ibapi.client.EClient that uses asyncio.\nThe client is fully asynchronous and has its own event-driven networking code that replaces the networking code\nof the standard EClient. It also replaces the infinite loop of EClient.run() with the asyncio event loop. It can\nbe used as a drop-in replacement for the standard EClient as provided by IBAPI.\nCompared to the standard EClient this client has the following additional features:\n-client.connect() will block until the client is ready to serve requests; It is not necessary to wait for\nnextValidId to start requests as the client has already done that. The reqId is directly available with\ngetReqId().\n-client.connectAsync() is a coroutine for connecting asynchronously.\n-When blocking, client.connect() can be made to time out with the timeout parameter (default 2 sec-\nonds).\n-Optional wrapper.priceSizeTick(reqId, tickType, price, size) that combines price and size\ninstead of the two wrapper methods priceTick and sizeTick.\n-Automatic request throttling.\n-Optional wrapper.tcpDataArrived() method; If the wrapper has this method it is invoked directly after\na network packet has arrived. A possible use is to timestamp all data in the packet with the exact same time.\n-Optional wrapper.tcpDataProcessed() method; If the wrapper has this method it is invoked after the\nnetwork packet\u2019s data has been handled. A possible use is to write or evaluate the newly arrived data in one\nbatch instead of item by item.\nParameters\n-MaxRequests (int) -Throttle the number of requests to MaxRequests per\nRequestsInterval seconds. Set to 0 to disable throttling.\n-RequestsInterval (float) -Time interval (in seconds) for request throttling.\n-MinClientVersion (int) -Client protocol version.\n-MaxClientVersion (int) -Client protocol version\n\nEvents:\n-apiStart ()\n-apiEnd ()\n-apiError (errorMsg: str)\n-throttleStart ()\n-throttleEnd ()\nevents = ('apiStart', 'apiEnd', 'apiError', 'throttleStart', 'throttleEnd')\nMaxRequests = 45\nRequestsInterval = 1\nMinClientVersion = 157\nMaxClientVersion = 176\nDISCONNECTED = 0\nCONNECTING = 1\nCONNECTED = 2\nreset()\nserverVersion()\nReturn type\nint\nrun()\nisConnected()\nisReady()\nIs the API connection up and running?\nReturn type\nbool\nconnectionStats()\nGet statistics about the connection.\nReturn type\nConnectionStats\ngetReqId()\nGet new request ID.\nReturn type\nint\nupdateReqId(minReqId)\nUpdate the next reqId to be at least minReqId.\ngetAccounts()\nGet the list of account names that are under management.\nReturn type\nList[str]\n\nsetConnectOptions(connectOptions)\nSet additional connect options.\nParameters\nconnectOptions (str) -Use \u201c+PACEAPI\u201d to use request-pacing built into TWS/gateway\n974+.\n\nconnect(host, port, clientId, timeout=2.0)\nConnect to a running TWS or IB gateway application.\nParameters\n-host (str) -Host name or IP address.\n-port (int) -Port number.\n-clientId (int) -ID number to use for this client; must be unique per connection.\n-timeout (Optional[float]) -If establishing the connection takes longer than timeout\nseconds then the asyncio.TimeoutError exception is raised. Set to 0 to disable timeout.\n\nasync connectAsync(host, port, clientId, timeout=2.0)\n\ndisconnect()\nDisconnect from IB connection.\n\nsend(*fields)\nSerialize and send the given fields using the IB socket protocol.\n\nsendMsg(msg)\n\nreqMktData(reqId, contract, genericTickList, snapshot, regulatorySnapshot, mktDataOptions)\n\ncancelMktData(reqId)\n\nplaceOrder(orderId, contract, order)\n\ncancelOrder(orderId, manualCancelOrderTime='')\n\nreqOpenOrders()\n\nreqAccountUpdates(subscribe, acctCode)\n\nreqExecutions(reqId, execFilter)\n\nreqIds(numIds)\n\nreqContractDetails(reqId, contract)\n\nreqMktDepth(reqId, contract, numRows, isSmartDepth, mktDepthOptions)\n\ncancelMktDepth(reqId, isSmartDepth)\n\nreqNewsBulletins(allMsgs)\n\ncancelNewsBulletins()\n\nsetServerLogLevel(logLevel)\n\nreqAutoOpenOrders(bAutoBind)\n\nreqAllOpenOrders()\n\nreqManagedAccts()\n\nrequestFA(faData)\n\nreplaceFA(reqId, faData, cxml)\n\nreqHistoricalData(reqId, contract, endDateTime, durationStr, barSizeSetting, whatToShow, useRTH,\nformatDate, keepUpToDate, chartOptions)\n\nexerciseOptions(reqId, contract, exerciseAction, exerciseQuantity, account, override)\n\nreqScannerSubscription(reqId, subscription, scannerSubscriptionOptions,\nscannerSubscriptionFilterOptions)\n\ncancelScannerSubscription(reqId)\n\nreqScannerParameters()\n\ncancelHistoricalData(reqId)\n\nreqCurrentTime()\n\nreqRealTimeBars(reqId, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)\n\ncancelRealTimeBars(reqId)\n\nreqFundamentalData(reqId, contract, reportType, fundamentalDataOptions)\n\ncancelFundamentalData(reqId)\n\ncalculateImpliedVolatility(reqId, contract, optionPrice, underPrice, implVolOptions)\n\ncalculateOptionPrice(reqId, contract, volatility, underPrice, optPrcOptions)\n\ncancelCalculateImpliedVolatility(reqId)\n\ncancelCalculateOptionPrice(reqId)\n\nreqGlobalCancel()\n\nreqMarketDataType(marketDataType)\n\nreqPositions()\n\nreqAccountSummary(reqId, groupName, tags)\n\ncancelAccountSummary(reqId)\n\ncancelPositions()\n\nverifyRequest(apiName, apiVersion)\n\nverifyMessage(apiData)\n\nqueryDisplayGroups(reqId)\n\nsubscribeToGroupEvents(reqId, groupId)\n\nupdateDisplayGroup(reqId, contractInfo)\n\nunsubscribeFromGroupEvents(reqId)\n\nstartApi()\n\nverifyAndAuthRequest(apiName, apiVersion, opaqueIsvKey)\n\nverifyAndAuthMessage(apiData, xyzResponse)\n\nreqPositionsMulti(reqId, account, modelCode)\n\ncancelPositionsMulti(reqId)\n\nreqAccountUpdatesMulti(reqId, account, modelCode, ledgerAndNLV )\n\ncancelAccountUpdatesMulti(reqId)\n\nreqSecDefOptParams(reqId, underlyingSymbol, futFopExchange, underlyingSecType, underlyingConId)\n\nreqSoftDollarTiers(reqId)\n\nreqFamilyCodes()\n\nreqMatchingSymbols(reqId, pattern)\n\nreqMktDepthExchanges()\n\nreqSmartComponents(reqId, bboExchange)\n\nreqNewsArticle(reqId, providerCode, articleId, newsArticleOptions)\n\nreqNewsProviders()\n\nreqHistoricalNews(reqId, conId, providerCodes, startDateTime, endDateTime, totalResults,\nhistoricalNewsOptions)\n\nreqHeadTimeStamp(reqId, contract, whatToShow, useRTH, formatDate)\n\nreqHistogramData(tickerId, contract, useRTH, timePeriod)\n\ncancelHistogramData(tickerId)\n\ncancelHeadTimeStamp(reqId)\n\nreqMarketRule(marketRuleId)\n\nreqPnL(reqId, account, modelCode)\n\ncancelPnL(reqId)\n\nreqPnLSingle(reqId, account, modelCode, conid)\n\ncancelPnLSingle(reqId)\n\nreqHistoricalTicks(reqId, contract, startDateTime, endDateTime, numberOfTicks, whatToShow, useRth,\nignoreSize, miscOptions)\n\nreqTickByTickData(reqId, contract, tickType, numberOfTicks, ignoreSize)\n\ncancelTickByTickData(reqId)\n\nreqCompletedOrders(apiOnly)\n\nreqWshMetaData(reqId)\n\ncancelWshMetaData(reqId)\n\nreqWshEventData(reqId, data)\n\ncancelWshEventData(reqId)\n\nreqUserInfo(reqId)",
          "language": "python",
          "context": "\nClient",
          "source_file": "pdf_extract.md",
          "line_number": 997,
          "heading": "async requestFAAsync(faDataType)",
          "tags": [
            "async",
            "connect",
            "contract",
            "data",
            "error",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0120_61a75e07"
    },
    {
      "cluster_id": "cluster_0120",
      "examples": [
        {
          "id": "ex_0121_fda0b06a",
          "code": "#### class ib_insync.order.Order(orderId: int = 0, clientId: int = 0, permId: int = 0, action: str = '',\ntotalQuantity: float = 0.0, orderType: str = '', lmtPrice: float =\n1.7976931348623157e+308, auxPrice: float = 1.7976931348623157e+308, tif:\nstr = '', activeStartTime: str = '', activeStopTime: str = '', ocaGroup: str = '',\nocaType: int = 0, orderRef: str = '', transmit: bool = True, parentId: int = 0,\nblockOrder: bool = False, sweepToFill: bool = False, displaySize: int = 0,\ntriggerMethod: int = 0, outsideRth: bool = False, hidden: bool = False,\ngoodAfterTime: str = '', goodTillDate: str = '', rule80A: str = '', allOrNone:\nbool = False, minQty: int = 2147483647, percentOffset: float =\n1.7976931348623157e+308, overridePercentageConstraints: bool = False,\ntrailStopPrice: float = 1.7976931348623157e+308, trailingPercent: float =\n1.7976931348623157e+308, faGroup: str = '', faProfile: str = '', faMethod: str\n= '', faPercentage: str = '', designatedLocation: str = '', openClose: str = 'O',\norigin: int = 0, shortSaleSlot: int = 0, exemptCode: int = -1, discretionaryAmt:\nfloat = 0.0, eTradeOnly: bool = False, firmQuoteOnly: bool = False,\nnbboPriceCap: float = 1.7976931348623157e+308, optOutSmartRouting: bool\n= False, auctionStrategy: int = 0, startingPrice: float =\n1.7976931348623157e+308, stockRefPrice: float =\n1.7976931348623157e+308, delta: float = 1.7976931348623157e+308,\nstockRangeLower: float = 1.7976931348623157e+308, stockRangeUpper: float\n= 1.7976931348623157e+308, randomizePrice: bool = False, randomizeSize:\nbool = False, volatility: float = 1.7976931348623157e+308, volatilityType: int\n= 2147483647, deltaNeutralOrderType: str = '', deltaNeutralAuxPrice: float =\n1.7976931348623157e+308, deltaNeutralConId: int = 0,\ndeltaNeutralSettlingFirm: str = '', deltaNeutralClearingAccount: str = '',\ndeltaNeutralClearingIntent: str = '', deltaNeutralOpenClose: str = '',\ndeltaNeutralShortSale: bool = False, deltaNeutralShortSaleSlot: int = 0,\ndeltaNeutralDesignatedLocation: str = '', continuousUpdate: bool = False,\nreferencePriceType: int = 2147483647, basisPoints: float =\n1.7976931348623157e+308, basisPointsType: int = 2147483647,\nscaleInitLevelSize: int = 2147483647, scaleSubsLevelSize: int = 2147483647,\nscalePriceIncrement: float = 1.7976931348623157e+308,\nscalePriceAdjustValue: float = 1.7976931348623157e+308,\nscalePriceAdjustInterval: int = 2147483647, scaleProfitOffset: float =\n1.7976931348623157e+308, scaleAutoReset: bool = False, scaleInitPosition:\nint = 2147483647, scaleInitFillQty: int = 2147483647, scaleRandomPercent:\nbool = False, scaleTable: str = '', hedgeType: str = '', hedgeParam: str = '',\naccount: str = '', settlingFirm: str = '', clearingAccount: str = '', clearingIntent:\nstr = '', algoStrategy: str = '', algoParams:\n~typing.List[~ib_insync.contract.TagValue] = <factory>,\nsmartComboRoutingParams: ~typing.List[~ib_insync.contract.TagValue] =\n<factory>, algoId: str = '', whatIf: bool = False, notHeld: bool = False,\nsolicited: bool = False, modelCode: str = '', orderComboLegs:\n~typing.List[~ib_insync.order.OrderComboLeg] = <factory>,\norderMiscOptions: ~typing.List[~ib_insync.contract.TagValue] = <factory>,\nreferenceContractId: int = 0, peggedChangeAmount: float = 0.0,\nisPeggedChangeAmountDecrease: bool = False, referenceChangeAmount: float\n= 0.0, referenceExchangeId: str = '', adjustedOrderType: str = '', triggerPrice:\nfloat = 1.7976931348623157e+308, adjustedStopPrice: float =\n1.7976931348623157e+308, adjustedStopLimitPrice: float =\n1.7976931348623157e+308, adjustedTrailingAmount: float =\n1.7976931348623157e+308, adjustableTrailingUnit: int = 0, lmtPriceOffset:\nfloat = 1.7976931348623157e+308, conditions:\n~typing.List[~ib_insync.order.OrderCondition] = <factory>,\nconditionsCancelOrder: bool = False, conditionsIgnoreRth: bool = False,\nextOperator: str = '', softDollarTier: ~ib_insync.objects.SoftDollarTier =\n<factory>, cashQty: float = 1.7976931348623157e+308,\nmifid2DecisionMaker: str = '', mifid2DecisionAlgo: str = '',\nmifid2ExecutionTrader: str = '', mifid2ExecutionAlgo: str = '',\ndontUseAutoPriceForHedge: bool = False, isOmsContainer: bool = False,\n\nOrder for trading contracts.\nhttps://interactivebrokers.github.io/tws-api/available_orders.html\norderId: int = 0\nclientId: int = 0\npermId: int = 0\naction: str = ''\ntotalQuantity: float = 0.0\norderType: str = ''\nlmtPrice: float = 1.7976931348623157e+308\nauxPrice: float = 1.7976931348623157e+308\ntif: str = ''\nactiveStartTime: str = ''\nactiveStopTime: str = ''\nocaGroup: str = ''\nocaType: int = 0\norderRef: str = ''\ntransmit: bool = True\nparentId: int = 0\nblockOrder: bool = False\nsweepToFill: bool = False\ndisplaySize: int = 0\ntriggerMethod: int = 0\noutsideRth: bool = False\nhidden: bool = False\ngoodAfterTime: str = ''\ngoodTillDate: str = ''\nrule80A: str = ''\nallOrNone: bool = False\nminQty: int = 2147483647\npercentOffset: float = 1.7976931348623157e+308\noverridePercentageConstraints: bool = False\ntrailStopPrice: float = 1.7976931348623157e+308\ntrailingPercent: float = 1.7976931348623157e+308\nfaGroup: str = ''\nfaProfile: str = ''\nfaMethod: str = ''\nfaPercentage: str = ''\ndesignatedLocation: str = ''\nopenClose: str = 'O'\norigin: int = 0\nshortSaleSlot: int = 0\nexemptCode: int = -1\ndiscretionaryAmt: float = 0.0\neTradeOnly: bool = False\nfirmQuoteOnly: bool = False\nnbboPriceCap: float = 1.7976931348623157e+308\noptOutSmartRouting: bool = False\nauctionStrategy: int = 0\nstartingPrice: float = 1.7976931348623157e+308\nstockRefPrice: float = 1.7976931348623157e+308\ndelta: float = 1.7976931348623157e+308\nstockRangeLower: float = 1.7976931348623157e+308\nstockRangeUpper: float = 1.7976931348623157e+308\nrandomizePrice: bool = False\nrandomizeSize: bool = False\nvolatility: float = 1.7976931348623157e+308\nvolatilityType: int = 2147483647\ndeltaNeutralOrderType: str = ''\ndeltaNeutralAuxPrice: float = 1.7976931348623157e+308\ndeltaNeutralConId: int = 0\ndeltaNeutralSettlingFirm: str = ''\ndeltaNeutralClearingAccount: str = ''\ndeltaNeutralClearingIntent: str = ''\ndeltaNeutralOpenClose: str = ''\ndeltaNeutralShortSale: bool = False\ndeltaNeutralShortSaleSlot: int = 0\ndeltaNeutralDesignatedLocation: str = ''\ncontinuousUpdate: bool = False\nreferencePriceType: int = 2147483647\nbasisPoints: float = 1.7976931348623157e+308\nbasisPointsType: int = 2147483647\nscaleInitLevelSize: int = 2147483647\nscaleSubsLevelSize: int = 2147483647\nscalePriceIncrement: float = 1.7976931348623157e+308\nscalePriceAdjustValue: float = 1.7976931348623157e+308\nscalePriceAdjustInterval: int = 2147483647\nscaleProfitOffset: float = 1.7976931348623157e+308\nscaleAutoReset: bool = False\nscaleInitPosition: int = 2147483647\nscaleInitFillQty: int = 2147483647\nscaleRandomPercent: bool = False\nscaleTable: str = ''\nhedgeType: str = ''\nhedgeParam: str = ''\naccount: str = ''\nsettlingFirm: str = ''\nclearingAccount: str = ''\nclearingIntent: str = ''\nalgoStrategy: str = ''\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\nalgoId: str = ''\nwhatIf: bool = False\nnotHeld: bool = False\nsolicited: bool = False\nmodelCode: str = ''\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nreferenceContractId: int = 0\npeggedChangeAmount: float = 0.0\nisPeggedChangeAmountDecrease: bool = False\nreferenceChangeAmount: float = 0.0\nreferenceExchangeId: str = ''\nadjustedOrderType: str = ''\ntriggerPrice: float = 1.7976931348623157e+308\nadjustedStopPrice: float = 1.7976931348623157e+308\nadjustedStopLimitPrice: float = 1.7976931348623157e+308\nadjustedTrailingAmount: float = 1.7976931348623157e+308\nadjustableTrailingUnit: int = 0\nlmtPriceOffset: float = 1.7976931348623157e+308\nconditions: List[OrderCondition]\nconditionsCancelOrder: bool = False\nconditionsIgnoreRth: bool = False\nextOperator: str = ''\nsoftDollarTier: SoftDollarTier\ncashQty: float = 1.7976931348623157e+308\nmifid2DecisionMaker: str = ''\nmifid2DecisionAlgo: str = ''\nmifid2ExecutionTrader: str = ''\nmifid2ExecutionAlgo: str = ''\ndontUseAutoPriceForHedge: bool = False\nisOmsContainer: bool = False\ndiscretionaryUpToLimitPrice: bool = False\nautoCancelDate: str = ''\nfilledQuantity: float = 1.7976931348623157e+308\nrefFuturesConId: int = 0\nautoCancelParent: bool = False\nshareholder: str = ''\nimbalanceOnly: bool = False\nrouteMarketableToBbo: bool = False\nparentPermId: int = 0\nusePriceMgmtAlgo: bool = False\nduration: int = 2147483647\npostToAts: int = 2147483647\nadvancedErrorOverride: str = ''\nmanualOrderTime: str = ''\nminTradeQty: int = 2147483647\nminCompeteSize: int = 2147483647\ncompeteAgainstBestOffset: float = 1.7976931348623157e+308\nmidOffsetAtWhole: float = 1.7976931348623157e+308\nmidOffsetAtHalf: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.LimitOrder(action, totalQuantity, lmtPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.MarketOrder(action, totalQuantity, **kwargs)\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopOrder(action, totalQuantity, stopPrice, **kwargs)\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.StopLimitOrder(action, totalQuantity, lmtPrice, stopPrice, **kwargs\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\nalgoParams: List[TagValue]\nsmartComboRoutingParams: List[TagValue]\norderComboLegs: List[OrderComboLeg]\norderMiscOptions: List[TagValue]\nconditions: List[OrderCondition]\nsoftDollarTier: SoftDollarTier\n\n#### class ib_insync.order.OrderStatus(orderId: int = 0, status: str = '', filled: float = 0.0, remaining: float =\n0.0, avgFillPrice: float = 0.0, permId: int = 0, parentId: int = 0,\nlastFillPrice: float = 0.0, clientId: int = 0, whyHeld: str = '',\nmktCapPrice: float = 0.0)\n\norderId: int = 0\nstatus: str = ''\nfilled: float = 0.0\nremaining: float = 0.0\navgFillPrice: float = 0.0\npermId: int = 0\nparentId: int = 0\nlastFillPrice: float = 0.0\nclientId: int = 0\nwhyHeld: str = ''\nmktCapPrice: float = 0.0\nPendingSubmit: ClassVar[str] = 'PendingSubmit'\nPendingCancel: ClassVar[str] = 'PendingCancel'\nPreSubmitted: ClassVar[str] = 'PreSubmitted'\nSubmitted: ClassVar[str] = 'Submitted'\nApiPending: ClassVar[str] = 'ApiPending'\nApiCancelled: ClassVar[str] = 'ApiCancelled'\nCancelled: ClassVar[str] = 'Cancelled'\nFilled: ClassVar[str] = 'Filled'\nInactive: ClassVar[str] = 'Inactive'\nDoneStates: ClassVar[Set[str]] = {'ApiCancelled', 'Cancelled', 'Filled'}\nActiveStates: ClassVar[Set[str]] = {'ApiPending', 'PendingSubmit', 'PreSubmitted',\n'Submitted'}\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderState(status: str = '', initMarginBefore: str = '', maintMarginBefore: str = '',\nequityWithLoanBefore: str = '', initMarginChange: str = '',\nmaintMarginChange: str = '', equityWithLoanChange: str = '',\ninitMarginAfter: str = '', maintMarginAfter: str = '', equityWithLoanAfter:\nstr = '', commission: float = 1.7976931348623157e+308,\nminCommission: float = 1.7976931348623157e+308, maxCommission:\nfloat = 1.7976931348623157e+308, commissionCurrency: str = '',\nwarningText: str = '', completedTime: str = '', completedStatus: str = '')\n\nstatus: str = ''\ninitMarginBefore: str = ''\nmaintMarginBefore: str = ''\nequityWithLoanBefore: str = ''\ninitMarginChange: str = ''\nmaintMarginChange: str = ''\nequityWithLoanChange: str = ''\ninitMarginAfter: str = ''\nmaintMarginAfter: str = ''\nequityWithLoanAfter: str = ''\ncommission: float = 1.7976931348623157e+308\nminCommission: float = 1.7976931348623157e+308\nmaxCommission: float = 1.7976931348623157e+308\ncommissionCurrency: str = ''\nwarningText: str = ''\ncompletedTime: str = ''\ncompletedStatus: str = ''\ndict()\n\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.OrderComboLeg(price: float = 1.7976931348623157e+308)\n\nprice: float = 1.7976931348623157e+308\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.Trade(contract: ~ib_insync.contract.Contract = <factory>, order:\n~ib_insync.order.Order = <factory>, orderStatus:\n~ib_insync.order.OrderStatus = <factory>, fills:\n~typing.List[~ib_insync.objects.Fill] = <factory>, log:\n~typing.List[~ib_insync.objects.TradeLogEntry] = <factory>, advancedError:\nstr = '')\nTrade keeps track of an order, its status and all its fills.\nEvents:\n-statusEvent (trade: Trade)\n-modifyEvent (trade: Trade)\n-fillEvent (trade: Trade, fill: Fill)\n-commissionReportEvent (trade: Trade, fill: Fill, commissionReport: CommissionReport)\n-filledEvent (trade: Trade)\n-cancelEvent (trade: Trade)\n-cancelledEvent (trade: Trade)\nevents: ClassVar = ('statusEvent', 'modifyEvent', 'fillEvent',\n'commissionReportEvent', 'filledEvent', 'cancelEvent', 'cancelledEvent')\ncontract: Contract\norder: Order\norderStatus: OrderStatus\nfills: List[Fill]\nlog: List[TradeLogEntry]\nadvancedError: str = ''\nisActive()\nTrue if eligible for execution, false otherwise.\nisDone()\nTrue if completely filled or cancelled, false otherwise.\nfilled()\nNumber of shares filled.\nremaining()\nNumber of shares remaining to be filled.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.BracketOrder(parent, takeProfit, stopLoss)\nCreate new instance of BracketOrder(parent, takeProfit, stopLoss)\nproperty parent\nproperty takeProfit\nproperty stopLoss\n\n#### class ib_insync.order.OrderCondition\nstatic createClass(condType)\nAnd()\nOr()\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PriceCondition(condType: int = 1, conjunction: str = 'a', isMore: bool = True,\nprice: float = 0.0, conId: int = 0, exch: str = '', triggerMethod: int =\n0)\ncondType: int = 1\nconjunction: str = 'a'\nisMore: bool = True\nprice: float = 0.0\nconId: int = 0\nexch: str = ''\ntriggerMethod: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.TimeCondition(condType: int = 3, conjunction: str = 'a', isMore: bool = True, time:\nstr = '')\ncondType: int = 3\nconjunction: str = 'a'\nisMore: bool = True\ntime: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.MarginCondition(condType: int = 4, conjunction: str = 'a', isMore: bool = True,\npercent: int = 0)\ncondType: int = 4\nconjunction: str = 'a'\nisMore: bool = True\npercent: int = 0\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.ExecutionCondition(condType: int = 5, conjunction: str = 'a', secType: str = '',\nexch: str = '', symbol: str = '')\ncondType: int = 5\nconjunction: str = 'a'\nsecType: str = ''\nexch: str = ''\nsymbol: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.VolumeCondition(condType: int = 6, conjunction: str = 'a', isMore: bool = True,\nvolume: int = 0, conId: int = 0, exch: str = '')\ncondType: int = 6\nconjunction: str = 'a'\nisMore: bool = True\nvolume: int = 0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =\nTrue, changePercent: float = 0.0, conId: int = 0, exch: str\n= '')\ncondType: int = 7\nconjunction: str = 'a'\nisMore: bool = True\nchangePercent: float = 0.0\nconId: int = 0\nexch: str = ''\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject",
          "language": "python",
          "context": "\nOrder",
          "source_file": "pdf_extract.md",
          "line_number": 1258,
          "heading": "class ib_insync.client.Client(wrapper)",
          "tags": [
            "contract",
            "error",
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0121_fda0b06a"
    },
    {
      "cluster_id": "cluster_0121",
      "examples": [
        {
          "id": "ex_0122_bbbc6522",
          "code": "Financial instrument types used by Interactive Brokers\n\nclass ib_insync.contract.Contract(secType: str = '', conId: int = 0, symbol: str = '',\nlastTradeDateOrContractMonth: str = '', strike: float = 0.0, right: str =\n'', multiplier: str = '', exchange: str = '', primaryExchange: str = '',\ncurrency: str = '', localSymbol: str = '', tradingClass: str = '',\nincludeExpired: bool = False, secIdType: str = '', secId: str = '',\ndescription: str = '', issuerId: str = '', comboLegsDescrip: str = '',\ncomboLegs: ~typing.List[~ib_insync.contract.ComboLeg] = <factory>,\ndeltaNeutralContract:\n~typing.Optional[~ib_insync.contract.DeltaNeutralContract] = None)\nContract(**kwargs) can create any contract using keyword arguments. To simplify working with contracts,\nthere are also more specialized contracts that take optional positional arguments. Some examples:\n\n\nContract(conId=270639)\nStock('AMD', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nForex('EURUSD')\nCFD('IBUS30')\nFuture('ES', '20180921', 'CME')\nOption('SPY', '20170721', 240, 'C', 'SMART')\nBond(secIdType='ISIN', secId='US03076KAA60')\nCrypto('BTC', 'PAXOS', 'USD')\n\nParameters\n-conId (int) -The unique IB contract identifier.\n-symbol (str) -The contract (or its underlying) symbol.\n-secType (str) -The security type:\n\u2013 \u2019STK\u2019 = Stock (or ETF)\n\u2013 \u2019OPT\u2019 = Option\n\u2013 \u2019FUT\u2019 = Future\n\u2013 \u2019IND\u2019 = Index\n\u2013 \u2019FOP\u2019 = Futures option\n\u2013 \u2019CASH\u2019 = Forex pair\n\u2013 \u2019CFD\u2019 = CFD\n\u2013 \u2019BAG\u2019 = Combo\n\u2013 \u2019WAR\u2019 = Warrant\n\u2013 \u2019BOND\u2019 = Bond\n\u2013 \u2019CMDTY\u2019 = Commodity\n\u2013 \u2019NEWS\u2019 = News\n\u2013 \u2019FUND\u2019 = Mutual fund\n\u2013 \u2019CRYPTO\u2019 = Crypto currency\n-lastTradeDateOrContractMonth (str) -The contract\u2019s last trading day or contract\nmonth (for Options and Futures). Strings with format YYYYMM will be interpreted as\nthe Contract Month whereas YYYYMMDD will be interpreted as Last Trading Day.\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or Call. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019, \u2018CALL\u2019, or \u2018\u2019 for non-options.\n-multiplier (str) -he instrument\u2019s multiplier (i.e. options, futures).\n-exchange (str) -The destination exchange.\n-currency (str) -The underlying\u2019s currency.\n-localSymbol (str) -The contract\u2019s symbol within its primary exchange. For options, this\nwill be the OCC symbol.\n-primaryExchange (str) -The contract\u2019s primary exchange. For smart routed contracts,\nused to define contract in case of ambiguity. Should be defined as native exchange of contract,\ne.g. ISLAND for MSFT. For exchanges which contain a period in name, will only be part of\nexchange name prior to period, i.e. ENEXT for ENEXT.BE.\n-tradingClass (str) -The trading class name for this contract. Available in TWS contract\ndescription window as well. For example, GBL Dec \u201813 future\u2019s trading class is \u201cFGBL\u201d.\n-includeExpired (bool) -If set to true, contract details requests and historical data queries\ncan be performed pertaining to expired futures contracts. Expired options or other instrument\ntypes are not available.\n-secIdType (str) -Security identifier type. Examples for Apple:\n\u2013 secIdType=\u2019ISIN\u2019, secId=\u2019US0378331005\u2019\n\u2013 secIdType=\u2019CUSIP\u2019, secId=\u2019037833100\u2019\n-secId (str) -Security identifier.\n-comboLegsDescription (str) -Description of the combo legs.\n-comboLegs (List[ComboLeg]) -The legs of a combined contract definition.\n-deltaNeutralContract (DeltaNeutralContract) -Delta and underlying price for\nDelta-Neutral combo orders.\nsecType: str = ''\nconId: int = 0\nsymbol: str = ''\nlastTradeDateOrContractMonth: str = ''\nstrike: float = 0.0\nright: str = ''\nmultiplier: str = ''\nexchange: str = ''\nprimaryExchange: str = ''\ncurrency: str = ''\nlocalSymbol: str = ''\ntradingClass: str = ''\nincludeExpired: bool = False\nsecIdType: str = ''\nsecId: str = ''\ndescription: str = ''\nissuerId: str = ''\ncomboLegsDescrip: str = ''\ncomboLegs: List[ComboLeg]\ndeltaNeutralContract: Optional[DeltaNeutralContract] = None\n\nstatic create(**kwargs)\nCreate and a return a specialized contract based on the given secType, or a general Contract if secType is\nnot given.\nReturn type\nContract\n\nisHashable()\nSee if this contract can be hashed by conId.\nNote: Bag contracts always get conId=28812380, so they\u2019re not hashable.\nReturn type\nbool\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\n\n#### class ib_insync.contract.Stock(symbol='', exchange='', currency='', **kwargs)\nStock contract.\nParameters\n-symbol (str) -Symbol name.\n-exchange (str) -Destination exchange.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from\nkeyword arguments.\nReturn type\nobject\ncomboLegs: List[ComboLeg]\n\n#### class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',\nexchange='', multiplier='', currency='', **kwargs)\nOption contract.\nParameters\n-symbol (str) -Symbol name.\n-lastTradeDateOrContractMonth (str) -The option\u2019s last trading day or contract month.\n\u2013 YYYYMM format: To specify last month\n\u2013 YYYYMMDD format: To specify last trading day\n-strike (float) -The option\u2019s strike price.\n-right (str) -Put or call option. Valid values are \u2018P\u2019, \u2018PUT\u2019, \u2018C\u2019 or \u2018CALL\u2019.\n-exchange (str) -Destination exchange.\n-multiplier (str) -The contract multiplier.\n-currency (str) -Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type\ndict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type\ndict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type\ntuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type\nobject\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nContract",
          "source_file": "pdf_extract.md",
          "line_number": 1987,
          "heading": "class ib_insync.order.PercentChangeCondition(condType: int = 7, conjunction: str = 'a', isMore: bool =",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0122_bbbc6522"
    },
    {
      "cluster_id": "cluster_0122",
      "examples": [
        {
          "id": "ex_0123_bc6f8975",
          "code": "#### class ib_insync.contract.Future(symbol='', lastTradeDateOrContractMonth='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\n\nFuture contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]\n\n\n#### class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)\nContinuous future contract.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **localSymbol** (str) - The contract's symbol within its primary exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type:dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\n*Return type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nFuture",
          "source_file": "pdf_extract.md",
          "line_number": 2179,
          "heading": "class ib_insync.contract.Option(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='',",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0123_bc6f8975"
    },
    {
      "cluster_id": "cluster_0123",
      "examples": [
        {
          "id": "ex_0124_a85b6a7f",
          "code": "class ib_insync.contract.Forex(pair='', exchange='IDEALPRO', symbol='', currency='', **kwargs)\n\nForeign exchange currency pair.\n\n**Parameters:**\n- **pair** (str) - Shortcut for specifying symbol and currency, like 'EURUSD'.\n- **exchange** (str) - Destination exchange.\n- **symbol** (str) - Base currency.\n- **currency** (str) - Quote currency.\n\n pair()\nShort name of pair.\nReturn type: str\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\n Forex",
          "source_file": "pdf_extract.md",
          "line_number": 2242,
          "heading": "class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0125_2b6f6a6e",
          "code": "class ib_insync.contract.Index(symbol='', exchange='', currency='', **kwargs)\n\nIndex.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\n\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nIndex",
          "source_file": "pdf_extract.md",
          "line_number": 2278,
          "heading": "class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0126_d4626d75",
          "code": "class ib_insync.contract.CFD(symbol='', exchange='', currency='', **kwargs)\n\nContract For Difference.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type:** dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type:** object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nCFD",
          "source_file": "pdf_extract.md",
          "line_number": 2309,
          "heading": "class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0127_8675ebd8",
          "code": "class ib_insync.contract.Commodity(symbol='', exchange='', currency='', **kwargs)\n\nCommodity.\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\n#### update(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nCommodity",
          "source_file": "pdf_extract.md",
          "line_number": 2340,
          "heading": "class ib_insync.contract.ContFuture(symbol='', exchange='', localSymbol='', multiplier='', currency='', **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0133_dff73d92",
          "code": "class ib_insync.contract.Crypto(symbol='', exchange='', currency='', **kwargs)\n\nCrypto currency contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **exchange** (str) - Destination exchange.\n- **currency** (str) - Underlying currency.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nCrypto",
          "source_file": "pdf_extract.md",
          "line_number": 2514,
          "heading": "tuple()",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 0.9317881116277391,
      "canonical": "ex_0124_a85b6a7f"
    },
    {
      "cluster_id": "cluster_0124",
      "examples": [
        {
          "id": "ex_0128_45d7fdfc",
          "code": "class ib_insync.contract.Bond(**kwargs)\nBond.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nBond",
          "source_file": "pdf_extract.md",
          "line_number": 2370,
          "heading": "update(*srcObjs, **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0130_970fbdd1",
          "code": "class ib_insync.contract.MutualFund(**kwargs)\n\nMutual fund.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\n---\n#### tuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nMutualFund",
          "source_file": "pdf_extract.md",
          "line_number": 2435,
          "heading": "update(*srcObjs, **kwargs)",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0131_d0953ca2",
          "code": "class ib_insync.contract.Warrant(**kwargs)\n\nWarrant option.\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\n*Return type:** tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nWarrant",
          "source_file": "pdf_extract.md",
          "line_number": 2462,
          "heading": "tuple()",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0132_e65c45ce",
          "code": "class ib_insync.contract.Bag(**kwargs)\n\nBag contract.\n\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type:** tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nBag",
          "source_file": "pdf_extract.md",
          "line_number": 2489,
          "heading": "tuple()",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 0.9665747134198909,
      "canonical": "ex_0128_45d7fdfc"
    },
    {
      "cluster_id": "cluster_0125",
      "examples": [
        {
          "id": "ex_0129_0c947e3f",
          "code": "class ib_insync.contract.FuturesOption(symbol='', lastTradeDateOrContractMonth='', strike=0.0, right='', exchange='', multiplier='', currency='', **kwargs)\n\nOption on a futures contract.\n\n**Parameters:**\n- **symbol** (str) - Symbol name.\n- **lastTradeDateOrContractMonth** (str) - The option's last trading day or contract month.\n  - YYYYMM format: To specify last month\n  - YYYYMMDD format: To specify last trading day\n- **strike** (float) - The option's strike price.\n- **right** (str) - Put or call option. Valid values are 'P', 'PUT', 'C' or 'CALL'.\n- **exchange** (str) - Destination exchange.\n- **multiplier** (str) - The contract multiplier.\n- **currency** (str) - Underlying currency.\n\n dict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type:** dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]",
          "language": "python",
          "context": "\nFuturesOption",
          "source_file": "pdf_extract.md",
          "line_number": 2396,
          "heading": "update(*srcObjs, **kwargs)",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0129_0c947e3f"
    },
    {
      "cluster_id": "cluster_0126",
      "examples": [
        {
          "id": "ex_0134_4bae9046",
          "code": "class ib_insync.contract.TagValue(tag, value)\n\nCreate new instance of TagValue(tag, value)",
          "language": "python",
          "context": "\n TagValue",
          "source_file": "pdf_extract.md",
          "line_number": 2546,
          "heading": "TagValue",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0134_4bae9046"
    },
    {
      "cluster_id": "cluster_0127",
      "examples": [
        {
          "id": "ex_0135_71282853",
          "code": "def onConnected():\n    print(ib.accountValues())\n\nibc = IBC(974, gateway=True, tradingMode='paper')\nib = IB()\nib.connectedEvent += onConnected\nwatchdog = Watchdog(ibc, ib, port=4002)\nwatchdog.start()\nib.run()",
          "language": "python",
          "context": "class ibinsync.ibcontroller.Watchdog(controller: Union[IBC, IBController], ib: IB, host: str =\n'127.0.0.1', port: int = 7497, clientId: int = 1, connectTimeout:\nfloat = 2, appStartupTime: float = 30, ...",
          "source_file": "pdf_extract.md",
          "line_number": 4057,
          "heading": "Watchdog Usage Example",
          "tags": [
            "connect",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0135_71282853"
    },
    {
      "cluster_id": "cluster_0128",
      "examples": [
        {
          "id": "ex_0136_1556d437",
          "code": "import datetime\nfrom ib_insync import *\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\ncontract = Stock('TSLA', 'SMART', 'USD')\ndt = ''\nbarsList = []\nwhile True:\nbars = ib.reqHistoricalData(\ncontract,\nendDateTime=dt,\ndurationStr='10 D',\nbarSizeSetting='1 min',\nwhatToShow='MIDPOINT',\nuseRTH=True,\nformatDate=1)\nif not bars:\nbreak\nbarsList.append(bars)\ndt = bars[0].date\nprint(dt)\n# save to CSV file\nallBars = [b for bars in reversed(barsList) for b in bars]\ndf = util.df(allBars)\ndf.to_csv(contract.symbol + '.csv', index=False)",
          "language": "python",
          "context": " Fetching consecutive historical data",
          "source_file": "pdf_extract.md",
          "line_number": 4116,
          "heading": "Fetching consecutive historical data",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0136_1556d437"
    },
    {
      "cluster_id": "cluster_0129",
      "examples": [
        {
          "id": "ex_0137_80aea104",
          "code": "import asyncio\nimport ib_insync as ibi\n\nclass App:\n    async def run(self):\n        self.ib = ibi.IB()\n        with await self.ib.connectAsync():\n            contracts = [\n                ibi.Stock(symbol, 'SMART', 'USD')\n                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]\n            for contract in contracts:\n                self.ib.reqMktData(contract)\n            async for tickers in self.ib.pendingTickersEvent:\n                for ticker in tickers:\n                    print(ticker)\n\n    def stop(self):\n        self.ib.disconnect()\n\napp = App()\ntry:\n    asyncio.run(app.run())\nexcept (KeyboardInterrupt, SystemExit):\n    app.stop()",
          "language": "python",
          "context": " Async streaming ticks",
          "source_file": "pdf_extract.md",
          "line_number": 4146,
          "heading": "Async streaming ticks",
          "tags": [
            "async",
            "connect",
            "contract",
            "data",
            "error",
            "event"
          ]
        },
        {
          "id": "ex_0147_490b705b",
          "code": "import asyncio\nimport ib_insync as ibi\nclass App:\nasync def run(self):\nself.ib = ibi.IB()\nwith await self.ib.connectAsync():\ncontracts = [\nibi.Stock(symbol, 'SMART', 'USD')\nfor symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]\nfor contract in contracts:\nself.ib.reqMktData(contract)\nasync for tickers in self.ib.pendingTickersEvent:\nfor ticker in tickers:\nprint(ticker)\ndef stop(self):\nself.ib.disconnect()\napp = App()\ntry:\nasyncio.run(app.run())\nexcept (KeyboardInterrupt, SystemExit):\napp.stop()",
          "language": "python",
          "context": " Async streaming ticks",
          "source_file": "pdf_extract.md",
          "line_number": 4292,
          "heading": "Async streaming ticks",
          "tags": [
            "async",
            "connect",
            "contract",
            "data",
            "error",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0137_80aea104"
    },
    {
      "cluster_id": "cluster_0130",
      "examples": [
        {
          "id": "ex_0138_fbdce807",
          "code": "allParams = ib.reqScannerParameters()\nprint(allParams)\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerData(sub)\nprint(scanData)",
          "language": "python",
          "context": " Scanner data (blocking)",
          "source_file": "pdf_extract.md",
          "line_number": 4175,
          "heading": "Scanner data (blocking)",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0138_fbdce807"
    },
    {
      "cluster_id": "cluster_0131",
      "examples": [
        {
          "id": "ex_0139_0058769e",
          "code": "def onScanData(scanData):\nprint(scanData[0])\nprint(len(scanData))\nsub = ScannerSubscription(\ninstrument='FUT.US',\nlocationCode='FUT.CME',\nscanCode='TOP_PERC_GAIN')\nscanData = ib.reqScannerSubscription(sub)\nscanData.updateEvent += onScanData\nib.sleep(60)\nib.cancelScannerSubscription(scanData)",
          "language": "python",
          "context": " Scanner data (streaming)",
          "source_file": "pdf_extract.md",
          "line_number": 4189,
          "heading": "Scanner data (streaming)",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0139_0058769e"
    },
    {
      "cluster_id": "cluster_0132",
      "examples": [
        {
          "id": "ex_0140_c87a4a2c",
          "code": "option = Option('EOE', '20171215', 490, 'P', 'FTA', multiplier=100)\ncalc = ib.calculateImpliedVolatility(\noption, optionPrice=6.1, underPrice=525)\nprint(calc)\ncalc = ib.calculateOptionPrice(\noption, volatility=0.14, underPrice=525)\nprint(calc)",
          "language": "python",
          "context": " Option calculations",
          "source_file": "pdf_extract.md",
          "line_number": 4206,
          "heading": "Option calculations",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0140_c87a4a2c"
    },
    {
      "cluster_id": "cluster_0133",
      "examples": [
        {
          "id": "ex_0141_8522063f",
          "code": "eurusd = Forex('EURUSD')\nticker = ib.reqMktDepth(eurusd)\nwhile ib.sleep(5):\nprint(\n[d.price for d in ticker.domBids],\n[d.price for d in ticker.domAsks])",
          "language": "python",
          "context": " Order book",
          "source_file": "pdf_extract.md",
          "line_number": 4219,
          "heading": "Order book",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0141_8522063f"
    },
    {
      "cluster_id": "cluster_0134",
      "examples": [
        {
          "id": "ex_0142_c7128665",
          "code": "usdjpy = Forex('USDJPY')\ncd = ib.reqContractDetails(usdjpy)[0]\nprint(cd.marketRuleIds)\nrules = [\nib.reqMarketRule(ruleId)\nfor ruleId in cd.marketRuleIds.split(',')]\nprint(rules)",
          "language": "python",
          "context": " Minimum price increments",
          "source_file": "pdf_extract.md",
          "line_number": 4231,
          "heading": "Minimum price increments",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0142_c7128665"
    },
    {
      "cluster_id": "cluster_0135",
      "examples": [
        {
          "id": "ex_0143_2e49e4f1",
          "code": "newsProviders = ib.reqNewsProviders()\nprint(newsProviders)\ncodes = '+'.join(np.code for np in newsProviders)\namd = Stock('AMD', 'SMART', 'USD')\nib.qualifyContracts(amd)\nheadlines = ib.reqHistoricalNews(amd.conId, codes, '', '', 10)\nlatest = headlines[0]\nprint(latest)\narticle = ib.reqNewsArticle(latest.providerCode, latest.articleId)\nprint(article",
          "language": "python",
          "context": " News articles",
          "source_file": "pdf_extract.md",
          "line_number": 4244,
          "heading": "News articles",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0143_2e49e4f1"
    },
    {
      "cluster_id": "cluster_0136",
      "examples": [
        {
          "id": "ex_0144_a855e3c4",
          "code": "ib.reqNewsBulletins(True)\nib.sleep(5)\nprint(ib.newsBulletins())",
          "language": "python",
          "context": " News bulletins",
          "source_file": "pdf_extract.md",
          "line_number": 4260,
          "heading": "News bulletins",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0144_a855e3c4"
    },
    {
      "cluster_id": "cluster_0137",
      "examples": [
        {
          "id": "ex_0145_6124bc35",
          "code": "contract = Stock('INTC', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '456')\nib.sleep(2)\nprint(ticker.dividends)\nOutput:\nDividends(past12Months=1.2, next12Months=1.2, nextDate=datetime.date(2019, 2, 6),\u2423\nnextAmount=0.3)",
          "language": "python",
          "context": " Dividends",
          "source_file": "pdf_extract.md",
          "line_number": 4269,
          "heading": "Dividends",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0145_6124bc35"
    },
    {
      "cluster_id": "cluster_0138",
      "examples": [
        {
          "id": "ex_0146_ac20163f",
          "code": "contract = Stock('IBM', 'SMART', 'USD')\nticker = ib.reqMktData(contract, '258')\nib.sleep(2)\nprint(ticker.fundamentalRatios)",
          "language": "python",
          "context": " Fundamental ratios",
          "source_file": "pdf_extract.md",
          "line_number": 4282,
          "heading": "Fundamental ratios",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0146_ac20163f"
    },
    {
      "cluster_id": "cluster_0139",
      "examples": [
        {
          "id": "ex_0148_f2fd5bf4",
          "code": "class TkApp:\n    \"\"\"\n    Example of integrating with Tkinter.\n    \"\"\"\n    def __init__(self):\n        self.ib = IB().connect()\n        self.root = tk.Tk()\n        self.root.protocol('WM_DELETE_WINDOW', self._onDeleteWindow)\n        self.entry = tk.Entry(self.root, width=50)\n        self.entry.insert(0, \"Stock('TSLA', 'SMART', 'USD')\")\n        self.entry.grid()\n        self.button = tk.Button(\n            self.root, text='Get details', command=self.onButtonClick)\n        self.button.grid()\n        self.text = tk.Text(self.root)\n        self.text.grid()\n        self.loop = util.getLoop()\n\n    def onButtonClick(self):\n        contract = eval(self.entry.get())\n        cds = self.ib.reqContractDetails(contract)\n        self.text.delete(1.0, tk.END)\n        self.text.insert(tk.END, str(cds))\n\n    def run(self):\n        self._onTimeout()\n        self.loop.run_forever()\n\n    def _onTimeout(self):\n        self.root.update()\n        self.loop.call_later(0.03, self._onTimeout)\n\n    def _onDeleteWindow(self):\n        self.loop.stop()\n\n\napp = TkApp()\napp.run()",
          "language": "python",
          "context": " Integration with Tkinter",
          "source_file": "pdf_extract.md",
          "line_number": 4319,
          "heading": "Integration with Tkinter",
          "tags": [
            "connect",
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0148_f2fd5bf4"
    },
    {
      "cluster_id": "cluster_0140",
      "examples": [
        {
          "id": "ex_0149_9e42986f",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Order triggers when SPY hits 450\ncontract = Stock('AAPL', 'SMART', 'USD')\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\n\n# Qualify both\ncontract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)\n\n# Create price condition\ncondition = PriceCondition(\n    condType=1,  # Price\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # True = above, False = below\n    price=450.0\n)\n\n# Create order with condition\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False\n\ntrade = ib.placeOrder(contract, order)\nprint(f\"Conditional order placed: {trade.order.orderId}\")",
          "language": "python",
          "context": " Price-Based Condition",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 31,
          "heading": "Price-Based Condition",
          "tags": [
            "connect",
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0149_9e42986f"
    },
    {
      "cluster_id": "cluster_0141",
      "examples": [
        {
          "id": "ex_0150_43324d28",
          "code": "from datetime import datetime, timedelta\n\n# Order triggers at specific time\ntime_condition = TimeCondition(\n    condType=3,  # Time\n    isMore=True,\n    time=datetime.now() + timedelta(hours=1)\n)\n\norder = MarketOrder('BUY', 100)\norder.conditions = [time_condition]\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Time-Based Condition",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 64,
          "heading": "Time-Based Condition",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0150_43324d28"
    },
    {
      "cluster_id": "cluster_0142",
      "examples": [
        {
          "id": "ex_0151_5d2c3705",
          "code": "# Trigger when daily volume exceeds threshold\nvolume_condition = VolumeCondition(\n    condType=4,  # Volume\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=10000000  # 10M shares\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [volume_condition]\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Volume-Based Condition",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 80,
          "heading": "Volume-Based Condition",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0151_5d2c3705"
    },
    {
      "cluster_id": "cluster_0143",
      "examples": [
        {
          "id": "ex_0152_4ec34ae3",
          "code": "# Order triggers when BOTH conditions met\nprice_cond = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,\n    price=450.0\n)\n\nvolume_cond = VolumeCondition(\n    condType=4,\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=5000000\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [price_cond, volume_cond]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False  # False = AND, True = OR\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Multiple Conditions (AND/OR)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 96,
          "heading": "Multiple Conditions (AND/OR)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0152_4ec34ae3"
    },
    {
      "cluster_id": "cluster_0144",
      "examples": [
        {
          "id": "ex_0154_22d3f273",
          "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.auxPrice = 5.0  # Trail by $5\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Trailing Stop Loss (Fixed Amount)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 137,
          "heading": "Trailing Stop Loss (Fixed Amount)",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0155_6b1a9a90",
          "code": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL LIMIT'\norder.lmtPriceOffset = 0.50  # Limit $0.50 below trail\norder.trailingPercent = 2.0\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Trailing Stop Limit",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 149,
          "heading": "Trailing Stop Limit",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0156_50051a29",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'PEG MID'\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Pegged to Market (Midpoint)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 164,
          "heading": "Pegged to Market (Midpoint)",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0157_92bd3785",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'PEG BEST'\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Pegged to Best Bid/Ask",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 175,
          "heading": "Pegged to Best Bid/Ask",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0158_e5fd845a",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'REL'\norder.lmtPrice = 0.10  # $0.10 above best bid\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Relative Order (Offset from NBBO)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 186,
          "heading": "Relative Order (Offset from NBBO)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.8874733421665896,
      "canonical": "ex_0154_22d3f273"
    },
    {
      "cluster_id": "cluster_0145",
      "examples": [
        {
          "id": "ex_0159_02a55978",
          "code": "# Buy at market, then set multiple exit strategies\nentry_order = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry_order)\n\n# Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    # Create OCA group for exits\n    oca_group = f\"OCA_{int(time.time())}\"\n    \n    # Exit 1: Take profit at +5%\n    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)\n    exit1.ocaGroup = oca_group\n    exit1.ocaType = 1  # Cancel all on fill\n    \n    # Exit 2: Stop loss at -2%\n    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)\n    exit2.ocaGroup = oca_group\n    exit2.ocaType = 1\n    \n    # Exit 3: Trailing stop\n    exit3 = Order()\n    exit3.action = 'SELL'\n    exit3.totalQuantity = 100\n    exit3.orderType = 'TRAIL'\n    exit3.trailingPercent = 3.0\n    exit3.ocaGroup = oca_group\n    exit3.ocaType = 1\n    \n    for order in [exit1, exit2, exit3]:\n        ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Multiple Exits from Same Entry",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 200,
          "heading": "Multiple Exits from Same Entry",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0159_02a55978"
    },
    {
      "cluster_id": "cluster_0146",
      "examples": [
        {
          "id": "ex_0161_c633d4e2",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Vwap'\norder.algoParams = [\n    TagValue('maxPctVol', '0.1'),  # Max 10% of volume\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1'),\n    TagValue('noTakeLiq', '1')\n]\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " VWAP (Volume-Weighted Average Price)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 259,
          "heading": "VWAP (Volume-Weighted Average Price)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0161_c633d4e2"
    },
    {
      "cluster_id": "cluster_0147",
      "examples": [
        {
          "id": "ex_0162_40a89498",
          "code": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 1000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Adaptive'\norder.algoParams = [\n    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient\n]\n\ntrade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Adaptive (IB's Smart Routing)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 280,
          "heading": "Adaptive (IB's Smart Routing)",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0162_40a89498"
    },
    {
      "cluster_id": "cluster_0148",
      "examples": [
        {
          "id": "ex_0163_f6b52c88",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Define legs\nbuy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\n# Qualify\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\n# Create combo contract\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\n# Define legs\nleg1 = ComboLeg()\nleg1.conId = buy_call.conId\nleg1.ratio = 1\nleg1.action = 'BUY'\nleg1.exchange = 'SMART'\n\nleg2 = ComboLeg()\nleg2.conId = sell_call.conId\nleg2.ratio = 1\nleg2.action = 'SELL'\nleg2.exchange = 'SMART'\n\ncombo.comboLegs = [leg1, leg2]\n\n# Place order\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50\ntrade = ib.placeOrder(combo, order)",
          "language": "python",
          "context": " Vertical Spread (Bull Call Spread)",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 301,
          "heading": "Vertical Spread (Bull Call Spread)",
          "tags": [
            "connect",
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0163_f6b52c88"
    },
    {
      "cluster_id": "cluster_0149",
      "examples": [
        {
          "id": "ex_0164_57cd3283",
          "code": "# Four-leg strategy: sell OTM call spread + sell OTM put spread\nbuy_call = Option('SPY', '20240315', 470, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 465, 'C', 'SMART')\nbuy_put = Option('SPY', '20240315', 430, 'P', 'SMART')\nsell_put = Option('SPY', '20240315', 435, 'P', 'SMART')\n\n# Qualify all\ncontracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)\n\n# Create BAG\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put\n    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put\n]\n\n# Place as credit spread\norder = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit\ntrade = ib.placeOrder(combo, order)",
          "language": "python",
          "context": " Iron Condor",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 342,
          "heading": "Iron Condor",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0165_ccb0bf34",
          "code": "# Buy 1 ITM call, Sell 2 ATM calls, Buy 1 OTM call\nlower_call = Option('SPY', '20240315', 440, 'C', 'SMART')\nmiddle_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nupper_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\ncontracts = ib.qualifyContracts(lower_call, middle_call, upper_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=contracts[1].conId, ratio=2, action='SELL', exchange='SMART'),  # 2x middle\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),\n]\n\norder = LimitOrder('BUY', 10, 1.50)\ntrade = ib.placeOrder(combo, order)",
          "language": "python",
          "context": " Butterfly Spread",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 372,
          "heading": "Butterfly Spread",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 0.8510462197643052,
      "canonical": "ex_0164_57cd3283"
    },
    {
      "cluster_id": "cluster_0150",
      "examples": [
        {
          "id": "ex_0167_405955a3",
          "code": "# Dynamic delta hedging for options position\ndef calculate_position_delta(portfolio):\n    \"\"\"Calculate total portfolio delta\"\"\"\n    total_delta = 0.0\n    \n    for item in portfolio:\n        if item.contract.secType == 'OPT':\n            # Request option computations\n            ticker = ib.reqMktData(item.contract, '', False, False)\n            ib.sleep(1)\n            \n            if ticker.modelGreeks:\n                delta = ticker.modelGreeks.delta\n                total_delta += delta * item.position\n            \n            ib.cancelMktData(item.contract)\n    \n    return total_delta\n\ndef hedge_delta(underlying_contract, target_delta=0.0):\n    \"\"\"Adjust underlying position to achieve target delta\"\"\"\n    portfolio = ib.portfolio()\n    current_delta = calculate_position_delta(portfolio)\n    \n    delta_to_hedge = current_delta - target_delta\n    \n    if abs(delta_to_hedge) > 0.1:  # Threshold\n        # Delta of stock is 1.0\n        shares_to_trade = int(delta_to_hedge * 100)  # Per contract\n        \n        if shares_to_trade > 0:\n            order = MarketOrder('SELL', abs(shares_to_trade))\n        else:\n            order = MarketOrder('BUY', abs(shares_to_trade))\n        \n        trade = ib.placeOrder(underlying_contract, order)\n        print(f\"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}\")\n        \n        return trade\n    else:\n        print(f\"Delta within tolerance: {current_delta:.2f}\")\n        return None\n\n# Run periodically\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\nwhile True:\n    hedge_delta(underlying, target_delta=0.0)\n    ib.sleep(300)  # Every 5 minutes",
          "language": "python",
          "context": " Delta Hedging Pattern",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 420,
          "heading": "Delta Hedging Pattern",
          "tags": [
            "contract",
            "data",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0167_405955a3"
    },
    {
      "cluster_id": "cluster_0151",
      "examples": [
        {
          "id": "ex_0168_01a3894d",
          "code": "from ib_insync import *\nimport logging\n\nclass IBErrorHandler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.error_log = []\n        self.ib.errorEvent += self.on_error\n        \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Centralized error handling\"\"\"\n        error_info = {\n            'time': datetime.now(),\n            'reqId': reqId,\n            'code': errorCode,\n            'message': errorString,\n            'contract': contract\n        }\n        self.error_log.append(error_info)\n        \n        # Categorize and handle\n        if errorCode in [502, 503, 504]:\n            self.handle_connection_error(errorCode, errorString)\n        elif errorCode in [200, 201, 202]:\n            self.handle_order_error(errorCode, errorString, contract)\n        elif errorCode == 162:\n            self.handle_data_error(errorCode, errorString, contract)\n        elif errorCode == 354:\n            self.handle_market_data_subscription_error(errorCode, errorString)\n        elif errorCode in [2104, 2106, 2158]:\n            # Info messages - ignore\n            pass\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def handle_connection_error(self, code, message):\n        \"\"\"Handle connection failures\"\"\"\n        logging.critical(f\"Connection error {code}: {message}\")\n        # Trigger reconnection\n        self.schedule_reconnect()\n    \n    def handle_order_error(self, code, message, contract):\n        \"\"\"Handle order rejections\"\"\"\n        logging.error(f\"Order error {code}: {message} for {contract}\")\n        # Could retry with modified params\n        # Or alert user\n    \n    def handle_data_error(self, code, message, contract):\n        \"\"\"Handle data request failures\"\"\"\n        logging.warning(f\"Data error {code}: {message} for {contract}\")\n        # Retry with different params\n    \n    def handle_market_data_subscription_error(self, code, message):\n        \"\"\"Handle market data subscription issues\"\"\"\n        logging.warning(f\"Market data error {code}: {message}\")\n        # Fall back to delayed data\n        self.ib.reqMarketDataType(3)  # Delayed\n    \n    def schedule_reconnect(self):\n        \"\"\"Schedule reconnection attempt\"\"\"\n        # Implementation in reconnection section\n        pass\n\n# Usage\nib = IB()\nerror_handler = IBErrorHandler(ib)\nib.connect('127.0.0.1', 7497, clientId=1)",
          "language": "python",
          "context": " Comprehensive Error Handler",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 478,
          "heading": "Comprehensive Error Handler",
          "tags": [
            "connect",
            "contract",
            "error",
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0168_01a3894d"
    },
    {
      "cluster_id": "cluster_0152",
      "examples": [
        {
          "id": "ex_0169_53f05d1d",
          "code": "def validate_order(ib, contract, order):\n    \"\"\"Validate order before placing\"\"\"\n    errors = []\n    \n    # 1. Check contract is qualified\n    if contract.conId == 0:\n        errors.append(\"Contract not qualified\")\n    \n    # 2. Check buying power\n    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}\n    \n    if order.action == 'BUY':\n        # Estimate cost\n        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot\n        ib.sleep(1)\n        \n        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN\n            estimated_cost = ticker.ask * order.totalQuantity\n            if estimated_cost > account_values.get('BuyingPower', 0):\n                errors.append(f\"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}\")\n        \n        ib.cancelMktData(contract)\n    \n    # 3. What-if order check\n    try:\n        order_copy = Order(**{k: v for k, v in order.__dict__.items()})\n        order_copy.whatIf = True\n        \n        orderState = ib.whatIfOrder(contract, order_copy)\n        \n        if orderState.commission and orderState.commission > 0:\n            # Valid response\n            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):\n                errors.append(\"Insufficient margin\")\n        else:\n            errors.append(\"What-if order returned invalid state\")\n            \n    except Exception as e:\n        errors.append(f\"What-if validation failed: {e}\")\n    \n    # 4. Check trading hours\n    details = ib.reqContractDetails(contract)\n    if details:\n        # Parse trading hours (simplified)\n        # Would need full implementation\n        pass\n    \n    return errors\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\norder = LimitOrder('BUY', 1000, 175.0)\n\nvalidation_errors = validate_order(ib, contract, order)\nif validation_errors:\n    print(\"Order validation failed:\")\n    for error in validation_errors:\n        print(f\"  - {error}\")\nelse:\n    trade = ib.placeOrder(contract, order)\n    print(\"Order placed successfully\")",
          "language": "python",
          "context": " Order Validation Before Submission",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 549,
          "heading": "Order Validation Before Submission",
          "tags": [
            "contract",
            "data",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0169_53f05d1d"
    },
    {
      "cluster_id": "cluster_0153",
      "examples": [
        {
          "id": "ex_0170_11393855",
          "code": "import time\nfrom functools import wraps\n\ndef retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):\n    \"\"\"Decorator for retrying failed operations\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            retries = 0\n            delay = base_delay\n            \n            while retries < max_retries:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    retries += 1\n                    if retries >= max_retries:\n                        logging.error(f\"{func.__name__} failed after {max_retries} retries: {e}\")\n                        raise\n                    \n                    logging.warning(f\"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n                    delay = min(delay * 2, max_delay)  # Exponential backoff\n            \n        return wrapper\n    return decorator\n\n# Usage\n@retry_with_backoff(max_retries=3, base_delay=2.0)\ndef place_order_with_retry(ib, contract, order):\n    \"\"\"Place order with automatic retry\"\"\"\n    trade = ib.placeOrder(contract, order)\n    \n    # Wait for submission\n    timeout = 10\n    start = time.time()\n    while trade.orderStatus.status in ['PendingSubmit', '']:\n        if time.time() - start > timeout:\n            raise TimeoutError(\"Order submission timeout\")\n        ib.sleep(0.1)\n    \n    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:\n        raise Exception(f\"Order cancelled: {trade.orderStatus.status}\")\n    \n    return trade\n\n# Usage\ntry:\n    trade = place_order_with_retry(ib, contract, order)\n    print(f\"Order placed: {trade.order.orderId}\")\nexcept Exception as e:\n    print(f\"Order failed: {e}\")",
          "language": "python",
          "context": " Retry Logic with Exponential Backoff",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 615,
          "heading": "Retry Logic with Exponential Backoff",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0170_11393855"
    },
    {
      "cluster_id": "cluster_0154",
      "examples": [
        {
          "id": "ex_0171_130315a8",
          "code": "class PositionManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.expected_positions = {}  # conId -> quantity\n        \n    def record_trade(self, trade):\n        \"\"\"Record expected position change\"\"\"\n        if trade.orderStatus.status == 'Filled':\n            conId = trade.contract.conId\n            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()\n            \n            if conId in self.expected_positions:\n                self.expected_positions[conId] += qty\n            else:\n                self.expected_positions[conId] = qty\n    \n    def reconcile(self):\n        \"\"\"Check actual vs expected positions\"\"\"\n        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}\n        \n        discrepancies = []\n        \n        # Check expected positions\n        for conId, expected_qty in self.expected_positions.items():\n            actual_qty = actual_positions.get(conId, 0)\n            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': expected_qty,\n                    'actual': actual_qty,\n                    'diff': actual_qty - expected_qty\n                })\n        \n        # Check for unexpected positions\n        for conId, actual_qty in actual_positions.items():\n            if conId not in self.expected_positions and abs(actual_qty) > 0.01:\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': 0,\n                    'actual': actual_qty,\n                    'diff': actual_qty\n                })\n        \n        if discrepancies:\n            logging.warning(f\"Position discrepancies found: {discrepancies}\")\n        \n        return discrepancies\n    \n    def reset_tracking(self):\n        \"\"\"Reset to current positions\"\"\"\n        self.expected_positions = {\n            p.contract.conId: p.position \n            for p in self.ib.positions()\n        }\n\n# Usage\npm = PositionManager(ib)\npm.reset_tracking()\n\n# Track trades\nib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)\n\n# Periodic reconciliation\nwhile True:\n    discrepancies = pm.reconcile()\n    if discrepancies:\n        # Alert or take action\n        pass\n    ib.sleep(60)",
          "language": "python",
          "context": " Position Reconciliation",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 675,
          "heading": "Position Reconciliation",
          "tags": [
            "contract",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0171_130315a8"
    },
    {
      "cluster_id": "cluster_0155",
      "examples": [
        {
          "id": "ex_0172_de7fe994",
          "code": "def close_all_positions(ib, exclude_symbols=None):\n    \"\"\"Emergency position closer\"\"\"\n    exclude_symbols = exclude_symbols or []\n    \n    positions = ib.positions()\n    trades = []\n    \n    for position in positions:\n        symbol = position.contract.symbol\n        \n        if symbol in exclude_symbols:\n            continue\n        \n        qty = abs(position.position)\n        action = 'SELL' if position.position > 0 else 'BUY'\n        \n        order = MarketOrder(action, qty)\n        trade = ib.placeOrder(position.contract, order)\n        trades.append(trade)\n        \n        print(f\"Closing {action} {qty} {symbol}\")\n    \n    # Wait for all to fill\n    timeout = 30\n    start = time.time()\n    \n    while any(not t.isDone() for t in trades):\n        if time.time() - start > timeout:\n            logging.error(\"Timeout waiting for position closures\")\n            break\n        ib.sleep(0.5)\n    \n    return trades\n\n# Usage - emergency exit\nif emergency_condition:\n    close_all_positions(ib)",
          "language": "python",
          "context": " Close All Positions",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 748,
          "heading": "Close All Positions",
          "tags": [
            "contract",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0172_de7fe994"
    },
    {
      "cluster_id": "cluster_0156",
      "examples": [
        {
          "id": "ex_0173_6fdd48c4",
          "code": "def calculate_position_size(\n    ib,\n    contract,\n    risk_per_trade_pct=0.02,  # 2% risk\n    stop_loss_pct=0.05         # 5% stop\n):\n    \"\"\"Calculate position size based on risk\"\"\"\n    \n    # Get account value\n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    # Calculate dollar risk\n    dollar_risk = net_liq * risk_per_trade_pct\n    \n    # Get current price\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if not ticker.last or ticker.last != ticker.last:  # NaN check\n        logging.error(\"Unable to get price for position sizing\")\n        return 0\n    \n    price = ticker.last\n    ib.cancelMktData(contract)\n    \n    # Calculate shares\n    # dollar_risk = shares * price * stop_loss_pct\n    shares = dollar_risk / (price * stop_loss_pct)\n    \n    # Round to nearest tradeable lot\n    if contract.secType == 'OPT':\n        shares = int(shares / 100) * 100  # Options in contracts (100 shares)\n    else:\n        shares = int(shares)\n    \n    print(f\"Position size for {contract.symbol}: {shares} shares\")\n    print(f\"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})\")\n    \n    return shares\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nshares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)\n\nif shares > 0:\n    order = LimitOrder('BUY', shares, 175.0)\n    trade = ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Position Size Calculator",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 789,
          "heading": "Position Size Calculator",
          "tags": [
            "contract",
            "data",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0173_6fdd48c4"
    },
    {
      "cluster_id": "cluster_0157",
      "examples": [
        {
          "id": "ex_0174_7b2a453d",
          "code": "class DailyLossLimiter:\n    def __init__(self, ib, max_daily_loss_pct=0.05):\n        self.ib = ib\n        self.max_daily_loss_pct = max_daily_loss_pct\n        self.start_equity = None\n        self.breached = False\n        \n    def initialize(self):\n        \"\"\"Set starting equity for the day\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        self.breached = False\n        print(f\"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}\")\n    \n    def check_limit(self):\n        \"\"\"Check if daily loss limit breached\"\"\"\n        if self.breached:\n            return True\n        \n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            self.breached = True\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)\")\n            return True\n        \n        return False\n    \n    def enforce(self):\n        \"\"\"Close all positions and cancel all orders\"\"\"\n        if not self.breached:\n            return\n        \n        print(\"Enforcing daily loss limit...\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        close_all_positions(self.ib)\n        \n        print(\"All positions closed. Trading halted for the day.\")\n\n# Usage\nlimiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit\nlimiter.initialize()\n\n# Check periodically\nwhile True:\n    if limiter.check_limit():\n        limiter.enforce()\n        break\n    ib.sleep(60)",
          "language": "python",
          "context": " Daily Loss Limit",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 847,
          "heading": "Daily Loss Limit",
          "tags": [
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0174_7b2a453d"
    },
    {
      "cluster_id": "cluster_0158",
      "examples": [
        {
          "id": "ex_0175_d2cf5153",
          "code": "def check_position_concentration(ib, max_position_pct=0.20):\n    \"\"\"Ensure no single position exceeds % of portfolio\"\"\"\n    \n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    violations = []\n    \n    for item in ib.portfolio():\n        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0\n        \n        if position_pct > max_position_pct:\n            violations.append({\n                'symbol': item.contract.symbol,\n                'value': item.marketValue,\n                'pct': position_pct,\n                'limit': max_position_pct\n            })\n    \n    if violations:\n        logging.warning(f\"Position concentration violations: {violations}\")\n    \n    return violations\n\n# Check before placing order\ndef place_order_with_concentration_check(ib, contract, order, max_pct=0.20):\n    \"\"\"Place order only if it doesn't violate concentration\"\"\"\n    \n    # Estimate new position value\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if ticker.ask:\n        estimated_value = ticker.ask * order.totalQuantity\n        \n        account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        # Get current position\n        current_position = next(\n            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),\n            0\n        )\n        \n        new_position_value = abs(current_position + estimated_value)\n        new_pct = new_position_value / net_liq if net_liq > 0 else 0\n        \n        if new_pct > max_pct:\n            logging.error(f\"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%\")\n            ib.cancelMktData(contract)\n            return None\n    \n    ib.cancelMktData(contract)\n    return ib.placeOrder(contract, order)",
          "language": "python",
          "context": " Max Position Concentration",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 908,
          "heading": "Max Position Concentration",
          "tags": [
            "contract",
            "data",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0175_d2cf5153"
    },
    {
      "cluster_id": "cluster_0159",
      "examples": [
        {
          "id": "ex_0176_65541a5c",
          "code": "import numpy as np\nimport pandas as pd\n\ndef calculate_portfolio_correlation_risk(ib, lookback_days=30):\n    \"\"\"Calculate portfolio correlation matrix\"\"\"\n    \n    portfolio = ib.portfolio()\n    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']\n    \n    # Get historical data for all positions\n    price_data = {}\n    \n    for symbol in symbols:\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = ib.qualifyContracts(contract)[0]\n        \n        bars = ib.reqHistoricalData(\n            contract,\n            endDateTime='',\n            durationStr=f'{lookback_days} D',\n            barSizeSetting='1 day',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if bars:\n            price_data[symbol] = [bar.close for bar in bars]\n    \n    # Create DataFrame\n    df = pd.DataFrame(price_data)\n    \n    # Calculate returns\n    returns = df.pct_change().dropna()\n    \n    # Correlation matrix\n    corr_matrix = returns.corr()\n    \n    # Identify highly correlated pairs\n    high_corr_threshold = 0.7\n    high_corr_pairs = []\n    \n    for i in range(len(corr_matrix.columns)):\n        for j in range(i+1, len(corr_matrix.columns)):\n            corr = corr_matrix.iloc[i, j]\n            if abs(corr) > high_corr_threshold:\n                high_corr_pairs.append({\n                    'symbol1': corr_matrix.columns[i],\n                    'symbol2': corr_matrix.columns[j],\n                    'correlation': corr\n                })\n    \n    if high_corr_pairs:\n        logging.warning(f\"High correlation detected: {high_corr_pairs}\")\n    \n    return corr_matrix, high_corr_pairs\n\n# Usage\ncorr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)\nprint(\"Portfolio Correlation Matrix:\")\nprint(corr_matrix)",
          "language": "python",
          "context": " Correlation-Based Risk",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 966,
          "heading": "Correlation-Based Risk",
          "tags": [
            "contract",
            "data",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0176_65541a5c"
    },
    {
      "cluster_id": "cluster_0160",
      "examples": [
        {
          "id": "ex_0177_8748cfe5",
          "code": "class ReconnectionManager:\n    def __init__(self, host='127.0.0.1', port=7497, clientId=1):\n        self.host = host\n        self.port = port\n        self.clientId = clientId\n        self.ib = None\n        self.reconnect_attempts = 0\n        self.max_reconnect_attempts = 10\n        self.reconnect_delay = 5\n        self.is_connected = False\n        \n    def connect(self):\n        \"\"\"Initial connection with reconnect logic\"\"\"\n        while self.reconnect_attempts < self.max_reconnect_attempts:\n            try:\n                self.ib = IB()\n                self.ib.disconnectedEvent += self.on_disconnect\n                self.ib.errorEvent += self.on_error\n                \n                self.ib.connect(\n                    self.host,\n                    self.port,\n                    self.clientId,\n                    timeout=10\n                )\n                \n                self.is_connected = True\n                self.reconnect_attempts = 0\n                logging.info(f\"Connected to TWS at {self.host}:{self.port}\")\n                \n                # Restore subscriptions\n                self.restore_state()\n                \n                return self.ib\n                \n            except Exception as e:\n                self.reconnect_attempts += 1\n                logging.error(f\"Connection attempt {self.reconnect_attempts} failed: {e}\")\n                \n                if self.reconnect_attempts >= self.max_reconnect_attempts:\n                    logging.critical(\"Max reconnection attempts reached. Giving up.\")\n                    raise\n                \n                logging.info(f\"Retrying in {self.reconnect_delay} seconds...\")\n                time.sleep(self.reconnect_delay)\n                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        self.is_connected = False\n        logging.warning(\"Disconnected from TWS. Attempting reconnect...\")\n        \n        # Save current state\n        self.save_state()\n        \n        # Attempt reconnection\n        self.connect()\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle connection errors\"\"\"\n        if errorCode in [502, 503, 504, 1100, 1101, 1102]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n            if not self.is_connected:\n                self.on_disconnect()\n    \n    def save_state(self):\n        \"\"\"Save subscriptions and state before disconnect\"\"\"\n        if not self.ib:\n            return\n        \n        # Save tickers\n        self.saved_tickers = [\n            (ticker.contract, ticker.genericTickList) \n            for ticker in self.ib.tickers()\n        ]\n        \n        # Save positions (for monitoring)\n        self.saved_positions = [\n            (p.contract, p.position) \n            for p in self.ib.positions()\n        ]\n        \n        logging.info(f\"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions\")\n    \n    def restore_state(self):\n        \"\"\"Restore subscriptions after reconnect\"\"\"\n        if not hasattr(self, 'saved_tickers'):\n            return\n        \n        logging.info(\"Restoring market data subscriptions...\")\n        \n        # Resubscribe to tickers\n        for contract, genericTickList in self.saved_tickers:\n            try:\n                self.ib.reqMktData(contract, genericTickList, False, False)\n            except Exception as e:\n                logging.error(f\"Failed to restore ticker {contract.symbol}: {e}\")\n        \n        logging.info(\"State restored\")\n\n# Usage\nconn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)\nib = conn_mgr.connect()\n\n# Normal trading operations\n# Connection will auto-reconnect on failure",
          "language": "python",
          "context": " Auto-Reconnect Manager",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1034,
          "heading": "Auto-Reconnect Manager",
          "tags": [
            "connect",
            "contract",
            "data",
            "error",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0177_8748cfe5"
    },
    {
      "cluster_id": "cluster_0161",
      "examples": [
        {
          "id": "ex_0178_7a9e424a",
          "code": "class HeartbeatMonitor:\n    def __init__(self, ib, timeout=60):\n        self.ib = ib\n        self.timeout = timeout\n        self.last_update = time.time()\n        self.ib.updateEvent += self.on_update\n        \n    def on_update(self):\n        \"\"\"Reset timer on any update\"\"\"\n        self.last_update = time.time()\n    \n    def check(self):\n        \"\"\"Check if connection is alive\"\"\"\n        elapsed = time.time() - self.last_update\n        \n        if elapsed > self.timeout:\n            logging.warning(f\"No updates for {elapsed:.0f}s. Connection may be dead.\")\n            return False\n        \n        return True\n    \n    def run(self):\n        \"\"\"Run heartbeat check loop\"\"\"\n        while True:\n            if not self.check():\n                logging.error(\"Heartbeat timeout. Triggering reconnect...\")\n                # Trigger reconnection\n                break\n            \n            time.sleep(10)\n\n# Usage\nheartbeat = HeartbeatMonitor(ib, timeout=60)\n# Run in separate thread or async task",
          "language": "python",
          "context": " Heartbeat Monitor",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1144,
          "heading": "Heartbeat Monitor",
          "tags": [
            "async",
            "connect",
            "error",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0178_7a9e424a"
    },
    {
      "cluster_id": "cluster_0162",
      "examples": [
        {
          "id": "ex_0179_0c5a4c2d",
          "code": "class PortfolioRebalancer:\n    def __init__(self, ib):\n        self.ib = ib\n        \n    def rebalance_to_target(self, target_allocations, tolerance=0.05):\n        \"\"\"\n        Rebalance portfolio to target allocations\n        \n        Args:\n            target_allocations: Dict[symbol: str, target_pct: float]\n                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}\n            tolerance: Rebalance threshold (0.05 = 5%)\n        \"\"\"\n        \n        # Validate target allocations\n        total = sum(target_allocations.values())\n        if abs(total - 1.0) > 0.01:\n            raise ValueError(f\"Target allocations must sum to 1.0, got {total}\")\n        \n        # Get current portfolio\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}\n        \n        # Calculate current allocations\n        current_allocations = {\n            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)\n            for symbol, item in portfolio.items()\n        }\n        \n        # Determine needed trades\n        trades_needed = []\n        \n        for symbol, target_pct in target_allocations.items():\n            current_pct = current_allocations.get(symbol, 0)\n            diff = target_pct - current_pct\n            \n            if abs(diff) > tolerance:\n                target_value = net_liq * target_pct\n                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0\n                value_change = target_value - current_value\n                \n                # Get current price\n                contract = Stock(symbol, 'SMART', 'USD')\n                contract = self.ib.qualifyContracts(contract)[0]\n                \n                ticker = self.ib.reqMktData(contract, '', True, False)\n                self.ib.sleep(1)\n                \n                if ticker.last and ticker.last == ticker.last:\n                    price = ticker.last\n                    shares_change = int(value_change / price)\n                    \n                    if shares_change != 0:\n                        trades_needed.append({\n                            'symbol': symbol,\n                            'contract': contract,\n                            'current_pct': current_pct,\n                            'target_pct': target_pct,\n                            'shares': shares_change,\n                            'action': 'BUY' if shares_change > 0 else 'SELL'\n                        })\n                \n                self.ib.cancelMktData(contract)\n        \n        # Execute trades\n        if not trades_needed:\n            logging.info(\"Portfolio within tolerance. No rebalancing needed.\")\n            return []\n        \n        logging.info(f\"Rebalancing {len(trades_needed)} positions...\")\n        placed_trades = []\n        \n        for trade_info in trades_needed:\n            logging.info(f\"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} \"\n                        f\"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)\")\n            \n            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))\n            trade = self.ib.placeOrder(trade_info['contract'], order)\n            placed_trades.append(trade)\n        \n        return placed_trades\n\n# Usage\ntarget = {\n    'AAPL': 0.30,\n    'GOOGL': 0.30,\n    'MSFT': 0.40\n}\n\nrebalancer = PortfolioRebalancer(ib)\ntrades = rebalancer.rebalance_to_target(target, tolerance=0.03)\n\n# Monitor fills\nfor trade in trades:\n    while not trade.isDone():\n        ib.sleep(1)\n    print(f\"{trade.contract.symbol}: {trade.orderStatus.status}\")",
          "language": "python",
          "context": " Target Allocation Rebalancer",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1186,
          "heading": "Target Allocation Rebalancer",
          "tags": [
            "contract",
            "data",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0179_0c5a4c2d"
    },
    {
      "cluster_id": "cluster_0163",
      "examples": [
        {
          "id": "ex_0180_c93de700",
          "code": "class DCAScheduler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.schedules = []\n        \n    def add_schedule(self, symbol, amount_per_period, frequency_days):\n        \"\"\"\n        Add DCA schedule\n        \n        Args:\n            symbol: Stock symbol\n            amount_per_period: Dollar amount to invest\n            frequency_days: Days between purchases\n        \"\"\"\n        self.schedules.append({\n            'symbol': symbol,\n            'amount': amount_per_period,\n            'frequency': frequency_days,\n            'last_purchase': None\n        })\n    \n    def check_and_execute(self):\n        \"\"\"Check if any DCA purchases are due\"\"\"\n        from datetime import datetime, timedelta\n        \n        now = datetime.now()\n        \n        for schedule in self.schedules:\n            last = schedule['last_purchase']\n            \n            # Check if purchase is due\n            if last is None or (now - last).days >= schedule['frequency']:\n                self.execute_dca(schedule)\n                schedule['last_purchase'] = now\n    \n    def execute_dca(self, schedule):\n        \"\"\"Execute DCA purchase\"\"\"\n        symbol = schedule['symbol']\n        amount = schedule['amount']\n        \n        # Create contract\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = self.ib.qualifyContracts(contract)[0]\n        \n        # Get current price\n        ticker = self.ib.reqMktData(contract, '', True, False)\n        self.ib.sleep(1)\n        \n        if ticker.last and ticker.last == ticker.last:\n            price = ticker.last\n            shares = int(amount / price)\n            \n            if shares > 0:\n                logging.info(f\"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})\")\n                order = MarketOrder('BUY', shares)\n                trade = self.ib.placeOrder(contract, order)\n                return trade\n        \n        self.ib.cancelMktData(contract)\n        return None\n\n# Usage\ndca = DCAScheduler(ib)\ndca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days\ndca.add_schedule('VTI', 500, 14)   # $500 every 14 days\n\n# Run daily check\nwhile True:\n    dca.check_and_execute()\n    ib.sleep(86400)  # Check daily",
          "language": "python",
          "context": " Dollar-Cost Averaging",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1289,
          "heading": "Dollar-Cost Averaging",
          "tags": [
            "contract",
            "data",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0180_c93de700"
    },
    {
      "cluster_id": "cluster_0164",
      "examples": [
        {
          "id": "ex_0181_61f34a96",
          "code": "class TickFilter:\n    def __init__(self, ib, contract, min_size=100):\n        self.ib = ib\n        self.contract = contract\n        self.min_size = min_size\n        self.large_trades = []\n        \n    def start(self):\n        \"\"\"Start tick-by-tick subscription with filtering\"\"\"\n        self.ticker = self.ib.reqTickByTickData(\n            self.contract,\n            'AllLast',  # All trades\n            0,\n            False\n        )\n        self.ticker.updateEvent += self.on_tick\n    \n    def on_tick(self, ticker):\n        \"\"\"Filter and process ticks\"\"\"\n        if not ticker.tickByTicks:\n            return\n        \n        latest_tick = ticker.tickByTicks[-1]\n        \n        # Filter by size\n        if latest_tick.size >= self.min_size:\n            self.large_trades.append({\n                'time': latest_tick.time,\n                'price': latest_tick.price,\n                'size': latest_tick.size\n            })\n            \n            logging.info(f\"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}\")\n    \n    def stop(self):\n        \"\"\"Stop subscription\"\"\"\n        self.ib.cancelTickByTickData(self.contract)\n    \n    def get_stats(self):\n        \"\"\"Get statistics on large trades\"\"\"\n        if not self.large_trades:\n            return None\n        \n        total_volume = sum(t['size'] for t in self.large_trades)\n        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume\n        \n        return {\n            'num_trades': len(self.large_trades),\n            'total_volume': total_volume,\n            'vwap': avg_price\n        }\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nfilter = TickFilter(ib, contract, min_size=1000)\nfilter.start()\n\n# Run for period\nib.sleep(3600)  # 1 hour\n\nfilter.stop()\nstats = filter.get_stats()\nprint(f\"Large trades: {stats}\")",
          "language": "python",
          "context": " Tick-by-Tick with Filtering",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1367,
          "heading": "Tick-by-Tick with Filtering",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0181_61f34a96"
    },
    {
      "cluster_id": "cluster_0165",
      "examples": [
        {
          "id": "ex_0182_36544bcc",
          "code": "class VolumeProfile:\n    def __init__(self, ib, contract, num_bins=20):\n        self.ib = ib\n        self.contract = contract\n        self.num_bins = num_bins\n        self.profile = {}\n        \n    def build_from_historical(self, days=1):\n        \"\"\"Build volume profile from historical data\"\"\"\n        bars = self.ib.reqHistoricalData(\n            self.contract,\n            endDateTime='',\n            durationStr=f'{days} D',\n            barSizeSetting='5 mins',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if not bars:\n            return None\n        \n        # Get price range\n        prices = [bar.close for bar in bars]\n        min_price = min(prices)\n        max_price = max(prices)\n        \n        # Create bins\n        bin_size = (max_price - min_price) / self.num_bins\n        \n        # Accumulate volume in bins\n        for bar in bars:\n            bin_idx = int((bar.close - min_price) / bin_size)\n            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max\n            \n            bin_price = min_price + (bin_idx * bin_size)\n            \n            if bin_price not in self.profile:\n                self.profile[bin_price] = 0\n            \n            self.profile[bin_price] += bar.volume\n        \n        return self.profile\n    \n    def get_poc(self):\n        \"\"\"Get Point of Control (price with highest volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        return max(self.profile.items(), key=lambda x: x[1])\n    \n    def get_value_area(self, percent=0.70):\n        \"\"\"Get value area (prices containing X% of volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        total_volume = sum(self.profile.values())\n        target_volume = total_volume * percent\n        \n        # Sort by volume\n        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)\n        \n        accumulated_volume = 0\n        value_area_prices = []\n        \n        for price, volume in sorted_profile:\n            accumulated_volume += volume\n            value_area_prices.append(price)\n            \n            if accumulated_volume >= target_volume:\n                break\n        \n        return min(value_area_prices), max(value_area_prices)\n\n# Usage\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nvp = VolumeProfile(ib, contract, num_bins=30)\nprofile = vp.build_from_historical(days=5)\n\npoc_price, poc_volume = vp.get_poc()\nprint(f\"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume\")\n\nva_low, va_high = vp.get_value_area(percent=0.70)\nprint(f\"Value Area: ${va_low:.2f} - ${va_high:.2f}\")",
          "language": "python",
          "context": " Volume Profile Builder",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1436,
          "heading": "Volume Profile Builder",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0182_36544bcc"
    },
    {
      "cluster_id": "cluster_0166",
      "examples": [
        {
          "id": "ex_0183_3e821cf7",
          "code": "class MultiAccountRouter:\n    def __init__(self, host='127.0.0.1', port=7497):\n        self.connections = {}\n        self.host = host\n        self.port = port\n        \n    def add_account(self, account_name, client_id):\n        \"\"\"Add account connection\"\"\"\n        ib = IB()\n        ib.connect(self.host, self.port, client_id)\n        self.connections[account_name] = ib\n        logging.info(f\"Connected account {account_name} with clientId {client_id}\")\n    \n    def place_order_all(self, contract, order_template, quantities):\n        \"\"\"\n        Place orders across multiple accounts\n        \n        Args:\n            contract: Contract to trade\n            order_template: Base order\n            quantities: Dict[account_name, quantity]\n        \"\"\"\n        trades = {}\n        \n        for account_name, quantity in quantities.items():\n            if account_name not in self.connections:\n                logging.error(f\"Account {account_name} not connected\")\n                continue\n            \n            ib = self.connections[account_name]\n            \n            # Clone order\n            order = Order(**{k: v for k, v in order_template.__dict__.items()})\n            order.totalQuantity = quantity\n            order.account = account_name\n            \n            # Place order\n            trade = ib.placeOrder(contract, order)\n            trades[account_name] = trade\n            \n            logging.info(f\"Placed {order.action} {quantity} {contract.symbol} for {account_name}\")\n        \n        return trades\n    \n    def get_combined_portfolio(self):\n        \"\"\"Get combined portfolio across all accounts\"\"\"\n        combined = {}\n        \n        for account_name, ib in self.connections.items():\n            for item in ib.portfolio():\n                symbol = item.contract.symbol\n                \n                if symbol not in combined:\n                    combined[symbol] = {\n                        'position': 0,\n                        'market_value': 0,\n                        'unrealized_pnl': 0,\n                        'accounts': {}\n                    }\n                \n                combined[symbol]['position'] += item.position\n                combined[symbol]['market_value'] += item.marketValue\n                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL\n                combined[symbol]['accounts'][account_name] = item.position\n        \n        return combined\n    \n    def disconnect_all(self):\n        \"\"\"Disconnect all accounts\"\"\"\n        for account_name, ib in self.connections.items():\n            ib.disconnect()\n            logging.info(f\"Disconnected {account_name}\")\n\n# Usage\nrouter = MultiAccountRouter()\nrouter.add_account('Account1', client_id=1)\nrouter.add_account('Account2', client_id=2)\nrouter.add_account('Account3', client_id=3)\n\n# Place order across all accounts\ncontract = Stock('AAPL', 'SMART', 'USD')\norder_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account\n\nquantities = {\n    'Account1': 100,\n    'Account2': 200,\n    'Account3': 150\n}\n\ntrades = router.place_order_all(contract, order_template, quantities)\n\n# Monitor combined portfolio\ncombined = router.get_combined_portfolio()\nfor symbol, data in combined.items():\n    print(f\"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts\")",
          "language": "python",
          "context": " Multi-Account Order Router",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1529,
          "heading": "Multi-Account Order Router",
          "tags": [
            "connect",
            "contract",
            "error",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0183_3e821cf7"
    },
    {
      "cluster_id": "cluster_0167",
      "examples": [
        {
          "id": "ex_0184_caee834a",
          "code": "def qualify_contracts_batch(ib, contracts, batch_size=50):\n    \"\"\"Qualify contracts in batches to avoid rate limits\"\"\"\n    qualified = []\n    \n    for i in range(0, len(contracts), batch_size):\n        batch = contracts[i:i+batch_size]\n        \n        try:\n            qualified_batch = ib.qualifyContracts(*batch)\n            qualified.extend(qualified_batch)\n        except Exception as e:\n            logging.error(f\"Batch qualification failed: {e}\")\n        \n        # Respect rate limits\n        ib.sleep(1)\n    \n    return qualified",
          "language": "python",
          "context": " Batch Contract Qualification",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1632,
          "heading": "Batch Contract Qualification",
          "tags": [
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0184_caee834a"
    },
    {
      "cluster_id": "cluster_0168",
      "examples": [
        {
          "id": "ex_0185_3be9f3a2",
          "code": "from collections import deque\nimport threading\n\nclass RequestQueue:\n    def __init__(self, ib, max_per_second=40):\n        self.ib = ib\n        self.queue = deque()\n        self.max_per_second = max_per_second\n        self.running = False\n        \n    def add(self, func, *args, **kwargs):\n        \"\"\"Add request to queue\"\"\"\n        self.queue.append((func, args, kwargs))\n    \n    def start(self):\n        \"\"\"Start processing queue\"\"\"\n        self.running = True\n        thread = threading.Thread(target=self._process)\n        thread.daemon = True\n        thread.start()\n    \n    def _process(self):\n        \"\"\"Process queue with rate limiting\"\"\"\n        delay = 1.0 / self.max_per_second\n        \n        while self.running:\n            if self.queue:\n                func, args, kwargs = self.queue.popleft()\n                \n                try:\n                    func(*args, **kwargs)\n                except Exception as e:\n                    logging.error(f\"Request failed: {e}\")\n                \n                time.sleep(delay)\n            else:\n                time.sleep(0.1)\n    \n    def stop(self):\n        \"\"\"Stop processing\"\"\"\n        self.running = False\n\n# Usage\nqueue = RequestQueue(ib, max_per_second=40)\nqueue.start()\n\n# Queue many requests\nfor contract in large_contract_list:\n    queue.add(ib.reqMktData, contract, '', False, False)",
          "language": "python",
          "context": " Request Queue Manager",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1653,
          "heading": "Request Queue Manager",
          "tags": [
            "contract",
            "data",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0185_3be9f3a2"
    },
    {
      "cluster_id": "cluster_0169",
      "examples": [
        {
          "id": "ex_0186_740a3bd3",
          "code": "\"\"\"\nProduction Trading System Template\nFeatures: Auto-reconnect, error handling, risk management, logging\n\"\"\"\n\nimport logging\nfrom datetime import datetime, time as dt_time\nfrom ib_insync import *\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s',\n    handlers=[\n        logging.FileHandler(f'trading_{datetime.now().strftime(\"%Y%m%d\")}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass ProductionTradingSystem:\n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self.ib = None\n        self.running = False\n        \n        # Risk parameters\n        self.max_daily_loss_pct = 0.03\n        self.max_position_pct = 0.20\n        self.daily_loss_breached = False\n        \n        # State tracking\n        self.start_equity = 0\n        self.trades_today = []\n        \n    def initialize(self):\n        \"\"\"Initialize system\"\"\"\n        logging.info(\"Initializing trading system...\")\n        \n        # Connect\n        self.ib = IB()\n        self.ib.errorEvent += self.on_error\n        self.ib.disconnectedEvent += self.on_disconnect\n        \n        try:\n            self.ib.connect(self.host, self.port, self.client_id, timeout=10)\n            logging.info(\"Connected to TWS\")\n        except Exception as e:\n            logging.critical(f\"Failed to connect: {e}\")\n            return False\n        \n        # Get starting equity\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        logging.info(f\"Starting equity: ${self.start_equity:,.2f}\")\n        \n        # Setup event handlers\n        self.ib.orderStatusEvent += self.on_order_status\n        self.ib.execDetailsEvent += self.on_execution\n        \n        return True\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle errors\"\"\"\n        if errorCode in [502, 503, 504]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n        elif errorCode >= 2000:\n            # Warnings\n            logging.warning(f\"Warning {errorCode}: {errorString}\")\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        logging.warning(\"Disconnected from TWS\")\n        # Attempt reconnection logic here\n    \n    def on_order_status(self, trade):\n        \"\"\"Track order status\"\"\"\n        logging.info(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    \n    def on_execution(self, trade, fill):\n        \"\"\"Track executions\"\"\"\n        self.trades_today.append(trade)\n        logging.info(f\"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}\")\n    \n    def check_risk_limits(self):\n        \"\"\"Check if risk limits breached\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        # Daily loss check\n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%\")\n            self.daily_loss_breached = True\n            self.emergency_shutdown()\n            return False\n        \n        return True\n    \n    def emergency_shutdown(self):\n        \"\"\"Emergency shutdown - close all positions\"\"\"\n        logging.critical(\"EMERGENCY SHUTDOWN INITIATED\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        for position in self.ib.positions():\n            qty = abs(position.position)\n            action = 'SELL' if position.position > 0 else 'BUY'\n            \n            order = MarketOrder(action, qty)\n            self.ib.placeOrder(position.contract, order)\n            \n            logging.info(f\"Emergency close: {action} {qty} {position.contract.symbol}\")\n        \n        self.running = False\n    \n    def is_market_hours(self):\n        \"\"\"Check if within trading hours\"\"\"\n        now = datetime.now().time()\n        market_open = dt_time(9, 30)\n        market_close = dt_time(16, 0)\n        \n        return market_open <= now <= market_close\n    \n    def run(self):\n        \"\"\"Main trading loop\"\"\"\n        if not self.initialize():\n            return\n        \n        self.running = True\n        logging.info(\"Trading system started\")\n        \n        try:\n            while self.running:\n                # Check risk limits\n                if not self.check_risk_limits():\n                    break\n                \n                # Only trade during market hours\n                if self.is_market_hours():\n                    # Your trading logic here\n                    self.trading_logic()\n                \n                # Sleep between iterations\n                self.ib.sleep(60)  # Check every minute\n                \n        except KeyboardInterrupt:\n            logging.info(\"Shutdown requested by user\")\n        except Exception as e:\n            logging.critical(f\"Unexpected error: {e}\")\n        finally:\n            self.shutdown()\n    \n    def trading_logic(self):\n        \"\"\"Implement your trading strategy here\"\"\"\n        pass\n    \n    def shutdown(self):\n        \"\"\"Graceful shutdown\"\"\"\n        logging.info(\"Shutting down trading system...\")\n        \n        if self.ib:\n            # Cancel all market data\n            for contract in [t.contract for t in self.ib.tickers()]:\n                self.ib.cancelMktData(contract)\n            \n            # Disconnect\n            self.ib.disconnect()\n        \n        logging.info(\"Shutdown complete\")\n\n# Run the system\nif __name__ == '__main__':\n    system = ProductionTradingSystem(\n        host='127.0.0.1',\n        port=7497,\n        client_id=1\n    )\n    system.run()",
          "language": "python",
          "context": " Complete Production Trading System Template",
          "source_file": "ib_advanced_patterns.md",
          "line_number": 1710,
          "heading": "Complete Production Trading System Template",
          "tags": [
            "connect",
            "contract",
            "error",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0186_740a3bd3"
    },
    {
      "cluster_id": "cluster_0170",
      "examples": [
        {
          "id": "ex_0187_9c1600a8",
          "code": "from ib_insync import *\n\n# Jupyter notebook? Uncomment:\n# util.startLoop()\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Get account info\naccount = ib.managedAccounts()[0]\nprint(f\"Connected to account: {account}\")\n\n# Create contract\ncontract = Stock('AAPL', 'SMART', 'USD')\n\n# Get market data\nticker = ib.reqMktData(contract)\nib.sleep(2)  # Wait for data\nprint(ticker.marketPrice())\n\nib.disconnect()",
          "language": "python",
          "context": " Minimal Example",
          "source_file": "ib_complete_reference.md",
          "line_number": 33,
          "heading": "Minimal Example",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0187_9c1600a8"
    },
    {
      "cluster_id": "cluster_0171",
      "examples": [
        {
          "id": "ex_0188_8e7796b2",
          "code": "class IB:\n    \"\"\"High-level interface to Interactive Brokers\"\"\"",
          "language": "python",
          "context": " Class Definition",
          "source_file": "ib_complete_reference.md",
          "line_number": 75,
          "heading": "Class Definition",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0188_8e7796b2"
    },
    {
      "cluster_id": "cluster_0172",
      "examples": [
        {
          "id": "ex_0189_91b1ed12",
          "code": "RequestTimeout: float = 0        # Request timeout (0 = infinite)\nRaiseRequestErrors: bool = False # Raise errors vs silent fail\nMaxSyncedSubAccounts: int = 50   # Max sub-accounts to sync",
          "language": "python",
          "context": " Class Attributes",
          "source_file": "ib_complete_reference.md",
          "line_number": 81,
          "heading": "Class Attributes",
          "tags": [
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0189_91b1ed12"
    },
    {
      "cluster_id": "cluster_0173",
      "examples": [
        {
          "id": "ex_0190_1da11b26",
          "code": "events = (\n    'connectedEvent',       # Connection established\n    'disconnectedEvent',    # Connection lost\n    'updateEvent',          # Any state update\n    'pendingTickersEvent',  # Ticker updates available\n    'barUpdateEvent',       # Real-time bar update\n    'newOrderEvent',        # New order created\n    'orderModifyEvent',     # Order modified\n    'cancelOrderEvent',     # Order cancel requested\n    'openOrderEvent',       # Open order status\n    'orderStatusEvent',     # Order status changed\n    'execDetailsEvent',     # Trade execution details\n    'commissionReportEvent',# Commission report\n    'updatePortfolioEvent', # Portfolio updated\n    'positionEvent',        # Position changed\n    'accountValueEvent',    # Account value updated\n    'accountSummaryEvent',  # Account summary updated\n    'pnlEvent',            # PnL update\n    'pnlSingleEvent',      # Single position PnL\n    'scannerDataEvent',    # Scanner data received\n    'tickNewsEvent',       # News tick\n    'newsBulletinEvent',   # News bulletin\n    'errorEvent',          # Error occurred\n    'timeoutEvent'         # Request timeout\n)",
          "language": "python",
          "context": " Events",
          "source_file": "ib_complete_reference.md",
          "line_number": 88,
          "heading": "Events",
          "tags": [
            "connect",
            "error",
            "event",
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0190_1da11b26"
    },
    {
      "cluster_id": "cluster_0174",
      "examples": [
        {
          "id": "ex_0191_a0a2d809",
          "code": "# Access current state (auto-synced)\nib.accountValues()      # List[AccountValue]\nib.portfolio()          # List[PortfolioItem]\nib.positions()          # List[Position]\nib.trades()             # List[Trade]\nib.openTrades()         # List[Trade] - open only\nib.orders()             # List[Order]\nib.openOrders()         # List[Order] - open only\nib.fills()              # List[Fill]\nib.executions()         # List[Execution]\nib.tickers()            # List[Ticker]\nib.pendingTickers()     # Set[Ticker] - with updates\nib.reqId()              # int - next request ID",
          "language": "python",
          "context": " State Properties",
          "source_file": "ib_complete_reference.md",
          "line_number": 117,
          "heading": "State Properties",
          "tags": [
            "order",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0191_a0a2d809"
    },
    {
      "cluster_id": "cluster_0175",
      "examples": [
        {
          "id": "ex_0192_1c37caad",
          "code": "ib.connect(\n    host: str = '127.0.0.1',\n    port: int = 7497,           # 7497=TWS, 4001=Gateway\n    clientId: int = 1,          # Unique per connection\n    timeout: float = 2.0,       # Connection timeout (0=no limit)\n    readonly: bool = False,     # Read-only mode\n    account: str = '',          # Main account for updates\n    raiseSyncErrors: bool = True # Raise sync errors\n) -> None",
          "language": "python",
          "context": " Connect (Blocking)",
          "source_file": "ib_complete_reference.md",
          "line_number": 138,
          "heading": "Connect (Blocking)",
          "tags": [
            "connect",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0192_1c37caad"
    },
    {
      "cluster_id": "cluster_0176",
      "examples": [
        {
          "id": "ex_0193_8372747c",
          "code": "await ib.connectAsync(\n    host, port, clientId, \n    timeout, readonly, account, raiseSyncErrors\n) -> None",
          "language": "python",
          "context": " Connect (Async)",
          "source_file": "ib_complete_reference.md",
          "line_number": 158,
          "heading": "Connect (Async)",
          "tags": [
            "async",
            "connect",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0193_8372747c"
    },
    {
      "cluster_id": "cluster_0177",
      "examples": [
        {
          "id": "ex_0194_217875f9",
          "code": "ib.disconnect() -> None",
          "language": "python",
          "context": " Disconnect",
          "source_file": "ib_complete_reference.md",
          "line_number": 166,
          "heading": "Disconnect",
          "tags": [
            "connect"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0194_217875f9"
    },
    {
      "cluster_id": "cluster_0178",
      "examples": [
        {
          "id": "ex_0195_8e8c97f7",
          "code": "ib.isConnected() -> bool\nib.client.isReady() -> bool  # API ready",
          "language": "python",
          "context": " Check Connection",
          "source_file": "ib_complete_reference.md",
          "line_number": 172,
          "heading": "Check Connection",
          "tags": [
            "connect"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0195_8e8c97f7"
    },
    {
      "cluster_id": "cluster_0179",
      "examples": [
        {
          "id": "ex_0196_6af2e413",
          "code": "ib.waitOnUpdate(timeout: float = 0) -> bool\n# Wait for network update. Returns False on timeout.\n\nib.sleep(seconds: float = 0.02) -> None\n# Sleep while keeping event loop alive\n# ALWAYS use this instead of time.sleep()",
          "language": "python",
          "context": " Wait & Sleep",
          "source_file": "ib_complete_reference.md",
          "line_number": 178,
          "heading": "Wait & Sleep",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0196_6af2e413"
    },
    {
      "cluster_id": "cluster_0180",
      "examples": [
        {
          "id": "ex_0197_5d3a8df7",
          "code": "ib.run()  # Run until disconnect\nawait ib.runAsync()  # Async version\n\n# Condition-based iteration\nfor update in ib.loopUntil(timeout=60):\n    if condition:\n        break",
          "language": "python",
          "context": " Loop Management",
          "source_file": "ib_complete_reference.md",
          "line_number": 188,
          "heading": "Loop Management",
          "tags": [
            "async",
            "connect"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0197_5d3a8df7"
    },
    {
      "cluster_id": "cluster_0181",
      "examples": [
        {
          "id": "ex_0198_021797a7",
          "code": "@dataclass\nclass Contract:\n    conId: int = 0              # Unique IB contract ID\n    symbol: str = ''            # Ticker symbol\n    secType: str = ''           # Security type\n    lastTradeDateOrContractMonth: str = ''\n    strike: float = 0.0\n    right: str = ''             # 'C' or 'P' for options\n    multiplier: str = ''\n    exchange: str = ''\n    primaryExchange: str = ''\n    currency: str = ''\n    localSymbol: str = ''\n    tradingClass: str = ''\n    includeExpired: bool = False\n    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC\n    secId: str = ''\n    description: str = ''\n    issuerId: str = ''\n    comboLegsDescrip: str = ''\n    comboLegs: List = None      # For combo orders\n    deltaNeutralContract: DeltaNeutralContract = None",
          "language": "python",
          "context": " Base Contract",
          "source_file": "ib_complete_reference.md",
          "line_number": 203,
          "heading": "Base Contract",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0198_021797a7"
    },
    {
      "cluster_id": "cluster_0182",
      "examples": [
        {
          "id": "ex_0199_47b23e16",
          "code": "Stock(\n    symbol: str,\n    exchange: str = 'SMART',\n    currency: str = 'USD',\n    primaryExchange: str = ''\n)\n\n# Examples\nStock('AAPL', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nStock('BMW', 'SMART', 'EUR', primaryExchange='IBIS')",
          "language": "python",
          "context": " Stock",
          "source_file": "ib_complete_reference.md",
          "line_number": 229,
          "heading": "Stock",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0199_47b23e16"
    },
    {
      "cluster_id": "cluster_0183",
      "examples": [
        {
          "id": "ex_0200_ac6252b4",
          "code": "Forex(pair: str = 'EURUSD', exchange: str = 'IDEALPRO')\n\n# Examples\nForex('EURUSD')\nForex('GBPUSD')",
          "language": "python",
          "context": " Forex",
          "source_file": "ib_complete_reference.md",
          "line_number": 244,
          "heading": "Forex",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0200_ac6252b4"
    },
    {
      "cluster_id": "cluster_0184",
      "examples": [
        {
          "id": "ex_0201_30a355c3",
          "code": "Future(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nFuture('ES', '20240920', 'GLOBEX')  # E-mini S&P\nFuture('CL', '202412', 'NYMEX')     # Crude Oil",
          "language": "python",
          "context": " Future",
          "source_file": "ib_complete_reference.md",
          "line_number": 253,
          "heading": "Future",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0201_30a355c3"
    },
    {
      "cluster_id": "cluster_0185",
      "examples": [
        {
          "id": "ex_0202_8a148020",
          "code": "Option(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    strike: float = 0.0,\n    right: str = '',            # 'C' or 'P'\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nOption('SPY', '20240920', 450, 'C', 'SMART')  # Call\nOption('AAPL', '20240315', 180, 'P', 'SMART') # Put",
          "language": "python",
          "context": " Option",
          "source_file": "ib_complete_reference.md",
          "line_number": 268,
          "heading": "Option",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0202_8a148020"
    },
    {
      "cluster_id": "cluster_0186",
      "examples": [
        {
          "id": "ex_0203_d49a58bb",
          "code": "Index(symbol: str = '', exchange: str = '')\n\n# Examples\nIndex('SPX', 'CBOE')\nIndex('VIX', 'CBOE')",
          "language": "python",
          "context": " Index",
          "source_file": "ib_complete_reference.md",
          "line_number": 285,
          "heading": "Index",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0203_d49a58bb"
    },
    {
      "cluster_id": "cluster_0187",
      "examples": [
        {
          "id": "ex_0204_93b9ec89",
          "code": "CFD(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCFD('IBUS30')",
          "language": "python",
          "context": " CFD",
          "source_file": "ib_complete_reference.md",
          "line_number": 294,
          "heading": "CFD",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0204_93b9ec89"
    },
    {
      "cluster_id": "cluster_0188",
      "examples": [
        {
          "id": "ex_0205_203f5234",
          "code": "Commodity(\n    symbol: str = '',\n    exchange: str = '',\n    currency: str = ''\n)\n\n# Example\nCommodity('XAUUSD', 'SMART', 'USD')",
          "language": "python",
          "context": " Commodity",
          "source_file": "ib_complete_reference.md",
          "line_number": 302,
          "heading": "Commodity",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0205_203f5234"
    },
    {
      "cluster_id": "cluster_0189",
      "examples": [
        {
          "id": "ex_0206_bfa34fc6",
          "code": "Bond(secIdType: str = '', secId: str = '')\n\n# Example\nBond(secIdType='ISIN', secId='US03076KAA60')",
          "language": "python",
          "context": " Bond",
          "source_file": "ib_complete_reference.md",
          "line_number": 314,
          "heading": "Bond",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0206_bfa34fc6"
    },
    {
      "cluster_id": "cluster_0190",
      "examples": [
        {
          "id": "ex_0207_163692a6",
          "code": "Crypto(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCrypto('BTC', 'PAXOS', 'USD')",
          "language": "python",
          "context": " Crypto",
          "source_file": "ib_complete_reference.md",
          "line_number": 322,
          "heading": "Crypto",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0207_163692a6"
    },
    {
      "cluster_id": "cluster_0191",
      "examples": [
        {
          "id": "ex_0208_0ae96c65",
          "code": "Contract(conId=270639)  # Direct lookup by IB contract ID",
          "language": "python",
          "context": " Contract by conId",
          "source_file": "ib_complete_reference.md",
          "line_number": 330,
          "heading": "Contract by conId",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0208_0ae96c65"
    },
    {
      "cluster_id": "cluster_0192",
      "examples": [
        {
          "id": "ex_0209_d000a006",
          "code": "# Resolve ambiguous contracts\ncontracts = ib.qualifyContracts(contract)\n# Returns list of fully qualified contracts\n\n# Example\nstock = Stock('AAPL', 'SMART', 'USD')\nqualified = ib.qualifyContracts(stock)[0]\nprint(qualified.conId)  # IB contract ID",
          "language": "python",
          "context": " Qualify Contracts",
          "source_file": "ib_complete_reference.md",
          "line_number": 335,
          "heading": "Qualify Contracts",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0209_d000a006"
    },
    {
      "cluster_id": "cluster_0193",
      "examples": [
        {
          "id": "ex_0210_84bbd4a2",
          "code": "details = ib.reqContractDetails(contract)\n# Returns List[ContractDetails]\n\n# ContractDetails fields:\n# .contract - Fully qualified contract\n# .marketName\n# .minTick\n# .priceMagnifier\n# .orderTypes\n# .validExchanges\n# .underConId\n# .longName\n# .contractMonth\n# .industry\n# .category\n# .subcategory\n# .timeZoneId\n# .tradingHours\n# .liquidHours\n# And many more...",
          "language": "python",
          "context": " Contract Details",
          "source_file": "ib_complete_reference.md",
          "line_number": 347,
          "heading": "Contract Details",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0210_84bbd4a2"
    },
    {
      "cluster_id": "cluster_0194",
      "examples": [
        {
          "id": "ex_0211_0a67635a",
          "code": "descriptions = ib.reqMatchingSymbols('app')\n# Returns List[ContractDescription]\n# Fuzzy search for symbols",
          "language": "python",
          "context": " Match Symbols",
          "source_file": "ib_complete_reference.md",
          "line_number": 371,
          "heading": "Match Symbols",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0211_0a67635a"
    },
    {
      "cluster_id": "cluster_0195",
      "examples": [
        {
          "id": "ex_0212_944e293c",
          "code": "@dataclass\nclass Order:\n    orderId: int = 0\n    clientId: int = 0\n    permId: int = 0\n    action: str = ''            # 'BUY' or 'SELL'\n    totalQuantity: float = 0.0\n    orderType: str = ''         # See order types below\n    lmtPrice: float = 0.0\n    auxPrice: float = 0.0       # Stop price\n    tif: str = 'DAY'            # Time in force\n    \n    # Advanced fields\n    ocaGroup: str = ''          # One-Cancels-All group\n    account: str = ''\n    openClose: str = 'O'        # 'O'=open, 'C'=close\n    origin: int = 0             # 0=customer\n    orderRef: str = ''\n    transmit: bool = True       # Auto-transmit\n    parentId: int = 0           # For bracket orders\n    blockOrder: bool = False\n    sweepToFill: bool = False\n    displaySize: int = 0\n    triggerMethod: int = 0\n    outsideRth: bool = False    # Outside regular hours\n    hidden: bool = False\n    \n    # Order combos\n    goodAfterTime: str = ''\n    goodTillDate: str = ''\n    rule80A: str = ''\n    allOrNone: bool = False\n    minQty: int = None\n    percentOffset: float = None\n    overridePercentageConstraints: bool = False\n    trailStopPrice: float = None\n    trailingPercent: float = None\n    \n    # Financial advisors\n    faGroup: str = ''\n    faProfile: str = ''\n    faMethod: str = ''\n    faPercentage: str = ''\n    \n    # Institutional\n    designatedLocation: str = ''\n    exemptCode: int = -1\n    \n    # Smart routing\n    discretionaryAmt: float = 0.0\n    eTradeOnly: bool = False\n    firmQuoteOnly: bool = False\n    nbboPriceCap: float = None\n    optOutSmartRouting: bool = False\n    \n    # Pegged orders\n    stockRefPrice: float = None\n    delta: float = None\n    \n    # Volatility orders\n    volatility: float = None\n    volatilityType: int = None\n    deltaNeutralOrderType: str = ''\n    deltaNeutralAuxPrice: float = None\n    deltaNeutralConId: int = 0\n    deltaNeutralShortSale: bool = False\n    deltaNeutralShortSaleSlot: int = 0\n    deltaNeutralDesignatedLocation: str = ''\n    continuousUpdate: bool = False\n    referencePriceType: int = None\n    \n    # Conditions\n    conditions: List = None\n    conditionsIgnoreRth: bool = False\n    conditionsCancelOrder: bool = False\n    \n    # Algo orders\n    algoStrategy: str = ''\n    algoParams: List = None\n    \n    # What-if\n    whatIf: bool = False\n    \n    # Misc\n    notHeld: bool = False\n    solicited: bool = False\n    randomizeSize: bool = False\n    randomizePrice: bool = False\n    \n    # Pegged to benchmark\n    referenceContractId: int = 0\n    peggedChangeAmount: float = 0.0\n    isPeggedChangeAmountDecrease: bool = False\n    referenceChangeAmount: float = 0.0\n    referenceExchangeId: str = ''\n    adjustedOrderType: str = ''\n    \n    # Misc2\n    modelCode: str = ''\n    extOperator: str = ''\n    cashQty: float = None\n    mifid2DecisionMaker: str = ''\n    mifid2DecisionAlgo: str = ''\n    mifid2ExecutionTrader: str = ''\n    mifid2ExecutionAlgo: str = ''\n    dontUseAutoPriceForHedge: bool = False\n    \n    # Manual times (for audit)\n    manualOrderTime: str = ''\n    manualOrderCancelTime: str = ''\n    \n    # Post to ATS\n    usePriceMgmtAlgo: bool = None",
          "language": "python",
          "context": " Base Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 384,
          "heading": "Base Order",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0212_944e293c"
    },
    {
      "cluster_id": "cluster_0196",
      "examples": [
        {
          "id": "ex_0213_59eaafe2",
          "code": "MarketOrder(action: str, totalQuantity: float, **kwargs)\n\n# Examples\norder = MarketOrder('BUY', 100)\norder = MarketOrder('SELL', 50, tif='GTC')",
          "language": "python",
          "context": " Market Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 501,
          "heading": "Market Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0213_59eaafe2"
    },
    {
      "cluster_id": "cluster_0197",
      "examples": [
        {
          "id": "ex_0214_436ee625",
          "code": "LimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    **kwargs\n)\n\n# Examples\norder = LimitOrder('BUY', 100, 150.50)\norder = LimitOrder('SELL', 50, 155.00, tif='GTC')",
          "language": "python",
          "context": " Limit Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 510,
          "heading": "Limit Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0214_436ee625"
    },
    {
      "cluster_id": "cluster_0198",
      "examples": [
        {
          "id": "ex_0215_9836d086",
          "code": "StopOrder(\n    action: str,\n    totalQuantity: float,\n    stopPrice: float,\n    **kwargs\n)\n\n# Examples\norder = StopOrder('SELL', 100, 145.00)  # Stop loss",
          "language": "python",
          "context": " Stop Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 524,
          "heading": "Stop Order",
          "tags": [
            "order"
          ]
        },
        {
          "id": "ex_0216_1e588943",
          "code": "StopLimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    stopPrice: float,\n    **kwargs\n)\n\n# Example\norder = StopLimitOrder('SELL', 100, 148.00, 150.00)",
          "language": "python",
          "context": " Stop-Limit Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 537,
          "heading": "Stop-Limit Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 0.8693869731800766,
      "canonical": "ex_0215_9836d086"
    },
    {
      "cluster_id": "cluster_0199",
      "examples": [
        {
          "id": "ex_0217_b9979312",
          "code": "BracketOrder(\n    action: str,\n    quantity: float,\n    limitPrice: float,\n    takeProfitPrice: float,\n    stopLossPrice: float\n) -> Tuple[Order, Order, Order]\n\n# Returns (parent, takeProfit, stopLoss)\n# Example\nparent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0, 160.0, 145.0\n)",
          "language": "python",
          "context": " Bracket Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 551,
          "heading": "Bracket Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0217_b9979312"
    },
    {
      "cluster_id": "cluster_0200",
      "examples": [
        {
          "id": "ex_0218_da330b8a",
          "code": "trade = ib.placeOrder(contract: Contract, order: Order) -> Trade\n# Returns Trade object (live-updated)\n\n# Example\ncontract = Stock('AAPL', 'SMART', 'USD')\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# Trade object updated in real-time:\n# - trade.orderStatus\n# - trade.fills\n# - trade.log",
          "language": "python",
          "context": " Place Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 568,
          "heading": "Place Order",
          "tags": [
            "contract",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0218_da330b8a"
    },
    {
      "cluster_id": "cluster_0201",
      "examples": [
        {
          "id": "ex_0220_af1ad75f",
          "code": "trade = ib.cancelOrder(order: Order) -> Trade\n\n# Cancel all orders\nib.reqGlobalCancel()",
          "language": "python",
          "context": " Cancel Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 591,
          "heading": "Cancel Order",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0220_af1ad75f"
    },
    {
      "cluster_id": "cluster_0202",
      "examples": [
        {
          "id": "ex_0221_39d68f86",
          "code": "@dataclass\nclass OrderStatus:\n    orderId: int = 0\n    status: str = ''        # PendingSubmit, Submitted, Filled, Cancelled, etc.\n    filled: float = 0.0\n    remaining: float = 0.0\n    avgFillPrice: float = 0.0\n    permId: int = 0\n    parentId: int = 0\n    lastFillPrice: float = 0.0\n    clientId: int = 0\n    whyHeld: str = ''\n    mktCapPrice: float = 0.0",
          "language": "python",
          "context": " Order Status",
          "source_file": "ib_complete_reference.md",
          "line_number": 599,
          "heading": "Order Status",
          "tags": [
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0221_39d68f86"
    },
    {
      "cluster_id": "cluster_0203",
      "examples": [
        {
          "id": "ex_0222_3d080260",
          "code": "@dataclass\nclass Trade:\n    contract: Contract = None\n    order: Order = None\n    orderStatus: OrderStatus = None\n    fills: List[Fill] = []\n    log: List[TradeLogEntry] = []\n    \n    # Methods\n    def isActive(self) -> bool\n    def isDone(self) -> bool\n    def filled(self) -> float\n    def remaining(self) -> float",
          "language": "python",
          "context": " Trade Object",
          "source_file": "ib_complete_reference.md",
          "line_number": 626,
          "heading": "Trade Object",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0222_3d080260"
    },
    {
      "cluster_id": "cluster_0204",
      "examples": [
        {
          "id": "ex_0223_b7055bc8",
          "code": "orderState = ib.whatIfOrder(contract, order)\n# Test order without placing\n# Returns OrderState with commission/margin impact\n\n# OrderState fields:\n# .initMarginBefore\n# .maintMarginBefore\n# .equityWithLoanBefore\n# .initMarginAfter\n# .maintMarginAfter\n# .equityWithLoanAfter\n# .commission\n# .minCommission\n# .maxCommission\n# .commissionCurrency",
          "language": "python",
          "context": " What-If Order",
          "source_file": "ib_complete_reference.md",
          "line_number": 643,
          "heading": "What-If Order",
          "tags": [
            "contract",
            "order"
          ]
        },
        {
          "id": "ex_0291_302efcfd",
          "code": "# Common causes:\n# 1. Invalid contract\n# 2. Insufficient buying power\n# 3. Outside trading hours\n# 4. Invalid order parameters\n\n# Debug:\norderState = ib.whatIfOrder(contract, order)\nprint(orderState)",
          "language": "python",
          "context": "Error 201: Order rejected",
          "source_file": "ib_complete_reference.md",
          "line_number": 1758,
          "heading": "Order Issues",
          "tags": [
            "contract",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 0.8641509433962264,
      "canonical": "ex_0223_b7055bc8"
    },
    {
      "cluster_id": "cluster_0205",
      "examples": [
        {
          "id": "ex_0224_acebfcb7",
          "code": "ticker = ib.reqMktData(\n    contract: Contract,\n    genericTickList: str = '',\n    snapshot: bool = False,\n    regulatorySnapshot: bool = False,\n    mktDataOptions: List = None\n) -> Ticker\n\n# Ticker auto-updates in real-time",
          "language": "python",
          "context": " Request Market Data (Streaming)",
          "source_file": "ib_complete_reference.md",
          "line_number": 696,
          "heading": "Request Market Data (Streaming)",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0224_acebfcb7"
    },
    {
      "cluster_id": "cluster_0206",
      "examples": [
        {
          "id": "ex_0225_73bbdf10",
          "code": "100 - putVolume, callVolume (options)\n101 - putOpenInterest, callOpenInterest (options)\n104 - histVolatility (options)\n105 - avOptionVolume (options)\n106 - impliedVolatility (options)\n162 - indexFuturePremium\n165 - low13week, high13week, low26week, high26week,\n      low52week, high52week, avVolume\n221 - markPrice\n225 - auctionVolume, auctionPrice, auctionImbalance\n233 - last, lastSize, rtVolume, rtTime, vwap (Time & Sales)\n236 - shortableShares\n258 - fundamentalRatios",
          "language": "python",
          "context": "Generic Tick List IDs:",
          "source_file": "ib_complete_reference.md",
          "line_number": 709,
          "heading": "Ticker auto-updates in real-time",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0225_73bbdf10"
    },
    {
      "cluster_id": "cluster_0207",
      "examples": [
        {
          "id": "ex_0226_109839aa",
          "code": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract, genericTickList='233,236')\nib.sleep(2)\nprint(f\"Last: {ticker.last}\")\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Volume: {ticker.volume}\")",
          "language": "python",
          "context": "Example:",
          "source_file": "ib_complete_reference.md",
          "line_number": 726,
          "heading": "Ticker auto-updates in real-time",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0226_109839aa"
    },
    {
      "cluster_id": "cluster_0208",
      "examples": [
        {
          "id": "ex_0227_032293ce",
          "code": "ib.cancelMktData(contract: Contract) -> None",
          "language": "python",
          "context": " Cancel Market Data",
          "source_file": "ib_complete_reference.md",
          "line_number": 737,
          "heading": "Cancel Market Data",
          "tags": [
            "contract"
          ]
        },
        {
          "id": "ex_0230_ad78b745",
          "code": "ib.cancelMktDepth(contract: Contract) -> None",
          "language": "python",
          "context": " Cancel Market Depth",
          "source_file": "ib_complete_reference.md",
          "line_number": 824,
          "heading": "Cancel Market Depth",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 0.9438202247191011,
      "canonical": "ex_0227_032293ce"
    },
    {
      "cluster_id": "cluster_0209",
      "examples": [
        {
          "id": "ex_0228_df91b679",
          "code": "@dataclass\nclass Ticker:\n    contract: Contract = None\n    time: datetime = None\n    \n    # Bid/Ask\n    bid: float = nan\n    bidSize: float = nan\n    bidExchange: str = ''\n    ask: float = nan\n    askSize: float = nan\n    askExchange: str = ''\n    \n    # Last trade\n    last: float = nan\n    lastSize: float = nan\n    lastExchange: str = ''\n    \n    # Volume\n    volume: float = nan\n    volumeRate: float = nan\n    \n    # Prices\n    open: float = nan\n    high: float = nan\n    low: float = nan\n    close: float = nan\n    vwap: float = nan\n    \n    # Options\n    putVolume: float = nan\n    callVolume: float = nan\n    putOpenInterest: float = nan\n    callOpenInterest: float = nan\n    avOptionVolume: float = nan\n    impliedVolatility: float = nan\n    histVolatility: float = nan\n    \n    # Greeks (options)\n    delta: float = nan\n    gamma: float = nan\n    theta: float = nan\n    vega: float = nan\n    \n    # Market depth\n    domBids: List = []\n    domAsks: List = []\n    domTicks: List = []\n    \n    # Ticks\n    ticks: List = []\n    tickByTicks: List = []\n    \n    # Halted\n    halted: float = nan\n    \n    # Real-time\n    rtVolume: float = nan\n    rtTime: datetime = None\n    rtHistVolativity: float = nan\n    rtTradeVolume: float = nan\n    \n    # Methods\n    def marketPrice(self) -> float\n    def hasBidAsk(self) -> bool\n    def midpoint(self) -> float",
          "language": "python",
          "context": " Ticker Object",
          "source_file": "ib_complete_reference.md",
          "line_number": 742,
          "heading": "Ticker Object",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0228_df91b679"
    },
    {
      "cluster_id": "cluster_0210",
      "examples": [
        {
          "id": "ex_0229_ad978f61",
          "code": "ticker = ib.reqMktDepth(\n    contract: Contract,\n    numRows: int = 5,\n    isSmartDepth: bool = False,\n    mktDepthOptions: List = None\n) -> Ticker\n\n# Ticker.domBids and Ticker.domAsks auto-update",
          "language": "python",
          "context": " Market Depth (Level II)",
          "source_file": "ib_complete_reference.md",
          "line_number": 812,
          "heading": "Market Depth (Level II)",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0229_ad978f61"
    },
    {
      "cluster_id": "cluster_0211",
      "examples": [
        {
          "id": "ex_0231_1f886e3e",
          "code": "ticker = ib.reqTickByTickData(\n    contract: Contract,\n    tickType: str,  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks: int = 0,\n    ignoreSize: bool = False\n) -> Ticker\n\n# Ticker.tickByTicks auto-updates",
          "language": "python",
          "context": " Tick-by-Tick Data",
          "source_file": "ib_complete_reference.md",
          "line_number": 829,
          "heading": "Tick-by-Tick Data",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0231_1f886e3e"
    },
    {
      "cluster_id": "cluster_0212",
      "examples": [
        {
          "id": "ex_0232_eea923a8",
          "code": "ib.reqMarketDataType(marketDataType: int) -> None\n# 1 = Live\n# 2 = Frozen\n# 3 = Delayed\n# 4 = Delayed-Frozen",
          "language": "python",
          "context": " Market Data Type",
          "source_file": "ib_complete_reference.md",
          "line_number": 841,
          "heading": "Market Data Type",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0232_eea923a8"
    },
    {
      "cluster_id": "cluster_0213",
      "examples": [
        {
          "id": "ex_0233_443b62c5",
          "code": "bars = ib.reqHistoricalData(\n    contract: Contract,\n    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'\n    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'\n    barSizeSetting: str = '1 hour',\n    whatToShow: str = 'TRADES', # See below\n    useRTH: bool = True,        # Regular trading hours only\n    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch\n    keepUpToDate: bool = False, # Auto-update\n    chartOptions: List = None,\n    timeout: float = 60\n) -> BarDataList\n\n# Returns BarDataList (auto-synced if keepUpToDate=True)",
          "language": "python",
          "context": " Request Historical Data",
          "source_file": "ib_complete_reference.md",
          "line_number": 854,
          "heading": "Request Historical Data",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0233_443b62c5"
    },
    {
      "cluster_id": "cluster_0214",
      "examples": [
        {
          "id": "ex_0234_5c6e682d",
          "code": "S = Seconds (max 60)\nD = Days (max 365)\nW = Weeks (max 52)\nM = Months (max 12)\nY = Years (max 1)",
          "language": "python",
          "context": "Duration Strings:",
          "source_file": "ib_complete_reference.md",
          "line_number": 872,
          "heading": "Returns BarDataList (auto-synced if keepUpToDate=True)",
          "tags": [
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0234_5c6e682d"
    },
    {
      "cluster_id": "cluster_0215",
      "examples": [
        {
          "id": "ex_0235_43901f2a",
          "code": "'1 secs', '5 secs', '10 secs', '15 secs', '30 secs',\n'1 min', '2 mins', '3 mins', '5 mins', '10 mins', '15 mins', '20 mins', '30 mins',\n'1 hour', '2 hours', '3 hours', '4 hours', '8 hours',\n'1 day', '1 week', '1 month'",
          "language": "python",
          "context": "Bar Sizes:",
          "source_file": "ib_complete_reference.md",
          "line_number": 881,
          "heading": "Returns BarDataList (auto-synced if keepUpToDate=True)",
          "tags": [
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0235_43901f2a"
    },
    {
      "cluster_id": "cluster_0216",
      "examples": [
        {
          "id": "ex_0236_612914ff",
          "code": "'TRADES'           - Actual trades\n'MIDPOINT'         - Bid/ask midpoint\n'BID'              - Bid prices\n'ASK'              - Ask prices\n'BID_ASK'          - Bid/ask pairs\n'HISTORICAL_VOLATILITY'\n'OPTION_IMPLIED_VOLATILITY'\n'REBATE_RATE'\n'FEE_RATE'\n'YIELD_BID'\n'YIELD_ASK'\n'YIELD_BID_ASK'\n'YIELD_LAST'",
          "language": "python",
          "context": "What to Show:",
          "source_file": "ib_complete_reference.md",
          "line_number": 889,
          "heading": "Returns BarDataList (auto-synced if keepUpToDate=True)",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0236_612914ff"
    },
    {
      "cluster_id": "cluster_0217",
      "examples": [
        {
          "id": "ex_0238_11491458",
          "code": "@dataclass\nclass Bar:\n    date: datetime\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    average: float\n    barCount: int",
          "language": "python",
          "context": " Bar Object",
          "source_file": "ib_complete_reference.md",
          "line_number": 924,
          "heading": "Bar Object",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0238_11491458"
    },
    {
      "cluster_id": "cluster_0218",
      "examples": [
        {
          "id": "ex_0239_d5adc6d3",
          "code": "ticks = ib.reqHistoricalTicks(\n    contract: Contract,\n    startDateTime: str,\n    endDateTime: str,\n    numberOfTicks: int = 1000,\n    whatToShow: str = 'TRADES',  # 'TRADES', 'BID_ASK', 'MIDPOINT'\n    useRth: bool = True,\n    ignoreSize: bool = False,\n    miscOptions: List = None\n) -> List\n\n# Returns list of HistoricalTick objects",
          "language": "python",
          "context": " Historical Ticks",
          "source_file": "ib_complete_reference.md",
          "line_number": 938,
          "heading": "Historical Ticks",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0239_d5adc6d3"
    },
    {
      "cluster_id": "cluster_0219",
      "examples": [
        {
          "id": "ex_0240_38b77bc7",
          "code": "headTimestamp = ib.reqHeadTimeStamp(\n    contract: Contract,\n    whatToShow: str = 'TRADES',\n    useRTH: bool = True,\n    formatDate: int = 1\n) -> str\n\n# Earliest available data timestamp",
          "language": "python",
          "context": " Head Timestamp",
          "source_file": "ib_complete_reference.md",
          "line_number": 954,
          "heading": "Head Timestamp",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0240_38b77bc7"
    },
    {
      "cluster_id": "cluster_0220",
      "examples": [
        {
          "id": "ex_0241_a43bc6b4",
          "code": "schedule = ib.reqHistoricalSchedule(\n    contract: Contract,\n    numDays: int = 1,\n    endDateTime: str = '',\n    useRTH: bool = True\n) -> List[HistoricalSchedule]\n\n# Trading schedule for contract",
          "language": "python",
          "context": " Historical Schedule",
          "source_file": "ib_complete_reference.md",
          "line_number": 966,
          "heading": "Historical Schedule",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0241_a43bc6b4"
    },
    {
      "cluster_id": "cluster_0221",
      "examples": [
        {
          "id": "ex_0242_62ca894c",
          "code": "bars = ib.reqRealTimeBars(\n    contract: Contract,\n    barSize: int = 5,           # Only 5 supported\n    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK\n    useRTH: bool = False,\n    realTimeBarsOptions: List = None\n) -> RealTimeBarList\n\n# Returns RealTimeBarList (auto-updating)\n# bars.updateEvent fires on new bar",
          "language": "python",
          "context": " Real-Time Bars",
          "source_file": "ib_complete_reference.md",
          "line_number": 982,
          "heading": "Real-Time Bars",
          "tags": [
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0242_62ca894c"
    },
    {
      "cluster_id": "cluster_0222",
      "examples": [
        {
          "id": "ex_0243_0587e2fb",
          "code": "ib.cancelRealTimeBars(bars: RealTimeBarList) -> None",
          "language": "python",
          "context": " Cancel Real-Time Bars",
          "source_file": "ib_complete_reference.md",
          "line_number": 1001,
          "heading": "Cancel Real-Time Bars",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0243_0587e2fb"
    },
    {
      "cluster_id": "cluster_0223",
      "examples": [
        {
          "id": "ex_0245_21f82c32",
          "code": "accounts = ib.managedAccounts() -> List[str]\n# List of account codes",
          "language": "python",
          "context": " Managed Accounts",
          "source_file": "ib_complete_reference.md",
          "line_number": 1025,
          "heading": "Managed Accounts",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0245_21f82c32"
    },
    {
      "cluster_id": "cluster_0224",
      "examples": [
        {
          "id": "ex_0246_af6a41c6",
          "code": "values = ib.accountValues(account: str = '') -> List[AccountValue]\n\n# AccountValue fields:\n# .account\n# .tag      - Key name (e.g., 'NetLiquidation')\n# .value    - Value as string\n# .currency\n# .modelCode",
          "language": "python",
          "context": " Account Values",
          "source_file": "ib_complete_reference.md",
          "line_number": 1031,
          "heading": "Account Values",
          "tags": [
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0246_af6a41c6"
    },
    {
      "cluster_id": "cluster_0225",
      "examples": [
        {
          "id": "ex_0247_c0af1b5a",
          "code": "NetLiquidation      - Total account value\nTotalCashValue      - Cash balance\nSettledCash         - Settled cash\nAccruedCash         - Accrued cash\nBuyingPower         - Buying power\nEquityWithLoanValue - Stock value + cash\nGrossPositionValue  - Total position value\nRegTEquity          - RegT equity\nRegTMargin          - RegT margin\nSMA                 - Special Memo Account\nInitMarginReq       - Initial margin\nMaintMarginReq      - Maintenance margin\nAvailableFunds      - Available funds\nExcessLiquidity     - Excess liquidity",
          "language": "python",
          "context": "Common Tags:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1043,
          "heading": ".modelCode",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0247_c0af1b5a"
    },
    {
      "cluster_id": "cluster_0226",
      "examples": [
        {
          "id": "ex_0248_23c41848",
          "code": "summary = ib.reqAccountSummary() -> List[AccountValue]\n# Summary for all accounts\n\n# Or filter by tags\nsummary = ib.reqAccountSummary(\n    account: str = 'All',\n    modelCode: str = '',\n    tags: str = 'NetLiquidation,TotalCashValue,BuyingPower'\n)",
          "language": "python",
          "context": " Account Summary",
          "source_file": "ib_complete_reference.md",
          "line_number": 1061,
          "heading": "Account Summary",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0248_23c41848"
    },
    {
      "cluster_id": "cluster_0227",
      "examples": [
        {
          "id": "ex_0249_f664de43",
          "code": "portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]\n\n# PortfolioItem fields:\n# .contract\n# .position        - Quantity\n# .marketPrice     - Current price\n# .marketValue     - Position value\n# .averageCost     - Avg cost basis\n# .unrealizedPNL   - Unrealized P&L\n# .realizedPNL     - Realized P&L\n# .account",
          "language": "python",
          "context": " Portfolio",
          "source_file": "ib_complete_reference.md",
          "line_number": 1074,
          "heading": "Portfolio",
          "tags": [
            "contract",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0249_f664de43"
    },
    {
      "cluster_id": "cluster_0228",
      "examples": [
        {
          "id": "ex_0250_af167094",
          "code": "positions = ib.positions(account: str = '') -> List[Position]\n\n# Position fields:\n# .account\n# .contract\n# .position       - Quantity\n# .avgCost        - Average cost",
          "language": "python",
          "context": " Positions",
          "source_file": "ib_complete_reference.md",
          "line_number": 1089,
          "heading": "Positions",
          "tags": [
            "contract",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0250_af167094"
    },
    {
      "cluster_id": "cluster_0229",
      "examples": [
        {
          "id": "ex_0251_fd03c5d2",
          "code": "pnl = ib.reqPnL(account: str, modelCode: str = '') -> PnL\n# Start PnL subscription\n\n# PnL fields (live-updated):\n# .account\n# .modelCode\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n\n# Cancel\nib.cancelPnL(account: str, modelCode: str = '')",
          "language": "python",
          "context": " PnL (Profit & Loss)",
          "source_file": "ib_complete_reference.md",
          "line_number": 1100,
          "heading": "PnL (Profit & Loss)",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0251_fd03c5d2"
    },
    {
      "cluster_id": "cluster_0230",
      "examples": [
        {
          "id": "ex_0252_1a669c09",
          "code": "pnlSingle = ib.reqPnLSingle(\n    account: str,\n    modelCode: str,\n    conId: int\n) -> PnLSingle\n\n# PnLSingle fields (live-updated):\n# .account\n# .modelCode\n# .conId\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n# .position\n# .value\n\n# Cancel\nib.cancelPnLSingle(account, modelCode, conId)",
          "language": "python",
          "context": " PnL Single Position",
          "source_file": "ib_complete_reference.md",
          "line_number": 1116,
          "heading": "PnL Single Position",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0252_1a669c09"
    },
    {
      "cluster_id": "cluster_0231",
      "examples": [
        {
          "id": "ex_0253_4e41919c",
          "code": "# Events use eventkit library\n\n# Subscribe to event\ndef onPendingTickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.marketPrice()}\")\n\nib.pendingTickersEvent += onPendingTickers\n\n# Unsubscribe\nib.pendingTickersEvent -= onPendingTickers\n\n# One-time handler\nib.connectedEvent += lambda: print('Connected!')",
          "language": "python",
          "context": " Event Handling",
          "source_file": "ib_complete_reference.md",
          "line_number": 1142,
          "heading": "Event Handling",
          "tags": [
            "connect",
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0253_4e41919c"
    },
    {
      "cluster_id": "cluster_0232",
      "examples": [
        {
          "id": "ex_0254_d1dc505e",
          "code": "# New order placed\nib.newOrderEvent += lambda trade: print(f'New order: {trade}')\n\n# Order modified\nib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')\n\n# Order status changed\nib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')\n\n# Execution received\nib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')\n\n# Commission report\nib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')",
          "language": "python",
          "context": " Trade Events",
          "source_file": "ib_complete_reference.md",
          "line_number": 1160,
          "heading": "Trade Events",
          "tags": [
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0254_d1dc505e"
    },
    {
      "cluster_id": "cluster_0233",
      "examples": [
        {
          "id": "ex_0255_8775dd62",
          "code": "# Ticker updates\nib.pendingTickersEvent += lambda tickers: handle_tickers(tickers)\n\n# Bar updates\nib.barUpdateEvent += lambda bars, hasNewBar: handle_bars(bars, hasNewBar)\n\n# Scanner data\nib.scannerDataEvent += lambda scanData: print(scanData)",
          "language": "python",
          "context": " Market Data Events",
          "source_file": "ib_complete_reference.md",
          "line_number": 1178,
          "heading": "Market Data Events",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0255_8775dd62"
    },
    {
      "cluster_id": "cluster_0234",
      "examples": [
        {
          "id": "ex_0256_d86ab109",
          "code": "# Portfolio updates\nib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')\n\n# Position changes\nib.positionEvent += lambda position: print(f'Position: {position}')\n\n# Account value updates\nib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')\n\n# PnL updates\nib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')",
          "language": "python",
          "context": " Account Events",
          "source_file": "ib_complete_reference.md",
          "line_number": 1190,
          "heading": "Account Events",
          "tags": [
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0256_d86ab109"
    },
    {
      "cluster_id": "cluster_0235",
      "examples": [
        {
          "id": "ex_0257_81a00951",
          "code": "# Connected\nib.connectedEvent += lambda: print('Connected to TWS')\n\n# Disconnected\nib.disconnectedEvent += lambda: print('Disconnected')\n\n# Error\nib.errorEvent += lambda reqId, errorCode, errorString, contract: \\\n    print(f'Error {errorCode}: {errorString}')",
          "language": "python",
          "context": " Connection Events",
          "source_file": "ib_complete_reference.md",
          "line_number": 1205,
          "heading": "Connection Events",
          "tags": [
            "connect",
            "contract",
            "error",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0257_81a00951"
    },
    {
      "cluster_id": "cluster_0236",
      "examples": [
        {
          "id": "ex_0258_28c76fef",
          "code": "2104 - Market data farm connection OK\n2106 - Historical data farm connection OK\n2158 - Sec-def data farm connection OK",
          "language": "python",
          "context": "Warnings (informational):",
          "source_file": "ib_complete_reference.md",
          "line_number": 1220,
          "heading": "Error Codes Reference",
          "tags": [
            "connect",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0258_28c76fef"
    },
    {
      "cluster_id": "cluster_0237",
      "examples": [
        {
          "id": "ex_0259_e9e86cd9",
          "code": "200 - No security definition found\n201 - Order rejected\n202 - Order cancelled\n321 - Error validating request\n326 - Unable to connect (check port)\n354 - Requested market data not subscribed\n404 - Order held\n502 - Couldn't connect to TWS",
          "language": "python",
          "context": "Errors:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1227,
          "heading": "Error Codes Reference",
          "tags": [
            "connect",
            "error",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0259_e9e86cd9"
    },
    {
      "cluster_id": "cluster_0238",
      "examples": [
        {
          "id": "ex_0260_9c708f65",
          "code": "# Format for IB\nformatted = util.formatIBDatetime(dt: datetime) -> str\n# Returns: 'YYYYMMDD HH:MM:SS UTC'\n\n# Parse from IB\nparsed = util.parseIBDatetime(s: str) -> Union[date, datetime]",
          "language": "python",
          "context": " Datetime Utilities",
          "source_file": "ib_complete_reference.md",
          "line_number": 1243,
          "heading": "Datetime Utilities",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0260_9c708f65"
    },
    {
      "cluster_id": "cluster_0239",
      "examples": [
        {
          "id": "ex_0261_45f7dcb4",
          "code": "import pandas as pd\n\n# Bars to DataFrame\ndf = util.df(bars)\n\n# List of objects to DataFrame\ndf = util.df(ib.positions())\ndf = util.df(ib.accountValues())",
          "language": "python",
          "context": " Dataframe Conversion",
          "source_file": "ib_complete_reference.md",
          "line_number": 1253,
          "heading": "Dataframe Conversion",
          "tags": [
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0261_45f7dcb4"
    },
    {
      "cluster_id": "cluster_0240",
      "examples": [
        {
          "id": "ex_0262_3d6ef144",
          "code": "# Log to console\nutil.logToConsole(level=logging.INFO)\n\n# Log to file\nutil.logToFile('ib_log.txt', level=logging.DEBUG)",
          "language": "python",
          "context": " Logging",
          "source_file": "ib_complete_reference.md",
          "line_number": 1265,
          "heading": "Logging",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0262_3d6ef144"
    },
    {
      "cluster_id": "cluster_0241",
      "examples": [
        {
          "id": "ex_0263_1b93afa6",
          "code": "# At start of notebook\nutil.startLoop()\n\n# Or with old notebooks\nutil.patchAsyncio()",
          "language": "python",
          "context": " Jupyter Notebooks",
          "source_file": "ib_complete_reference.md",
          "line_number": 1276,
          "heading": "Jupyter Notebooks",
          "tags": [
            "async"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0263_1b93afa6"
    },
    {
      "cluster_id": "cluster_0242",
      "examples": [
        {
          "id": "ex_0264_083aaf30",
          "code": "util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'\n# Integrates asyncio with Qt event loop",
          "language": "python",
          "context": " Qt Integration",
          "source_file": "ib_complete_reference.md",
          "line_number": 1285,
          "heading": "Qt Integration",
          "tags": [
            "async",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0264_083aaf30"
    },
    {
      "cluster_id": "cluster_0243",
      "examples": [
        {
          "id": "ex_0265_53e6fadb",
          "code": "def callback():\n    print('Periodic task')\n\n# Schedule every 60 seconds\nhandle = util.schedule(60, callback)\n\n# Cancel scheduled task\nhandle.cancel()",
          "language": "python",
          "context": " Schedule Periodic Tasks",
          "source_file": "ib_complete_reference.md",
          "line_number": 1291,
          "heading": "Schedule Periodic Tasks",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0265_53e6fadb"
    },
    {
      "cluster_id": "cluster_0244",
      "examples": [
        {
          "id": "ex_0266_fab63157",
          "code": "# Iterate over time periods\nfor dt in util.timeRange(\n    start='20240101',\n    end='20240131',\n    step='1 day'\n):\n    print(dt)",
          "language": "python",
          "context": " Time Range Iterator",
          "source_file": "ib_complete_reference.md",
          "line_number": 1303,
          "heading": "Time Range Iterator",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0266_fab63157"
    },
    {
      "cluster_id": "cluster_0245",
      "examples": [
        {
          "id": "ex_0268_1fbd5182",
          "code": "# For tick data\nticker = ib.reqMktData(contract, '233')  # Last, volume, vwap\nticker.updateEvent += lambda ticker: process_tick(ticker)\n\n# For bar data\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)",
          "language": "python",
          "context": "\u2705 GOOD - Use streaming:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1327,
          "heading": "1. Use Real-Time Feeds, Not Repeated Historical Requests",
          "tags": [
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0268_1fbd5182"
    },
    {
      "cluster_id": "cluster_0246",
      "examples": [
        {
          "id": "ex_0269_4d249eb8",
          "code": "time.sleep(5)  # Blocks event loop!",
          "language": "python",
          "context": "\u274c BAD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1340,
          "heading": "2. Never Use time.sleep()",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0269_4d249eb8"
    },
    {
      "cluster_id": "cluster_0247",
      "examples": [
        {
          "id": "ex_0270_c9bcedf6",
          "code": "ib.sleep(5)  # Keeps event loop running",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1345,
          "heading": "2. Never Use time.sleep()",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0270_c9bcedf6"
    },
    {
      "cluster_id": "cluster_0248",
      "examples": [
        {
          "id": "ex_0271_fda8a0c1",
          "code": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)",
          "language": "python",
          "context": "\u274c BAD - Ambiguous:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1352,
          "heading": "3. Qualify Contracts",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0271_fda8a0c1"
    },
    {
      "cluster_id": "cluster_0249",
      "examples": [
        {
          "id": "ex_0272_d4da6975",
          "code": "contract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\nticker = ib.reqMktData(contract)",
          "language": "python",
          "context": "\u2705 GOOD - Qualified:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1358,
          "heading": "3. Qualify Contracts",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0272_d4da6975"
    },
    {
      "cluster_id": "cluster_0250",
      "examples": [
        {
          "id": "ex_0273_ee1d6f63",
          "code": "while True:\n    if ticker.last > 150:\n        break\n    ib.sleep(0.1)",
          "language": "python",
          "context": "\u274c BAD - Polling:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1367,
          "heading": "4. Handle Events, Don't Poll",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0273_ee1d6f63"
    },
    {
      "cluster_id": "cluster_0251",
      "examples": [
        {
          "id": "ex_0274_2dd7ade1",
          "code": "def on_price_update(ticker):\n    if ticker.last > 150:\n        take_action()\n\nticker.updateEvent += on_price_update",
          "language": "python",
          "context": "\u2705 GOOD - Event-driven:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1375,
          "heading": "4. Handle Events, Don't Poll",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0274_2dd7ade1"
    },
    {
      "cluster_id": "cluster_0252",
      "examples": [
        {
          "id": "ex_0275_0223f3f8",
          "code": "def on_error(reqId, errorCode, errorString, contract):\n    if errorCode == 200:\n        print(f\"Contract not found: {contract}\")\n    elif errorCode == 321:\n        print(f\"Validation error: {errorString}\")\n    # Handle other errors...\n\nib.errorEvent += on_error",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1386,
          "heading": "5. Error Handling",
          "tags": [
            "contract",
            "error",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0275_0223f3f8"
    },
    {
      "cluster_id": "cluster_0253",
      "examples": [
        {
          "id": "ex_0276_35e97390",
          "code": "try:\n    ticker = ib.reqMktData(contract)\n    # ... do work ...\nfinally:\n    ib.cancelMktData(contract)\n    ib.disconnect()",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1400,
          "heading": "6. Cleanup Resources",
          "tags": [
            "connect",
            "contract",
            "data",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0276_35e97390"
    },
    {
      "cluster_id": "cluster_0254",
      "examples": [
        {
          "id": "ex_0277_e3d77231",
          "code": "# ib-insync handles throttling automatically\nfor contract in large_list:\n    ib.reqMktData(contract)\n# No manual delays needed",
          "language": "python",
          "context": "\u2705 GOOD - Built-in throttling:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1414,
          "heading": "7. Request Throttling",
          "tags": [
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0277_e3d77231"
    },
    {
      "cluster_id": "cluster_0255",
      "examples": [
        {
          "id": "ex_0279_792ef977",
          "code": "def on_disconnect():\n    print(\"Disconnected! Attempting reconnect...\")\n    reconnect_logic()\n\nib.disconnectedEvent += on_disconnect",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1437,
          "heading": "9. Monitor Connection",
          "tags": [
            "connect",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0279_792ef977"
    },
    {
      "cluster_id": "cluster_0256",
      "examples": [
        {
          "id": "ex_0280_7ff23534",
          "code": "ib = IB()\nib.RequestTimeout = 30  # 30 second timeout\nib.RaiseRequestErrors = True  # Raise exceptions\n\ntry:\n    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)\nexcept asyncio.TimeoutError:\n    print(\"Connection timeout!\")",
          "language": "python",
          "context": "\u2705 GOOD:",
          "source_file": "ib_complete_reference.md",
          "line_number": 1448,
          "heading": "10. Set Timeouts",
          "tags": [
            "async",
            "connect",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0280_7ff23534"
    },
    {
      "cluster_id": "cluster_0257",
      "examples": [
        {
          "id": "ex_0281_2484482f",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        symbol = ticker.contract.symbol\n        price = ticker.marketPrice()\n        volume = ticker.volume\n        print(f\"{symbol}: ${price:.2f} | Vol: {volume}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract, '', False, False)\n\n# Run forever\nib.run()",
          "language": "python",
          "context": " Pattern: Live Ticker Monitor",
          "source_file": "ib_complete_reference.md",
          "line_number": 1464,
          "heading": "Pattern: Live Ticker Monitor",
          "tags": [
            "connect",
            "contract",
            "data",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0281_2484482f"
    },
    {
      "cluster_id": "cluster_0258",
      "examples": [
        {
          "id": "ex_0282_2728ae87",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\ncontract = ib.qualifyContracts(contract)[0]\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += on_bar_update\n\nib.run()",
          "language": "python",
          "context": " Pattern: Real-Time Bar Processing",
          "source_file": "ib_complete_reference.md",
          "line_number": 1496,
          "heading": "Pattern: Real-Time Bar Processing",
          "tags": [
            "connect",
            "contract",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0282_2728ae87"
    },
    {
      "cluster_id": "cluster_0259",
      "examples": [
        {
          "id": "ex_0283_bdce8c76",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Strategy parameters\nquantity = 100\nentry_price = None\nposition = 0\n\ndef on_tick(ticker):\n    global entry_price, position\n    price = ticker.last\n    \n    if price is None or price != price:  # NaN check\n        return\n    \n    # Entry logic\n    if position == 0 and should_enter(price):\n        order = MarketOrder('BUY', quantity)\n        trade = ib.placeOrder(contract, order)\n        entry_price = price\n        position = quantity\n        print(f\"ENTRY: Buy {quantity} @ {price}\")\n    \n    # Exit logic\n    elif position > 0 and should_exit(price, entry_price):\n        order = MarketOrder('SELL', quantity)\n        trade = ib.placeOrder(contract, order)\n        profit = (price - entry_price) * quantity\n        print(f\"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}\")\n        position = 0\n        entry_price = None\n\ndef should_enter(price):\n    # Your entry logic\n    return False\n\ndef should_exit(price, entry):\n    # Your exit logic (e.g., stop loss, take profit)\n    return False\n\nticker = ib.reqMktData(contract, '233', False, False)\nticker.updateEvent += on_tick\n\nib.run()",
          "language": "python",
          "context": " Pattern: Automated Trading Strategy",
          "source_file": "ib_complete_reference.md",
          "line_number": 1517,
          "heading": "Pattern: Automated Trading Strategy",
          "tags": [
            "connect",
            "contract",
            "data",
            "error",
            "event",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0283_bdce8c76"
    },
    {
      "cluster_id": "cluster_0260",
      "examples": [
        {
          "id": "ex_0284_51b7c018",
          "code": "from ib_insync import *\nimport pandas as pd\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Download multiple timeframes\ntimeframes = [\n    ('1 Y', '1 day'),\n    ('6 M', '1 hour'),\n    ('30 D', '15 mins')\n]\n\nall_data = {}\nfor duration, barsize in timeframes:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=barsize,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    df = util.df(bars)\n    all_data[f'{duration}_{barsize}'] = df\n    print(f\"Downloaded {len(bars)} {barsize} bars for {duration}\")\n\n# Save to files\nfor name, df in all_data.items():\n    df.to_csv(f\"{contract.symbol}_{name}.csv\", index=False)\n\nib.disconnect()",
          "language": "python",
          "context": " Pattern: Historical Data Download",
          "source_file": "ib_complete_reference.md",
          "line_number": 1570,
          "heading": "Pattern: Historical Data Download",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0284_51b7c018"
    },
    {
      "cluster_id": "cluster_0261",
      "examples": [
        {
          "id": "ex_0285_a059ab35",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef show_portfolio():\n    print(\"\\n=== PORTFOLIO ===\")\n    for item in ib.portfolio():\n        symbol = item.contract.symbol\n        pos = item.position\n        price = item.marketPrice\n        value = item.marketValue\n        pnl = item.unrealizedPNL\n        print(f\"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}\")\n    \n    print(\"\\n=== ACCOUNT ===\")\n    values = ib.accountValues()\n    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']\n    for value in values:\n        if value.tag in important_tags:\n            print(f\"{value.tag:20} | {value.value:15} {value.currency}\")\n\ndef on_update(item):\n    show_portfolio()\n\n# Show initial state\nshow_portfolio()\n\n# Update on changes\nib.updatePortfolioEvent += on_update\n\nib.run()",
          "language": "python",
          "context": " Pattern: Portfolio Monitor",
          "source_file": "ib_complete_reference.md",
          "line_number": 1609,
          "heading": "Pattern: Portfolio Monitor",
          "tags": [
            "connect",
            "contract",
            "event",
            "portfolio"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0285_a059ab35"
    },
    {
      "cluster_id": "cluster_0262",
      "examples": [
        {
          "id": "ex_0286_c1f31f77",
          "code": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\n# Get option chain\nchains = ib.reqSecDefOptParams(\n    underlying.symbol,\n    '',\n    underlying.secType,\n    underlying.conId\n)\n\nprint(f\"Found {len(chains)} option chains\")\n\n# Get chain for specific exchange\nchain = next(c for c in chains if c.exchange == 'SMART')\nprint(f\"Trading class: {chain.tradingClass}\")\nprint(f\"Expirations: {sorted(chain.expirations)[:5]}\")  # First 5\nprint(f\"Strike range: {min(chain.strikes)} - {max(chain.strikes)}\")\n\n# Request contracts for specific expiration\nexpiration = sorted(chain.expirations)[0]\nstrikes = sorted([s for s in chain.strikes if 400 < s < 500])\n\ncontracts = [\n    Option('SPY', expiration, strike, right, 'SMART')\n    for strike in strikes[:5]\n    for right in ['C', 'P']\n]\n\n# Qualify and get details\ncontracts = ib.qualifyContracts(*contracts)\n\n# Request market data\nfor contract in contracts:\n    ticker = ib.reqMktData(contract, '', False, False)\n    ib.sleep(1)\n    print(f\"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}\")\n\nib.disconnect()",
          "language": "python",
          "context": " Pattern: Option Chain Analysis",
          "source_file": "ib_complete_reference.md",
          "line_number": 1645,
          "heading": "Pattern: Option Chain Analysis",
          "tags": [
            "connect",
            "contract",
            "data"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0286_c1f31f77"
    },
    {
      "cluster_id": "cluster_0263",
      "examples": [
        {
          "id": "ex_0287_6fea4d44",
          "code": "# Solutions:\n# 1. Check TWS/Gateway is running\n# 2. Check correct port (7497=TWS, 4001=Gateway)\n# 3. Enable API in TWS settings\n# 4. Check firewall\n# 5. Verify clientId is unique\n\n# Test connection\nimport socket\nsock = socket.socket()\ntry:\n    sock.connect(('127.0.0.1', 7497))\n    print(\"Port is open\")\nexcept:\n    print(\"Cannot connect to port\")\nfinally:\n    sock.close()",
          "language": "python",
          "context": "Error 502: Couldn't connect to TWS",
          "source_file": "ib_complete_reference.md",
          "line_number": 1699,
          "heading": "Connection Issues",
          "tags": [
            "connect",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0287_6fea4d44"
    },
    {
      "cluster_id": "cluster_0264",
      "examples": [
        {
          "id": "ex_0288_6880db86",
          "code": "# Check API settings in TWS:\n# Configuration -> API -> Settings\n# - Enable ActiveX and Socket Clients\n# - Socket port: 7497 (TWS) or 4001 (Gateway)\n# - Trusted IPs: 127.0.0.1\n# - Master API client ID: (optional)",
          "language": "python",
          "context": "Error 326: Unable to connect",
          "source_file": "ib_complete_reference.md",
          "line_number": 1720,
          "heading": "Test connection",
          "tags": [
            "connect",
            "contract",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0288_6880db86"
    },
    {
      "cluster_id": "cluster_0265",
      "examples": [
        {
          "id": "ex_0290_5eea209b",
          "code": "# Don't use waitOnUpdate() loop for ticks - data loss!\n\n# \u274c BAD\nwhile True:\n    ib.waitOnUpdate()\n    # Some ticks lost!\n\n# \u2705 GOOD - Use events\nticker.updateEvent += lambda t: process(t)",
          "language": "python",
          "context": "Missing tick data",
          "source_file": "ib_complete_reference.md",
          "line_number": 1743,
          "heading": "3. Use reqMarketDataType(4) for frozen delayed",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0290_5eea209b"
    },
    {
      "cluster_id": "cluster_0266",
      "examples": [
        {
          "id": "ex_0292_6d4e3880",
          "code": "# Check:\n# 1. Correct clientId\n# 2. \"Download open orders on connection\" enabled in TWS\n# 3. Use ib.openOrders() not ib.reqOpenOrders()\n\n# Sync orders\nib.reqOpenOrders()  # Legacy, can be stale\nib.openOrders()     # Better - auto-synced",
          "language": "python",
          "context": "Orders not showing",
          "source_file": "ib_complete_reference.md",
          "line_number": 1771,
          "heading": "Debug:",
          "tags": [
            "connect",
            "order"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0292_6d4e3880"
    },
    {
      "cluster_id": "cluster_0267",
      "examples": [
        {
          "id": "ex_0293_aec1b4a0",
          "code": "# Common causes:\n# 1. Requesting too much data\n# 2. Invalid date range\n# 3. Contract not found\n# 4. No data available for period\n\n# Solution: Break into chunks\ndt = ''\nall_bars = []\nwhile True:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime=dt,\n        durationStr='30 D',\n        barSizeSetting='1 hour',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    if not bars:\n        break\n    all_bars.extend(bars)\n    dt = bars[0].date\n    ib.sleep(1)  # Respect rate limits",
          "language": "python",
          "context": "Error 162: Historical Market Data Service error",
          "source_file": "ib_complete_reference.md",
          "line_number": 1785,
          "heading": "Historical Data Issues",
          "tags": [
            "contract",
            "data",
            "error"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0293_aec1b4a0"
    },
    {
      "cluster_id": "cluster_0268",
      "examples": [
        {
          "id": "ex_0294_41afd91b",
          "code": "# Solutions:\n# 1. Reduce simultaneous requests\n# 2. Use batch requests where possible\n# 3. Increase TWS memory allocation\n# 4. Use keepUpToDate for live bars instead of repeated requests\n\n# Increase TWS memory:\n# Configuration -> Settings -> Memory Allocation -> 4096 MB",
          "language": "python",
          "context": "Slow responses",
          "source_file": "ib_complete_reference.md",
          "line_number": 1814,
          "heading": "Performance Issues",
          "tags": []
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0294_41afd91b"
    },
    {
      "cluster_id": "cluster_0269",
      "examples": [
        {
          "id": "ex_0295_b291fa9b",
          "code": "# IB throttles automatically at 45 req/sec\n# Monitor throttle events:\n\ndef on_throttle_start():\n    print(\"Throttling started\")\n\ndef on_throttle_end():\n    print(\"Throttling ended\")\n\nib.client.throttleStart += on_throttle_start\nib.client.throttleEnd += on_throttle_end",
          "language": "python",
          "context": "Too many requests",
          "source_file": "ib_complete_reference.md",
          "line_number": 1826,
          "heading": "Configuration -> Settings -> Memory Allocation -> 4096 MB",
          "tags": [
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0295_b291fa9b"
    },
    {
      "cluster_id": "cluster_0270",
      "examples": [
        {
          "id": "ex_0296_3cf79bd0",
          "code": "# At start of notebook:\nutil.startLoop()\n\n# If still issues:\nutil.patchAsyncio()\n\n# For old notebooks:\nimport nest_asyncio\nnest_asyncio.apply()",
          "language": "python",
          "context": "Event loop conflicts",
          "source_file": "ib_complete_reference.md",
          "line_number": 1843,
          "heading": "Jupyter Notebook Issues",
          "tags": [
            "async",
            "event"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0296_3cf79bd0"
    },
    {
      "cluster_id": "cluster_0271",
      "examples": [
        {
          "id": "ex_0297_f097284e",
          "code": "# Cancel unused tickers\nfor contract in old_contracts:\n    ib.cancelMktData(contract)\n\n# Clear refs\ndel ticker",
          "language": "python",
          "context": "Ticker accumulation",
          "source_file": "ib_complete_reference.md",
          "line_number": 1858,
          "heading": "Memory Leaks",
          "tags": [
            "contract"
          ]
        }
      ],
      "similarity_score": 1.0,
      "canonical": "ex_0297_f097284e"
    }
  ],
  "stats": {
    "clusters": 272,
    "singleton_clusters": 255,
    "multi_example_clusters": 17,
    "max_cluster_size": 5
  },
  "cost_info": {
    "total_cost": 0.0563,
    "input_tokens": 9408.0,
    "output_tokens": 23342.0,
    "total_tokens": 32750.0
  }
}