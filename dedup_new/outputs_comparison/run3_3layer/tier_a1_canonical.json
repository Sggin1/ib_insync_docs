[{"id":"merged_cluster_0003","topic":"Creates a bracket order with entry, take profit, a","tier":"a1","confidence":0.95,"tags":["ct","or","er"],"content":{"code":"parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 175.0,\n    takeProfitPrice=185.0,\n    stopLossPrice=170.0\n)\n\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)","language":"python","description":"Creates a bracket order with entry, take profit, and stop loss orders. The parent order is a BUY order for 100 contracts at 175.0, with profit-taking at 185.0 and stop loss at 170.0. All three orders are placed sequentially using a loop. This pattern ensures risk management by automatically setting profit targets and loss limits. Works for both stock and derivatives trading."},"stats":{"mentions":2,"sources":["ex_0004_1edc2880","ex_0278_3d95d75e"]}},{"id":"merged_cluster_0004","topic":"Creates a trailing stop order that tracks price mo","tier":"a1","confidence":0.95,"tags":["or","ct"],"content":{"code":"order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # Trail by 2%\norder.tif = 'GTC'\n\n# Requires valid contract object\n# trade = ib.placeOrder(contract, order)","language":"python","description":"Creates a trailing stop order that tracks price movements by percentage. Specifies SELL action, 100 shares, 2% trailing offset, and Good-Til-Canceled duration. Includes order placement example requiring a valid contract object. Suitable for percentage-based trailing stop loss strategies."},"stats":{"mentions":2,"sources":["ex_0005_a46437c8","ex_0153_fcded4d3"]}},{"id":"merged_cluster_0006","topic":"Creates a TWAP (Time-Weighted Average Price) order","tier":"a1","confidence":0.95,"tags":["or","ct","twp"],"content":{"code":"order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1')\n]\n\n# Requires contract definition before placement:\n# trade = ib.placeOrder(contract, order)","language":"python","description":"Creates a TWAP (Time-Weighted Average Price) order for large orders. Specifies limit price, duration (09:30-16:00 EST), and allows order execution past the end time. Requires order placement with a valid contract. Combines core order configuration with optional past-end-time allowance parameter."},"stats":{"mentions":2,"sources":["ex_0007_aba79f2a","ex_0160_aae7547e"]}},{"id":"merged_cluster_0011","topic":"Modifies an existing order by updating its limit p","tier":"a1","confidence":0.95,"tags":["ct","or","mdf","lmt","trad"],"content":{"code":"order.lmtPrice = 176.0\ntrade = ib.placeOrder(contract, order)","language":"python","description":"Modifies an existing order by updating its limit price attribute and submits the modified order using the `placeOrder` method. The `order` object must be an active existing order, and the `contract` must match the original instrument. After updating relevant order attributes (e.g., `lmtPrice` for limit orders), calling `placeOrder` with the same contract/order pair triggers modification rather than creating a new order."},"stats":{"mentions":2,"sources":["ex_0012_ae79ffd3","ex_0219_e7868613"]}},{"id":"merged_cluster_0014","topic":"Creates a vertical spread (debit) or calendar spre","tier":"a1","confidence":0.95,"tags":["ct","or","spr","ptn"],"content":{"code":"buy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=buy_call.conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=sell_call.conId, ratio=1, action='SELL', exchange='SMART')\n]\n\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread\ntrade = ib.placeOrder(combo, order)","language":"python","description":"Creates a vertical spread (debit) or calendar spread using combo contracts. The pattern involves: 1) Defining option legs with matching underlying but different strikes/expirations, 2) Qualifying contracts, 3) Building a BAG contract with combo legs specifying buy/sell actions, and 4) Placing a limit order. Works for both vertical spreads (same expiration, different strikes) and calendar spreads (same strike, different expirations) by adjusting leg parameters."},"stats":{"mentions":2,"sources":["ex_0015_e4716efb","ex_0166_08a5d66a"]}},{"id":"merged_cluster_0019","topic":"Demonstrates incorrect pattern of repeatedly polli","tier":"a1","confidence":0.95,"tags":["da","vnt"],"content":{"code":"while True:\n    bars = ib.reqHistoricalData(...)  # DON'T POLL!\n    time.sleep(5)  # Also wrong - blocks event loop!","language":"python","description":"Demonstrates incorrect pattern of repeatedly polling historical data in a blocking loop. This approach violates API best practices by 1) Using historical requests instead of real-time streaming 2) Blocking the event loop with sleep() which prevents processing of messages and events. Use real-time market data subscriptions instead of polling historical endpoints."},"stats":{"mentions":2,"sources":["ex_0020_eb569bed","ex_0267_ecb56a32"]}},{"id":"merged_cluster_0027","topic":"Requests historical market data for a financial in","tier":"a1","confidence":0.95,"tags":["ct","da","pnd","frx","hst"],"content":{"code":"contract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',          # '' = now\n    durationStr='30 D',      # 30 days\n    barSizeSetting='1 hour',\n    whatToShow='TRADES',     # Can be MIDPOINT for FX\n    useRTH=True              # Regular hours only\n)\n\n# Convert to pandas\ndf = util.df(bars)\nprint(df.head())","language":"python","description":"Requests historical market data for a financial instrument (e.g. Forex EURUSD) and converts it to pandas DataFrame. Supports specifying time range (30 days back from now), bar size (1 hour), data type (TRADES for actual trades or MIDPOINT for FX), and regular trading hours filtering. Demonstrates IBKR's API usage with automatic pandas conversion."},"stats":{"mentions":2,"sources":["ex_0028_df8dcf24","ex_0237_f1541456"]}},{"id":"merged_cluster_0035","topic":"Sets the market data type for Interactive Brokers ","tier":"a1","confidence":0.95,"tags":["mrk","sbs","dly","rrr","cnn","rqm"],"content":{"code":"# Market Data Types:\n# 1 = Live (subscription required)\n# 2 = Frozen (snapshot)\n# 3 = Delayed (free, 15-min delay)\n# 4 = Delayed-Frozen\nib.reqMarketDataType(3)  # Use delayed data (free)","language":"python","description":"Sets the market data type for Interactive Brokers API connections. Use reqMarketDataType() to specify data quality: (1) Live data requiring subscription, (2) Frozen snapshots, (3) Free delayed data with 15-minute latency, or (4) Delayed-Frozen data. Type 3 is recommended for free access without subscriptions. This also resolves Error 354 ('Requested market data not subscribed') when accounts lack real-time data permissions."},"stats":{"mentions":2,"sources":["ex_0036_b007e6a8","ex_0289_2973e326"]}},{"id":"merged_cluster_0091","topic":"Requests historical bars with real-time updates. W","tier":"a1","confidence":0.95,"tags":["ct","da","vnt"],"content":{"code":"contract = Stock('TSLA', 'SMART', 'USD')\n\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    formatDate=1,\n    keepUpToDate=True  # Enables live updates\n)","language":"python","description":"Requests historical bars with real-time updates. When keepUpToDate=True, the bars list automatically receives live updates after initial historical load. The updateEvent fires on changes. Uses regular trading hours (useRTH=True), formats timestamps as epoch seconds (formatDate=1), and shows trade data (TRADES). TSLA contract specified with SMART routing."},"stats":{"mentions":2,"sources":["ex_0092_27c9aee2","ex_0244_39f6deda"]}},{"id":"merged_cluster_0123","topic":"Represents financial contracts for various asset t","tier":"a1","confidence":0.95,"tags":["ct"],"content":{"code":"class ib_insync.contract.Forex(pair='', exchange='IDEALPRO', symbol='', currency='', **kwargs)\n\nForeign exchange currency pair.\n\n**Parameters:**\n- **pair** (str) - Shortcut for specifying symbol and currency, like 'EURUSD'.\n- **exchange** (str) - Destination exchange.\n- **symbol** (str) - Base currency.\n- **currency** (str) - Quote currency.\n\npair()\nShort name of pair.\nReturn type: str\n\ndict()\nReturn dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\nReturn type: dict\n\nnonDefaults()\nFor a dataclass instance get the fields that are different from the default values and return as dict.\nReturn type: dict\n\ntuple()\nReturn dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\nReturn type: tuple\n\nupdate(*srcObjs, **kwargs)\nUpdate fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\nReturn type: object\n\ncomboLegs: List[ComboLeg]","language":"python","description":"Represents financial contracts for various asset types including Forex, Index, CFD, Commodity, and Crypto. Common parameters include 'symbol' (asset identifier), 'exchange' (destination exchange), and 'currency' (underlying currency). Forex contracts additionally use 'pair' as a shortcut for symbol/currency (e.g., 'EURUSD'). All contracts inherit methods to convert to dict/tuple, track non-default fields, update attributes, and manage combo legs. Forex includes a dedicated pair() method to return the currency pair name."},"stats":{"mentions":5,"sources":["ex_0124_a85b6a7f","ex_0125_2b6f6a6e","ex_0126_d4626d75","ex_0127_8675ebd8","ex_0133_dff73d92"]}},{"id":"merged_cluster_0124","topic":"Represents a financial contract in IBKR systems. T","tier":"a1","confidence":0.95,"tags":["ct","dtc","bkr","trd"],"content":{"code":"class ib_insync.contract.ContractType(**kwargs)\n    [Contract Type Description]\n\n    dict()\n        Return dataclass values as dict. This is a non-recursive variant of dataclasses.asdict.\n        Return type: dict\n\n    nonDefaults()\n        For a dataclass instance get the fields that are different from the default values and return as dict.\n        Return type: dict\n\n    tuple()\n        Return dataclass values as tuple. This is a non-recursive variant of dataclasses.astuple.\n        Return type: tuple\n\n    update(*srcObjs, **kwargs)\n        Update fields of the given dataclass object from zero or more dataclass source objects and/or from keyword arguments.\n        Return type: object\n\n    comboLegs: List[ComboLeg]","language":"python","description":"Represents a financial contract in IBKR systems. This generic template applies to Bond, MutualFund, Warrant, and Bag contract types. All share identical methods: 1) dict() converts object to dictionary (non-recursive dataclasses.asdict), 2) nonDefaults() returns non-default fields as dict, 3) tuple() converts object to tuple (non-recursive dataclasses.astuple), 4) update() merges fields from other objects/keyword arguments. All contain a comboLegs attribute for multi-leg strategies. Contract-specific descriptions replace '[Contract Type Description]' (e.g., 'Bond' for bonds, 'Mutual fund' for mutual funds)."},"stats":{"mentions":4,"sources":["ex_0128_45d7fdfc","ex_0130_970fbdd1","ex_0131_d0953ca2","ex_0132_e65c45ce"]}},{"id":"merged_cluster_0129","topic":"Demonstrates asynchronous streaming of real-time m","tier":"a1","confidence":0.95,"tags":["as","co","ct","da","vnt","mrk","str","rl-"],"content":{"code":"import asyncio\nimport ib_insync as ibi\n\nclass App:\n    async def run(self):\n        self.ib = ibi.IB()\n        with await self.ib.connectAsync():\n            contracts = [\n                ibi.Stock(symbol, 'SMART', 'USD')\n                for symbol in ['AAPL', 'TSLA', 'AMD', 'INTC']]\n            for contract in contracts:\n                self.ib.reqMktData(contract)\n            async for tickers in self.ib.pendingTickersEvent:\n                for ticker in tickers:\n                    print(ticker)\n\n    def stop(self):\n        self.ib.disconnect()\n\napp = App()\ntry:\n    asyncio.run(app.run())\nexcept (KeyboardInterrupt, SystemExit):\n    app.stop()","language":"python","description":"Demonstrates asynchronous streaming of real-time market data (ticks) for multiple stocks using IB API. Establishes connection using async context manager, requests market data for specified contracts (AAPL, TSLA, AMD, INTC), and continuously processes incoming tick updates via the pendingTickersEvent. Includes graceful shutdown handling for KeyboardInterrupt/SystemExit events by disconnecting from IB gateway."},"stats":{"mentions":2,"sources":["ex_0137_80aea104","ex_0147_490b705b"]}},{"id":"merged_cluster_0144","topic":"Places advanced order types in Interactive Brokers","tier":"a1","confidence":0.95,"tags":["or","ct","trl","pgg","rlt"],"content":{"code":"order = Order()\norder.action = 'BUY'  # or 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'  # can be TRAIL, TRAIL LIMIT, PEG MID, PEG BEST, REL\n# For TRAIL: set auxPrice (fixed trail amount)\n# For TRAIL LIMIT: set lmtPriceOffset and trailingPercent\n# For PEG MID/PEG BEST: no additional price fields\n# For REL: set lmtPrice (offset from NBBO)\norder.tif = 'GTC'  # or other time in force\n\ntrade = ib.placeOrder(contract, order)","language":"python","description":"Places advanced order types in Interactive Brokers API. Covers:\n1. Trailing Stop Loss (Fixed Amount): Uses 'TRAIL' orderType with auxPrice for fixed trail amount\n2. Trailing Stop Limit: Uses 'TRAIL LIMIT' orderType with lmtPriceOffset (limit offset) and trailingPercent (trail percentage)\n3. Pegged to Market (Midpoint): Uses 'PEG MID' orderType for midpoint pegging\n4. Pegged to Best Bid/Ask: Uses 'PEG BEST' orderType for best bid/ask pegging\n5. Relative Order: Uses 'REL' orderType with lmtPrice for offset from NBBO\nCommon parameters: action (BUY/SELL), totalQuantity, orderType, tif (time in force). All orders use ib.placeOrder() with contract."},"stats":{"mentions":5,"sources":["ex_0154_22d3f273","ex_0155_6b1a9a90","ex_0156_50051a29","ex_0157_92bd3785","ex_0158_e5fd845a"]}},{"id":"merged_cluster_0198","topic":"Represents stop and stop-limit order types. Stop o","tier":"a1","confidence":0.95,"tags":["or","stp","stop"],"content":{"code":"StopLimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    stopPrice: float,\n    **kwargs\n)","language":"python","description":"Represents stop and stop-limit order types. Stop orders become market orders when the stop price is reached. Stop-limit orders become limit orders with both a stop price (trigger) and limit price (execution constraint). Use StopOrder for basic stop-loss orders (single price trigger) and StopLimitOrder for price-controlled executions."},"stats":{"mentions":2,"sources":["ex_0215_9836d086","ex_0216_1e588943"]}},{"id":"merged_cluster_0204","topic":"The whatIfOrder method tests an order without plac","tier":"a1","confidence":0.95,"tags":["ct","or","er","mrg"],"content":{"code":"orderState = ib.whatIfOrder(contract, order)\n# Test order without placing\n# Returns OrderState with commission/margin impact\n\n# OrderState fields:\n# .initMarginBefore\n# .maintMarginBefore\n# .equityWithLoanBefore\n# .initMarginAfter\n# .maintMarginAfter\n# .equityWithLoanAfter\n# .commission\n# .minCommission\n# .maxCommission\n# .commissionCurrency","language":"python","description":"The whatIfOrder method tests an order without placing it, returning an OrderState object containing margin and commission impacts. Use this to validate order feasibility, check margin requirements, estimate commissions, and debug order rejection reasons like insufficient buying power or invalid parameters. Includes pre-trade and post-trade account metrics for analysis."},"stats":{"mentions":2,"sources":["ex_0223_b7055bc8","ex_0291_302efcfd"]}},{"id":"merged_cluster_0208","topic":"Cancels real-time market data subscriptions. Use c","tier":"a1","confidence":0.95,"tags":["ct","mark","mark"],"content":{"code":"ib.cancelMktData(contract: Contract) -> None\nib.cancelMktDepth(contract: Contract) -> None","language":"python","description":"Cancels real-time market data subscriptions. Use cancelMktData to stop receiving market data (e.g., last price, bid/ask) for a specific contract. Use cancelMktDepth to stop receiving market depth (order book level 2) data for a specific contract. Both require the original Contract object used for subscription."},"stats":{"mentions":2,"sources":["ex_0227_032293ce","ex_0230_ad78b745"]}}]