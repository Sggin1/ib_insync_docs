[
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\n# Jupyter notebook? Uncomment:\n# util.startLoop()\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Get account info\naccount = ib.managedAccounts()[0]\nprint(f\"Connected to account: {account}\")\n\n# Create contract\ncontract = Stock('AAPL', 'SMART', 'USD')\n\n# Get market data\nticker = ib.reqMktData(contract)\nib.sleep(2)  # Wait for data\nprint(ticker.marketPrice())\n\nib.disconnect()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "events = (\n    'connectedEvent',       # Connection established\n    'disconnectedEvent',    # Connection lost\n    'updateEvent',          # Any state update\n    'pendingTickersEvent',  # Ticker updates available\n    'barUpdateEvent',       # Real-time bar update\n    'newOrderEvent',        # New order created\n    'orderModifyEvent',     # Order modified\n    'cancelOrderEvent',     # Order cancel requested\n    'openOrderEvent',       # Open order status\n    'orderStatusEvent',     # Order status changed\n    'execDetailsEvent',     # Trade execution details\n    'commissionReportEvent',# Commission report\n    'updatePortfolioEvent', # Portfolio updated\n    'positionEvent',        # Position changed\n    'accountValueEvent',    # Account value updated\n    'accountSummaryEvent',  # Account summary updated\n    'pnlEvent',            # PnL update\n    'pnlSingleEvent',      # Single position PnL\n    'scannerDataEvent',    # Scanner data received\n    'tickNewsEvent',       # News tick\n    'newsBulletinEvent',   # News bulletin\n    'errorEvent',          # Error occurred\n    'timeoutEvent'         # Request timeout\n)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "ib.connect(\n    host: str = '127.0.0.1',\n    port: int = 7497,           # 7497=TWS, 4001=Gateway\n    clientId: int = 1,          # Unique per connection\n    timeout: float = 2.0,       # Connection timeout (0=no limit)\n    readonly: bool = False,     # Read-only mode\n    account: str = '',          # Main account for updates\n    raiseSyncErrors: bool = True # Raise sync errors\n) -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "await ib.connectAsync(\n    host, port, clientId, \n    timeout, readonly, account, raiseSyncErrors\n) -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "ib.disconnect() -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "ib.isConnected() -> bool\nib.client.isReady() -> bool  # API ready",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "ib.run()  # Run until disconnect\nawait ib.runAsync()  # Async version\n\n# Condition-based iteration\nfor update in ib.loopUntil(timeout=60):\n    if condition:\n        break",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Events use eventkit library\n\n# Subscribe to event\ndef onPendingTickers(tickers):\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.marketPrice()}\")\n\nib.pendingTickersEvent += onPendingTickers\n\n# Unsubscribe\nib.pendingTickersEvent -= onPendingTickers\n\n# One-time handler\nib.connectedEvent += lambda: print('Connected!')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Connected\nib.connectedEvent += lambda: print('Connected to TWS')\n\n# Disconnected\nib.disconnectedEvent += lambda: print('Disconnected')\n\n# Error\nib.errorEvent += lambda reqId, errorCode, errorString, contract: \\\n    print(f'Error {errorCode}: {errorString}')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "try:\n    ticker = ib.reqMktData(contract)\n    # ... do work ...\nfinally:\n    ib.cancelMktData(contract)\n    ib.disconnect()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "def on_disconnect():\n    print(\"Disconnected! Attempting reconnect...\")\n    reconnect_logic()\n\nib.disconnectedEvent += on_disconnect",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "ib = IB()\nib.RequestTimeout = 30  # 30 second timeout\nib.RaiseRequestErrors = True  # Raise exceptions\n\ntry:\n    ib.connect('127.0.0.1', 7497, clientId=1, timeout=10)\nexcept asyncio.TimeoutError:\n    print(\"Connection timeout!\")",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\ncontracts = ib.qualifyContracts(*contracts)\n\ndef on_pending_tickers(tickers):\n    for ticker in tickers:\n        symbol = ticker.contract.symbol\n        price = ticker.marketPrice()\n        volume = ticker.volume\n        print(f\"{symbol}: ${price:.2f} | Vol: {volume}\")\n\nib.pendingTickersEvent += on_pending_tickers\n\n# Subscribe to all\nfor contract in contracts:\n    ib.reqMktData(contract, '', False, False)\n\n# Run forever\nib.run()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Forex('EURUSD')\ncontract = ib.qualifyContracts(contract)[0]\n\ndef on_bar_update(bars, hasNewBar):\n    if hasNewBar:\n        bar = bars[-1]\n        print(f\"New 5s bar: {bar.date} O:{bar.open} H:{bar.high} L:{bar.low} C:{bar.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += on_bar_update\n\nib.run()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Strategy parameters\nquantity = 100\nentry_price = None\nposition = 0\n\ndef on_tick(ticker):\n    global entry_price, position\n    price = ticker.last\n    \n    if price is None or price != price:  # NaN check\n        return\n    \n    # Entry logic\n    if position == 0 and should_enter(price):\n        order = MarketOrder('BUY', quantity)\n        trade = ib.placeOrder(contract, order)\n        entry_price = price\n        position = quantity\n        print(f\"ENTRY: Buy {quantity} @ {price}\")\n    \n    # Exit logic\n    elif position > 0 and should_exit(price, entry_price):\n        order = MarketOrder('SELL', quantity)\n        trade = ib.placeOrder(contract, order)\n        profit = (price - entry_price) * quantity\n        print(f\"EXIT: Sell {quantity} @ {price} | Profit: ${profit:.2f}\")\n        position = 0\n        entry_price = None\n\ndef should_enter(price):\n    # Your entry logic\n    return False\n\ndef should_exit(price, entry):\n    # Your exit logic (e.g., stop loss, take profit)\n    return False\n\nticker = ib.reqMktData(contract, '233', False, False)\nticker.updateEvent += on_tick\n\nib.run()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\nimport pandas as pd\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\n# Download multiple timeframes\ntimeframes = [\n    ('1 Y', '1 day'),\n    ('6 M', '1 hour'),\n    ('30 D', '15 mins')\n]\n\nall_data = {}\nfor duration, barsize in timeframes:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime='',\n        durationStr=duration,\n        barSizeSetting=barsize,\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    df = util.df(bars)\n    all_data[f'{duration}_{barsize}'] = df\n    print(f\"Downloaded {len(bars)} {barsize} bars for {duration}\")\n\n# Save to files\nfor name, df in all_data.items():\n    df.to_csv(f\"{contract.symbol}_{name}.csv\", index=False)\n\nib.disconnect()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef show_portfolio():\n    print(\"\\n=== PORTFOLIO ===\")\n    for item in ib.portfolio():\n        symbol = item.contract.symbol\n        pos = item.position\n        price = item.marketPrice\n        value = item.marketValue\n        pnl = item.unrealizedPNL\n        print(f\"{symbol:6} | Pos: {pos:6} | Price: ${price:8.2f} | Value: ${value:10.2f} | PnL: ${pnl:8.2f}\")\n    \n    print(\"\\n=== ACCOUNT ===\")\n    values = ib.accountValues()\n    important_tags = ['NetLiquidation', 'TotalCashValue', 'BuyingPower', 'GrossPositionValue']\n    for value in values:\n        if value.tag in important_tags:\n            print(f\"{value.tag:20} | {value.value:15} {value.currency}\")\n\ndef on_update(item):\n    show_portfolio()\n\n# Show initial state\nshow_portfolio()\n\n# Update on changes\nib.updatePortfolioEvent += on_update\n\nib.run()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\n# Get option chain\nchains = ib.reqSecDefOptParams(\n    underlying.symbol,\n    '',\n    underlying.secType,\n    underlying.conId\n)\n\nprint(f\"Found {len(chains)} option chains\")\n\n# Get chain for specific exchange\nchain = next(c for c in chains if c.exchange == 'SMART')\nprint(f\"Trading class: {chain.tradingClass}\")\nprint(f\"Expirations: {sorted(chain.expirations)[:5]}\")  # First 5\nprint(f\"Strike range: {min(chain.strikes)} - {max(chain.strikes)}\")\n\n# Request contracts for specific expiration\nexpiration = sorted(chain.expirations)[0]\nstrikes = sorted([s for s in chain.strikes if 400 < s < 500])\n\ncontracts = [\n    Option('SPY', expiration, strike, right, 'SMART')\n    for strike in strikes[:5]\n    for right in ['C', 'P']\n]\n\n# Qualify and get details\ncontracts = ib.qualifyContracts(*contracts)\n\n# Request market data\nfor contract in contracts:\n    ticker = ib.reqMktData(contract, '', False, False)\n    ib.sleep(1)\n    print(f\"{contract.right} {contract.strike:7.2f} | Bid: {ticker.bid:6.2f} | Ask: {ticker.ask:6.2f} | IV: {ticker.impliedVolatility:.2%}\")\n\nib.disconnect()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Solutions:\n# 1. Check TWS/Gateway is running\n# 2. Check correct port (7497=TWS, 4001=Gateway)\n# 3. Enable API in TWS settings\n# 4. Check firewall\n# 5. Verify clientId is unique\n\n# Test connection\nimport socket\nsock = socket.socket()\ntry:\n    sock.connect(('127.0.0.1', 7497))\n    print(\"Port is open\")\nexcept:\n    print(\"Cannot connect to port\")\nfinally:\n    sock.close()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Check:\n# 1. Correct clientId\n# 2. \"Download open orders on connection\" enabled in TWS\n# 3. Use ib.openOrders() not ib.reqOpenOrders()\n\n# Sync orders\nib.reqOpenOrders()  # Legacy, can be stale\nib.openOrders()     # Better - auto-synced",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Order triggers when SPY hits 450\ncontract = Stock('AAPL', 'SMART', 'USD')\ntrigger_contract = Stock('SPY', 'SMART', 'USD')\n\n# Qualify both\ncontract, trigger_contract = ib.qualifyContracts(contract, trigger_contract)\n\n# Create price condition\ncondition = PriceCondition(\n    condType=1,  # Price\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,  # True = above, False = below\n    price=450.0\n)\n\n# Create order with condition\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [condition]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False\n\ntrade = ib.placeOrder(contract, order)\nprint(f\"Conditional order placed: {trade.order.orderId}\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Define legs\nbuy_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\n# Qualify\nbuy_call, sell_call = ib.qualifyContracts(buy_call, sell_call)\n\n# Create combo contract\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\n# Define legs\nleg1 = ComboLeg()\nleg1.conId = buy_call.conId\nleg1.ratio = 1\nleg1.action = 'BUY'\nleg1.exchange = 'SMART'\n\nleg2 = ComboLeg()\nleg2.conId = sell_call.conId\nleg2.ratio = 1\nleg2.action = 'SELL'\nleg2.exchange = 'SMART'\n\ncombo.comboLegs = [leg1, leg2]\n\n# Place order\norder = LimitOrder('BUY', 10, 5.50)  # Debit spread for $5.50\ntrade = ib.placeOrder(combo, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\nimport logging\n\nclass IBErrorHandler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.error_log = []\n        self.ib.errorEvent += self.on_error\n        \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Centralized error handling\"\"\"\n        error_info = {\n            'time': datetime.now(),\n            'reqId': reqId,\n            'code': errorCode,\n            'message': errorString,\n            'contract': contract\n        }\n        self.error_log.append(error_info)\n        \n        # Categorize and handle\n        if errorCode in [502, 503, 504]:\n            self.handle_connection_error(errorCode, errorString)\n        elif errorCode in [200, 201, 202]:\n            self.handle_order_error(errorCode, errorString, contract)\n        elif errorCode == 162:\n            self.handle_data_error(errorCode, errorString, contract)\n        elif errorCode == 354:\n            self.handle_market_data_subscription_error(errorCode, errorString)\n        elif errorCode in [2104, 2106, 2158]:\n            # Info messages - ignore\n            pass\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def handle_connection_error(self, code, message):\n        \"\"\"Handle connection failures\"\"\"\n        logging.critical(f\"Connection error {code}: {message}\")\n        # Trigger reconnection\n        self.schedule_reconnect()\n    \n    def handle_order_error(self, code, message, contract):\n        \"\"\"Handle order rejections\"\"\"\n        logging.error(f\"Order error {code}: {message} for {contract}\")\n        # Could retry with modified params\n        # Or alert user\n    \n    def handle_data_error(self, code, message, contract):\n        \"\"\"Handle data request failures\"\"\"\n        logging.warning(f\"Data error {code}: {message} for {contract}\")\n        # Retry with different params\n    \n    def handle_market_data_subscription_error(self, code, message):\n        \"\"\"Handle market data subscription issues\"\"\"\n        logging.warning(f\"Market data error {code}: {message}\")\n        # Fall back to delayed data\n        self.ib.reqMarketDataType(3)  # Delayed\n    \n    def schedule_reconnect(self):\n        \"\"\"Schedule reconnection attempt\"\"\"\n        # Implementation in reconnection section\n        pass\n\n# Usage\nib = IB()\nerror_handler = IBErrorHandler(ib)\nib.connect('127.0.0.1', 7497, clientId=1)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "class ReconnectionManager:\n    def __init__(self, host='127.0.0.1', port=7497, clientId=1):\n        self.host = host\n        self.port = port\n        self.clientId = clientId\n        self.ib = None\n        self.reconnect_attempts = 0\n        self.max_reconnect_attempts = 10\n        self.reconnect_delay = 5\n        self.is_connected = False\n        \n    def connect(self):\n        \"\"\"Initial connection with reconnect logic\"\"\"\n        while self.reconnect_attempts < self.max_reconnect_attempts:\n            try:\n                self.ib = IB()\n                self.ib.disconnectedEvent += self.on_disconnect\n                self.ib.errorEvent += self.on_error\n                \n                self.ib.connect(\n                    self.host,\n                    self.port,\n                    self.clientId,\n                    timeout=10\n                )\n                \n                self.is_connected = True\n                self.reconnect_attempts = 0\n                logging.info(f\"Connected to TWS at {self.host}:{self.port}\")\n                \n                # Restore subscriptions\n                self.restore_state()\n                \n                return self.ib\n                \n            except Exception as e:\n                self.reconnect_attempts += 1\n                logging.error(f\"Connection attempt {self.reconnect_attempts} failed: {e}\")\n                \n                if self.reconnect_attempts >= self.max_reconnect_attempts:\n                    logging.critical(\"Max reconnection attempts reached. Giving up.\")\n                    raise\n                \n                logging.info(f\"Retrying in {self.reconnect_delay} seconds...\")\n                time.sleep(self.reconnect_delay)\n                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        self.is_connected = False\n        logging.warning(\"Disconnected from TWS. Attempting reconnect...\")\n        \n        # Save current state\n        self.save_state()\n        \n        # Attempt reconnection\n        self.connect()\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle connection errors\"\"\"\n        if errorCode in [502, 503, 504, 1100, 1101, 1102]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n            if not self.is_connected:\n                self.on_disconnect()\n    \n    def save_state(self):\n        \"\"\"Save subscriptions and state before disconnect\"\"\"\n        if not self.ib:\n            return\n        \n        # Save tickers\n        self.saved_tickers = [\n            (ticker.contract, ticker.genericTickList) \n            for ticker in self.ib.tickers()\n        ]\n        \n        # Save positions (for monitoring)\n        self.saved_positions = [\n            (p.contract, p.position) \n            for p in self.ib.positions()\n        ]\n        \n        logging.info(f\"Saved state: {len(self.saved_tickers)} tickers, {len(self.saved_positions)} positions\")\n    \n    def restore_state(self):\n        \"\"\"Restore subscriptions after reconnect\"\"\"\n        if not hasattr(self, 'saved_tickers'):\n            return\n        \n        logging.info(\"Restoring market data subscriptions...\")\n        \n        # Resubscribe to tickers\n        for contract, genericTickList in self.saved_tickers:\n            try:\n                self.ib.reqMktData(contract, genericTickList, False, False)\n            except Exception as e:\n                logging.error(f\"Failed to restore ticker {contract.symbol}: {e}\")\n        \n        logging.info(\"State restored\")\n\n# Usage\nconn_mgr = ReconnectionManager(host='127.0.0.1', port=7497, clientId=1)\nib = conn_mgr.connect()\n\n# Normal trading operations\n# Connection will auto-reconnect on failure",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "class HeartbeatMonitor:\n    def __init__(self, ib, timeout=60):\n        self.ib = ib\n        self.timeout = timeout\n        self.last_update = time.time()\n        self.ib.updateEvent += self.on_update\n        \n    def on_update(self):\n        \"\"\"Reset timer on any update\"\"\"\n        self.last_update = time.time()\n    \n    def check(self):\n        \"\"\"Check if connection is alive\"\"\"\n        elapsed = time.time() - self.last_update\n        \n        if elapsed > self.timeout:\n            logging.warning(f\"No updates for {elapsed:.0f}s. Connection may be dead.\")\n            return False\n        \n        return True\n    \n    def run(self):\n        \"\"\"Run heartbeat check loop\"\"\"\n        while True:\n            if not self.check():\n                logging.error(\"Heartbeat timeout. Triggering reconnect...\")\n                # Trigger reconnection\n                break\n            \n            time.sleep(10)\n\n# Usage\nheartbeat = HeartbeatMonitor(ib, timeout=60)\n# Run in separate thread or async task",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "class MultiAccountRouter:\n    def __init__(self, host='127.0.0.1', port=7497):\n        self.connections = {}\n        self.host = host\n        self.port = port\n        \n    def add_account(self, account_name, client_id):\n        \"\"\"Add account connection\"\"\"\n        ib = IB()\n        ib.connect(self.host, self.port, client_id)\n        self.connections[account_name] = ib\n        logging.info(f\"Connected account {account_name} with clientId {client_id}\")\n    \n    def place_order_all(self, contract, order_template, quantities):\n        \"\"\"\n        Place orders across multiple accounts\n        \n        Args:\n            contract: Contract to trade\n            order_template: Base order\n            quantities: Dict[account_name, quantity]\n        \"\"\"\n        trades = {}\n        \n        for account_name, quantity in quantities.items():\n            if account_name not in self.connections:\n                logging.error(f\"Account {account_name} not connected\")\n                continue\n            \n            ib = self.connections[account_name]\n            \n            # Clone order\n            order = Order(**{k: v for k, v in order_template.__dict__.items()})\n            order.totalQuantity = quantity\n            order.account = account_name\n            \n            # Place order\n            trade = ib.placeOrder(contract, order)\n            trades[account_name] = trade\n            \n            logging.info(f\"Placed {order.action} {quantity} {contract.symbol} for {account_name}\")\n        \n        return trades\n    \n    def get_combined_portfolio(self):\n        \"\"\"Get combined portfolio across all accounts\"\"\"\n        combined = {}\n        \n        for account_name, ib in self.connections.items():\n            for item in ib.portfolio():\n                symbol = item.contract.symbol\n                \n                if symbol not in combined:\n                    combined[symbol] = {\n                        'position': 0,\n                        'market_value': 0,\n                        'unrealized_pnl': 0,\n                        'accounts': {}\n                    }\n                \n                combined[symbol]['position'] += item.position\n                combined[symbol]['market_value'] += item.marketValue\n                combined[symbol]['unrealized_pnl'] += item.unrealizedPNL\n                combined[symbol]['accounts'][account_name] = item.position\n        \n        return combined\n    \n    def disconnect_all(self):\n        \"\"\"Disconnect all accounts\"\"\"\n        for account_name, ib in self.connections.items():\n            ib.disconnect()\n            logging.info(f\"Disconnected {account_name}\")\n\n# Usage\nrouter = MultiAccountRouter()\nrouter.add_account('Account1', client_id=1)\nrouter.add_account('Account2', client_id=2)\nrouter.add_account('Account3', client_id=3)\n\n# Place order across all accounts\ncontract = Stock('AAPL', 'SMART', 'USD')\norder_template = LimitOrder('BUY', 0, 175.0)  # Quantity set per account\n\nquantities = {\n    'Account1': 100,\n    'Account2': 200,\n    'Account3': 150\n}\n\ntrades = router.place_order_all(contract, order_template, quantities)\n\n# Monitor combined portfolio\ncombined = router.get_combined_portfolio()\nfor symbol, data in combined.items():\n    print(f\"{symbol}: {data['position']} shares across {len(data['accounts'])} accounts\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "\"\"\"\nProduction Trading System Template\nFeatures: Auto-reconnect, error handling, risk management, logging\n\"\"\"\n\nimport logging\nfrom datetime import datetime, time as dt_time\nfrom ib_insync import *\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s',\n    handlers=[\n        logging.FileHandler(f'trading_{datetime.now().strftime(\"%Y%m%d\")}.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass ProductionTradingSystem:\n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self.ib = None\n        self.running = False\n        \n        # Risk parameters\n        self.max_daily_loss_pct = 0.03\n        self.max_position_pct = 0.20\n        self.daily_loss_breached = False\n        \n        # State tracking\n        self.start_equity = 0\n        self.trades_today = []\n        \n    def initialize(self):\n        \"\"\"Initialize system\"\"\"\n        logging.info(\"Initializing trading system...\")\n        \n        # Connect\n        self.ib = IB()\n        self.ib.errorEvent += self.on_error\n        self.ib.disconnectedEvent += self.on_disconnect\n        \n        try:\n            self.ib.connect(self.host, self.port, self.client_id, timeout=10)\n            logging.info(\"Connected to TWS\")\n        except Exception as e:\n            logging.critical(f\"Failed to connect: {e}\")\n            return False\n        \n        # Get starting equity\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        logging.info(f\"Starting equity: ${self.start_equity:,.2f}\")\n        \n        # Setup event handlers\n        self.ib.orderStatusEvent += self.on_order_status\n        self.ib.execDetailsEvent += self.on_execution\n        \n        return True\n    \n    def on_error(self, reqId, errorCode, errorString, contract):\n        \"\"\"Handle errors\"\"\"\n        if errorCode in [502, 503, 504]:\n            logging.error(f\"Connection error {errorCode}: {errorString}\")\n        elif errorCode >= 2000:\n            # Warnings\n            logging.warning(f\"Warning {errorCode}: {errorString}\")\n        else:\n            logging.error(f\"Error {errorCode}: {errorString}\")\n    \n    def on_disconnect(self):\n        \"\"\"Handle disconnection\"\"\"\n        logging.warning(\"Disconnected from TWS\")\n        # Attempt reconnection logic here\n    \n    def on_order_status(self, trade):\n        \"\"\"Track order status\"\"\"\n        logging.info(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    \n    def on_execution(self, trade, fill):\n        \"\"\"Track executions\"\"\"\n        self.trades_today.append(trade)\n        logging.info(f\"Fill: {fill.execution.shares} @ ${fill.execution.price:.2f}\")\n    \n    def check_risk_limits(self):\n        \"\"\"Check if risk limits breached\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        # Daily loss check\n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED: {loss_pct*100:.2f}%\")\n            self.daily_loss_breached = True\n            self.emergency_shutdown()\n            return False\n        \n        return True\n    \n    def emergency_shutdown(self):\n        \"\"\"Emergency shutdown - close all positions\"\"\"\n        logging.critical(\"EMERGENCY SHUTDOWN INITIATED\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        for position in self.ib.positions():\n            qty = abs(position.position)\n            action = 'SELL' if position.position > 0 else 'BUY'\n            \n            order = MarketOrder(action, qty)\n            self.ib.placeOrder(position.contract, order)\n            \n            logging.info(f\"Emergency close: {action} {qty} {position.contract.symbol}\")\n        \n        self.running = False\n    \n    def is_market_hours(self):\n        \"\"\"Check if within trading hours\"\"\"\n        now = datetime.now().time()\n        market_open = dt_time(9, 30)\n        market_close = dt_time(16, 0)\n        \n        return market_open <= now <= market_close\n    \n    def run(self):\n        \"\"\"Main trading loop\"\"\"\n        if not self.initialize():\n            return\n        \n        self.running = True\n        logging.info(\"Trading system started\")\n        \n        try:\n            while self.running:\n                # Check risk limits\n                if not self.check_risk_limits():\n                    break\n                \n                # Only trade during market hours\n                if self.is_market_hours():\n                    # Your trading logic here\n                    self.trading_logic()\n                \n                # Sleep between iterations\n                self.ib.sleep(60)  # Check every minute\n                \n        except KeyboardInterrupt:\n            logging.info(\"Shutdown requested by user\")\n        except Exception as e:\n            logging.critical(f\"Unexpected error: {e}\")\n        finally:\n            self.shutdown()\n    \n    def trading_logic(self):\n        \"\"\"Implement your trading strategy here\"\"\"\n        pass\n    \n    def shutdown(self):\n        \"\"\"Graceful shutdown\"\"\"\n        logging.info(\"Shutting down trading system...\")\n        \n        if self.ib:\n            # Cancel all market data\n            for contract in [t.contract for t in self.ib.tickers()]:\n                self.ib.cancelMktData(contract)\n            \n            # Disconnect\n            self.ib.disconnect()\n        \n        logging.info(\"Shutdown complete\")\n\n# Run the system\nif __name__ == '__main__':\n    system = ProductionTradingSystem(\n        host='127.0.0.1',\n        port=7497,\n        client_id=1\n    )\n    system.run()",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Blocking interface - simple and direct\nfrom ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\nbars = ib.reqHistoricalData(contract, ...)  # Blocks until complete",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Asynchronous interface - non-blocking\nimport asyncio\nfrom ib_insync import *\n\nasync def main():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    bars = await ib.reqHistoricalDataAsync(contract, ...)  # Non-blocking\n    \nasyncio.run(main())",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "# Jupyter notebook setup\nfrom ib_insync import *\n\nutil.startLoop()  # Enables nested event loops\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n# Can now use blocking methods directly in notebook cells",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ndef onTicker(ticker):\n    print(f\"Price update: {ticker.contract.symbol} @ {ticker.last}\")\n\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTicker\n\nib.run()  # Runs event loop indefinitely",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "async def get_multiple_contracts():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    contracts = [\n        Stock('AAPL', 'SMART', 'USD'),\n        Stock('GOOGL', 'SMART', 'USD'),\n        Stock('MSFT', 'SMART', 'USD')\n    ]\n    \n    # Request all contract details concurrently\n    results = await asyncio.gather(*[\n        ib.reqContractDetailsAsync(c) for c in contracts\n    ])\n    \n    return results",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "async def monitor_multiple_tickers():\n    ib = IB()\n    await ib.connectAsync('127.0.0.1', 7497, clientId=1)\n    \n    async def watch_ticker(contract):\n        ticker = ib.reqMktData(contract)\n        await ib.sleep(1)\n        return ticker\n    \n    # Create tasks for concurrent execution\n    tasks = [\n        asyncio.create_task(watch_ticker(Forex('EURUSD'))),\n        asyncio.create_task(watch_ticker(Forex('GBPUSD'))),\n        asyncio.create_task(watch_ticker(Forex('USDJPY')))\n    ]\n    \n    tickers = await asyncio.gather(*tasks)\n    return tickers",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "def get_price():\n    if not ib.isConnected():\n        raise ConnectionError(\"Not connected to IB\")\n    ticker = ib.reqMktData(contract)\n    ib.sleep(2)\n    if ticker.last:\n        return ticker.last\n    raise ValueError(\"No price data available\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\nimport logging\n\nclass IBDataManager:\n    \"\"\"Demonstrates best practices for single source of truth pattern\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=7497, client_id=1):\n        self.ib = IB()\n        self.host = host\n        self.port = port\n        self.client_id = client_id\n        self._setup_logging()\n        self._setup_events()\n    \n    def _setup_logging(self):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n    \n    def _setup_events(self):\n        self.ib.connectedEvent += self._on_connected\n        self.ib.disconnectedEvent += self._on_disconnected\n        self.ib.positionEvent += self._on_position\n        self.ib.updatePortfolioEvent += self._on_portfolio\n    \n    def connect(self):\n        try:\n            self.ib.connect(self.host, self.port, clientId=self.client_id)\n            self.logger.info(\"Connected to IB\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            return False\n    \n    def _on_connected(self):\n        self.logger.info(\"Connection established\")\n        self.ib.reqAccountSummary()\n    \n    def _on_disconnected(self):\n        self.logger.warning(\"Disconnected from IB\")\n    \n    def _on_position(self, position):\n        self.logger.info(f\"Position update: {position.contract.symbol}\")\n    \n    def _on_portfolio(self, item):\n        self.logger.info(f\"Portfolio update: {item.contract.symbol}\")\n    \n    def get_current_positions(self):\n        \"\"\"Get current positions (always fresh from single source)\"\"\"\n        if not self.ib.isConnected():\n            raise ConnectionError(\"Not connected\")\n        return self.ib.positions()\n    \n    def get_position_for_symbol(self, symbol):\n        \"\"\"Get position for specific symbol\"\"\"\n        for pos in self.get_current_positions():\n            if pos.contract.symbol == symbol:\n                return pos\n        return None",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Create and qualify contract\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Create and place market order\norder = MarketOrder('BUY', 100)\ntrade = ib.placeOrder(contract, order)\n\n# Monitor order status\nprint(f\"Order status: {trade.orderStatus.status}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Recommended method\ncontract = Future('ES', '202506', 'CME')\n\n# With additional parameters\ncontract = Future(\n    symbol='ES',\n    lastTradeDateOrContractMonth='202506',\n    exchange='CME',\n    localSymbol='ESM6',\n    multiplier='50',\n    currency='USD'\n)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\n\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nib.qualifyContracts(contract)\n\n# Subscribe to market data\nticker = ib.reqMktData(contract, '', False, False)\n\n# Wait for data to populate\nib.sleep(2)\n\n# Access real-time data\nprint(f\"Last: {ticker.last}, Bid: {ticker.bid}, Ask: {ticker.ask}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "def shutdown():\n    # Cancel all subscriptions\n    for contract in active_contracts:\n        ib.cancelMktData(contract)\n    \n    # Allow cancellations to process\n    ib.sleep(1)\n    \n    # Disconnect\n    ib.disconnect()\n\ntry:\n    ib.run()\nfinally:\n    shutdown()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "connect",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "connect",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "connect example",
      "data": "from ib_insync import *\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nclass TradingSystem:\n    def __init__(self):\n        self.ib = IB()\n        self.tickers = {}\n        self.active_contracts = set()\n        \n    def connect(self):\n        self.ib.connect('127.0.0.1', 7497, clientId=1)\n        self.ib.errorEvent += self.onError\n        self.ib.pendingTickersEvent += self.onPendingTickers\n        \n    def subscribe(self, symbol):\n        contract = Stock(symbol, 'SMART', 'USD')\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract, '', False, False)\n        self.tickers[symbol] = ticker\n        self.active_contracts.add(contract)\n        \n    def onPendingTickers(self, tickers):\n        for ticker in tickers:\n            self.process_ticker(ticker)\n            \n    def process_ticker(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n        \n        # Always yield control in callbacks\n        self.ib.sleep(0)\n        \n    def onError(self, reqId, errorCode, errorString, contract):\n        logging.error(f\"Error {errorCode}: {errorString}\")\n        \n    def shutdown(self):\n        for contract in self.active_contracts:\n            self.ib.cancelMktData(contract)\n        self.ib.sleep(1)\n        self.ib.disconnect()\n        \n    def run(self):\n        try:\n            self.ib.run()\n        except KeyboardInterrupt:\n            print(\"Shutting down...\")\n        finally:\n            self.shutdown()\n\n# Usage\nif __name__ == '__main__':\n    system = TradingSystem()\n    system.connect()\n    system.subscribe('AAPL')\n    system.subscribe('GOOGL')\n    system.run()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "class IB:\n    \"\"\"High-level interface to Interactive Brokers\"\"\"",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "RequestTimeout: float = 0        # Request timeout (0 = infinite)\nRaiseRequestErrors: bool = False # Raise errors vs silent fail\nMaxSyncedSubAccounts: int = 50   # Max sub-accounts to sync",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "ib.waitOnUpdate(timeout: float = 0) -> bool\n# Wait for network update. Returns False on timeout.\n\nib.sleep(seconds: float = 0.02) -> None\n# Sleep while keeping event loop alive\n# ALWAYS use this instead of time.sleep()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Stock(\n    symbol: str,\n    exchange: str = 'SMART',\n    currency: str = 'USD',\n    primaryExchange: str = ''\n)\n\n# Examples\nStock('AAPL', 'SMART', 'USD')\nStock('INTC', 'SMART', 'USD', primaryExchange='NASDAQ')\nStock('BMW', 'SMART', 'EUR', primaryExchange='IBIS')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Forex(pair: str = 'EURUSD', exchange: str = 'IDEALPRO')\n\n# Examples\nForex('EURUSD')\nForex('GBPUSD')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Index(symbol: str = '', exchange: str = '')\n\n# Examples\nIndex('SPX', 'CBOE')\nIndex('VIX', 'CBOE')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "CFD(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCFD('IBUS30')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Commodity(\n    symbol: str = '',\n    exchange: str = '',\n    currency: str = ''\n)\n\n# Example\nCommodity('XAUUSD', 'SMART', 'USD')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Bond(secIdType: str = '', secId: str = '')\n\n# Example\nBond(secIdType='ISIN', secId='US03076KAA60')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "Crypto(symbol: str = '', exchange: str = '', currency: str = '')\n\n# Example\nCrypto('BTC', 'PAXOS', 'USD')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "ib.reqMarketDataType(marketDataType: int) -> None\n# 1 = Live\n# 2 = Frozen\n# 3 = Delayed\n# 4 = Delayed-Frozen",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "@dataclass\nclass Bar:\n    date: datetime\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    average: float\n    barCount: int",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "accounts = ib.managedAccounts() -> List[str]\n# List of account codes",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "values = ib.accountValues(account: str = '') -> List[AccountValue]\n\n# AccountValue fields:\n# .account\n# .tag      - Key name (e.g., 'NetLiquidation')\n# .value    - Value as string\n# .currency\n# .modelCode",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "summary = ib.reqAccountSummary() -> List[AccountValue]\n# Summary for all accounts\n\n# Or filter by tags\nsummary = ib.reqAccountSummary(\n    account: str = 'All',\n    modelCode: str = '',\n    tags: str = 'NetLiquidation,TotalCashValue,BuyingPower'\n)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "pnl = ib.reqPnL(account: str, modelCode: str = '') -> PnL\n# Start PnL subscription\n\n# PnL fields (live-updated):\n# .account\n# .modelCode\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n\n# Cancel\nib.cancelPnL(account: str, modelCode: str = '')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# Format for IB\nformatted = util.formatIBDatetime(dt: datetime) -> str\n# Returns: 'YYYYMMDD HH:MM:SS UTC'\n\n# Parse from IB\nparsed = util.parseIBDatetime(s: str) -> Union[date, datetime]",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# Log to console\nutil.logToConsole(level=logging.INFO)\n\n# Log to file\nutil.logToFile('ib_log.txt', level=logging.DEBUG)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# At start of notebook\nutil.startLoop()\n\n# Or with old notebooks\nutil.patchAsyncio()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "util.useQt('PyQt5')  # or 'PyQt6', 'PySide2', 'PySide6'\n# Integrates asyncio with Qt event loop",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "def callback():\n    print('Periodic task')\n\n# Schedule every 60 seconds\nhandle = util.schedule(60, callback)\n\n# Cancel scheduled task\nhandle.cancel()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# Iterate over time periods\nfor dt in util.timeRange(\n    start='20240101',\n    end='20240131',\n    step='1 day'\n):\n    print(dt)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "time.sleep(5)  # Blocks event loop!",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "ib.sleep(5)  # Keeps event loop running",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# Check API settings in TWS:\n# Configuration -> API -> Settings\n# - Enable ActiveX and Socket Clients\n# - Socket port: 7497 (TWS) or 4001 (Gateway)\n# - Trusted IPs: 127.0.0.1\n# - Master API client ID: (optional)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# Your account lacks market data subscription\n# Options:\n# 1. Subscribe to market data in account management\n# 2. Use reqMarketDataType(3) for delayed data\n# 3. Use reqMarketDataType(4) for frozen delayed\n\nib.reqMarketDataType(3)  # Delayed data (free)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# IB throttles automatically at 45 req/sec\n# Monitor throttle events:\n\ndef on_throttle_start():\n    print(\"Throttling started\")\n\ndef on_throttle_end():\n    print(\"Throttling ended\")\n\nib.client.throttleStart += on_throttle_start\nib.client.throttleEnd += on_throttle_end",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "unknown",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "unknown",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "unknown example",
      "data": "# At start of notebook:\nutil.startLoop()\n\n# If still issues:\nutil.patchAsyncio()\n\n# For old notebooks:\nimport nest_asyncio\nnest_asyncio.apply()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Access current state (auto-synced)\nib.accountValues()      # List[AccountValue]\nib.portfolio()          # List[PortfolioItem]\nib.positions()          # List[Position]\nib.trades()             # List[Trade]\nib.openTrades()         # List[Trade] - open only\nib.orders()             # List[Order]\nib.openOrders()         # List[Order] - open only\nib.fills()              # List[Fill]\nib.executions()         # List[Execution]\nib.tickers()            # List[Ticker]\nib.pendingTickers()     # Set[Ticker] - with updates\nib.reqId()              # int - next request ID",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "@dataclass\nclass Contract:\n    conId: int = 0              # Unique IB contract ID\n    symbol: str = ''            # Ticker symbol\n    secType: str = ''           # Security type\n    lastTradeDateOrContractMonth: str = ''\n    strike: float = 0.0\n    right: str = ''             # 'C' or 'P' for options\n    multiplier: str = ''\n    exchange: str = ''\n    primaryExchange: str = ''\n    currency: str = ''\n    localSymbol: str = ''\n    tradingClass: str = ''\n    includeExpired: bool = False\n    secIdType: str = ''         # CUSIP, SEDOL, ISIN, RIC\n    secId: str = ''\n    description: str = ''\n    issuerId: str = ''\n    comboLegsDescrip: str = ''\n    comboLegs: List = None      # For combo orders\n    deltaNeutralContract: DeltaNeutralContract = None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "details = ib.reqContractDetails(contract)\n# Returns List[ContractDetails]\n\n# ContractDetails fields:\n# .contract - Fully qualified contract\n# .marketName\n# .minTick\n# .priceMagnifier\n# .orderTypes\n# .validExchanges\n# .underConId\n# .longName\n# .contractMonth\n# .industry\n# .category\n# .subcategory\n# .timeZoneId\n# .tradingHours\n# .liquidHours\n# And many more...",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "@dataclass\nclass Order:\n    orderId: int = 0\n    clientId: int = 0\n    permId: int = 0\n    action: str = ''            # 'BUY' or 'SELL'\n    totalQuantity: float = 0.0\n    orderType: str = ''         # See order types below\n    lmtPrice: float = 0.0\n    auxPrice: float = 0.0       # Stop price\n    tif: str = 'DAY'            # Time in force\n    \n    # Advanced fields\n    ocaGroup: str = ''          # One-Cancels-All group\n    account: str = ''\n    openClose: str = 'O'        # 'O'=open, 'C'=close\n    origin: int = 0             # 0=customer\n    orderRef: str = ''\n    transmit: bool = True       # Auto-transmit\n    parentId: int = 0           # For bracket orders\n    blockOrder: bool = False\n    sweepToFill: bool = False\n    displaySize: int = 0\n    triggerMethod: int = 0\n    outsideRth: bool = False    # Outside regular hours\n    hidden: bool = False\n    \n    # Order combos\n    goodAfterTime: str = ''\n    goodTillDate: str = ''\n    rule80A: str = ''\n    allOrNone: bool = False\n    minQty: int = None\n    percentOffset: float = None\n    overridePercentageConstraints: bool = False\n    trailStopPrice: float = None\n    trailingPercent: float = None\n    \n    # Financial advisors\n    faGroup: str = ''\n    faProfile: str = ''\n    faMethod: str = ''\n    faPercentage: str = ''\n    \n    # Institutional\n    designatedLocation: str = ''\n    exemptCode: int = -1\n    \n    # Smart routing\n    discretionaryAmt: float = 0.0\n    eTradeOnly: bool = False\n    firmQuoteOnly: bool = False\n    nbboPriceCap: float = None\n    optOutSmartRouting: bool = False\n    \n    # Pegged orders\n    stockRefPrice: float = None\n    delta: float = None\n    \n    # Volatility orders\n    volatility: float = None\n    volatilityType: int = None\n    deltaNeutralOrderType: str = ''\n    deltaNeutralAuxPrice: float = None\n    deltaNeutralConId: int = 0\n    deltaNeutralShortSale: bool = False\n    deltaNeutralShortSaleSlot: int = 0\n    deltaNeutralDesignatedLocation: str = ''\n    continuousUpdate: bool = False\n    referencePriceType: int = None\n    \n    # Conditions\n    conditions: List = None\n    conditionsIgnoreRth: bool = False\n    conditionsCancelOrder: bool = False\n    \n    # Algo orders\n    algoStrategy: str = ''\n    algoParams: List = None\n    \n    # What-if\n    whatIf: bool = False\n    \n    # Misc\n    notHeld: bool = False\n    solicited: bool = False\n    randomizeSize: bool = False\n    randomizePrice: bool = False\n    \n    # Pegged to benchmark\n    referenceContractId: int = 0\n    peggedChangeAmount: float = 0.0\n    isPeggedChangeAmountDecrease: bool = False\n    referenceChangeAmount: float = 0.0\n    referenceExchangeId: str = ''\n    adjustedOrderType: str = ''\n    \n    # Misc2\n    modelCode: str = ''\n    extOperator: str = ''\n    cashQty: float = None\n    mifid2DecisionMaker: str = ''\n    mifid2DecisionAlgo: str = ''\n    mifid2ExecutionTrader: str = ''\n    mifid2ExecutionAlgo: str = ''\n    dontUseAutoPriceForHedge: bool = False\n    \n    # Manual times (for audit)\n    manualOrderTime: str = ''\n    manualOrderCancelTime: str = ''\n    \n    # Post to ATS\n    usePriceMgmtAlgo: bool = None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "MarketOrder(action: str, totalQuantity: float, **kwargs)\n\n# Examples\norder = MarketOrder('BUY', 100)\norder = MarketOrder('SELL', 50, tif='GTC')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "LimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    **kwargs\n)\n\n# Examples\norder = LimitOrder('BUY', 100, 150.50)\norder = LimitOrder('SELL', 50, 155.00, tif='GTC')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "StopOrder(\n    action: str,\n    totalQuantity: float,\n    stopPrice: float,\n    **kwargs\n)\n\n# Examples\norder = StopOrder('SELL', 100, 145.00)  # Stop loss",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "StopLimitOrder(\n    action: str,\n    totalQuantity: float,\n    lmtPrice: float,\n    stopPrice: float,\n    **kwargs\n)\n\n# Example\norder = StopLimitOrder('SELL', 100, 148.00, 150.00)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "BracketOrder(\n    action: str,\n    quantity: float,\n    limitPrice: float,\n    takeProfitPrice: float,\n    stopLossPrice: float\n) -> Tuple[Order, Order, Order]\n\n# Returns (parent, takeProfit, stopLoss)\n# Example\nparent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0, 160.0, 145.0\n)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "trade = ib.placeOrder(contract: Contract, order: Order) -> Trade\n# Returns Trade object (live-updated)\n\n# Example\ncontract = Stock('AAPL', 'SMART', 'USD')\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# Trade object updated in real-time:\n# - trade.orderStatus\n# - trade.fills\n# - trade.log",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Modify existing order\norder.lmtPrice = 151.0\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "trade = ib.cancelOrder(order: Order) -> Trade\n\n# Cancel all orders\nib.reqGlobalCancel()",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "@dataclass\nclass OrderStatus:\n    orderId: int = 0\n    status: str = ''        # PendingSubmit, Submitted, Filled, Cancelled, etc.\n    filled: float = 0.0\n    remaining: float = 0.0\n    avgFillPrice: float = 0.0\n    permId: int = 0\n    parentId: int = 0\n    lastFillPrice: float = 0.0\n    clientId: int = 0\n    whyHeld: str = ''\n    mktCapPrice: float = 0.0",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "@dataclass\nclass Trade:\n    contract: Contract = None\n    order: Order = None\n    orderStatus: OrderStatus = None\n    fills: List[Fill] = []\n    log: List[TradeLogEntry] = []\n    \n    # Methods\n    def isActive(self) -> bool\n    def isDone(self) -> bool\n    def filled(self) -> float\n    def remaining(self) -> float",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "orderState = ib.whatIfOrder(contract, order)\n# Test order without placing\n# Returns OrderState with commission/margin impact\n\n# OrderState fields:\n# .initMarginBefore\n# .maintMarginBefore\n# .equityWithLoanBefore\n# .initMarginAfter\n# .maintMarginAfter\n# .equityWithLoanAfter\n# .commission\n# .minCommission\n# .maxCommission\n# .commissionCurrency",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# New order placed\nib.newOrderEvent += lambda trade: print(f'New order: {trade}')\n\n# Order modified\nib.orderModifyEvent += lambda trade: print(f'Modified: {trade}')\n\n# Order status changed\nib.orderStatusEvent += lambda trade: print(f'Status: {trade.orderStatus.status}')\n\n# Execution received\nib.execDetailsEvent += lambda trade, fill: print(f'Fill: {fill}')\n\n# Commission report\nib.commissionReportEvent += lambda trade, fill, report: print(f'Commission: {report}')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "parent, takeProfit, stopLoss = BracketOrder(\n    'BUY', 100, 150.0,\n    takeProfitPrice=160.0,\n    stopLossPrice=145.0\n)\nfor order in (parent, takeProfit, stopLoss):\n    ib.placeOrder(contract, order)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Common causes:\n# 1. Invalid contract\n# 2. Insufficient buying power\n# 3. Outside trading hours\n# 4. Invalid order parameters\n\n# Debug:\norderState = ib.whatIfOrder(contract, order)\nprint(orderState)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "from datetime import datetime, timedelta\n\n# Order triggers at specific time\ntime_condition = TimeCondition(\n    condType=3,  # Time\n    isMore=True,\n    time=datetime.now() + timedelta(hours=1)\n)\n\norder = MarketOrder('BUY', 100)\norder.conditions = [time_condition]\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Trigger when daily volume exceeds threshold\nvolume_condition = VolumeCondition(\n    condType=4,  # Volume\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=10000000  # 10M shares\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [volume_condition]\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Order triggers when BOTH conditions met\nprice_cond = PriceCondition(\n    condType=1,\n    conId=trigger_contract.conId,\n    exchange='SMART',\n    isMore=True,\n    price=450.0\n)\n\nvolume_cond = VolumeCondition(\n    condType=4,\n    conId=contract.conId,\n    exchange='SMART',\n    isMore=True,\n    volume=5000000\n)\n\norder = LimitOrder('BUY', 100, 175.0)\norder.conditions = [price_cond, volume_cond]\norder.conditionsIgnoreRth = False\norder.conditionsCancelOrder = False  # False = AND, True = OR\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.trailingPercent = 2.0  # Trail by 2%\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL'\norder.auxPrice = 5.0  # Trail by $5\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'SELL'\norder.totalQuantity = 100\norder.orderType = 'TRAIL LIMIT'\norder.lmtPriceOffset = 0.50  # Limit $0.50 below trail\norder.trailingPercent = 2.0\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'PEG MID'\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'PEG BEST'\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 100\norder.orderType = 'REL'\norder.lmtPrice = 0.10  # $0.10 above best bid\norder.tif = 'GTC'\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Buy at market, then set multiple exit strategies\nentry_order = MarketOrder('BUY', 100)\nentry_trade = ib.placeOrder(contract, entry_order)\n\n# Wait for fill\nwhile not entry_trade.isDone():\n    ib.sleep(0.1)\n\nif entry_trade.orderStatus.status == 'Filled':\n    # Create OCA group for exits\n    oca_group = f\"OCA_{int(time.time())}\"\n    \n    # Exit 1: Take profit at +5%\n    exit1 = LimitOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 1.05)\n    exit1.ocaGroup = oca_group\n    exit1.ocaType = 1  # Cancel all on fill\n    \n    # Exit 2: Stop loss at -2%\n    exit2 = StopOrder('SELL', 100, entry_trade.orderStatus.avgFillPrice * 0.98)\n    exit2.ocaGroup = oca_group\n    exit2.ocaType = 1\n    \n    # Exit 3: Trailing stop\n    exit3 = Order()\n    exit3.action = 'SELL'\n    exit3.totalQuantity = 100\n    exit3.orderType = 'TRAIL'\n    exit3.trailingPercent = 3.0\n    exit3.ocaGroup = oca_group\n    exit3.ocaType = 1\n    \n    for order in [exit1, exit2, exit3]:\n        ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000  # Large order\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\n# TWAP algo\norder.algoStrategy = 'Twap'\norder.algoParams = [\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1')\n]\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 10000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Vwap'\norder.algoParams = [\n    TagValue('maxPctVol', '0.1'),  # Max 10% of volume\n    TagValue('startTime', '09:30:00 EST'),\n    TagValue('endTime', '16:00:00 EST'),\n    TagValue('allowPastEndTime', '1'),\n    TagValue('noTakeLiq', '1')\n]\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "order = Order()\norder.action = 'BUY'\norder.totalQuantity = 1000\norder.orderType = 'LMT'\norder.lmtPrice = 175.0\norder.tif = 'DAY'\n\norder.algoStrategy = 'Adaptive'\norder.algoParams = [\n    TagValue('adaptivePriority', 'Normal')  # Urgent, Normal, Patient\n]\n\ntrade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Four-leg strategy: sell OTM call spread + sell OTM put spread\nbuy_call = Option('SPY', '20240315', 470, 'C', 'SMART')\nsell_call = Option('SPY', '20240315', 465, 'C', 'SMART')\nbuy_put = Option('SPY', '20240315', 430, 'P', 'SMART')\nsell_put = Option('SPY', '20240315', 435, 'P', 'SMART')\n\n# Qualify all\ncontracts = ib.qualifyContracts(buy_call, sell_call, buy_put, sell_put)\n\n# Create BAG\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy call\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell call\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),   # Buy put\n    ComboLeg(conId=contracts[3].conId, ratio=1, action='SELL', exchange='SMART'),  # Sell put\n]\n\n# Place as credit spread\norder = LimitOrder('SELL', 10, 2.00)  # Collect $2.00 credit\ntrade = ib.placeOrder(combo, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Buy 1 ITM call, Sell 2 ATM calls, Buy 1 OTM call\nlower_call = Option('SPY', '20240315', 440, 'C', 'SMART')\nmiddle_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nupper_call = Option('SPY', '20240315', 460, 'C', 'SMART')\n\ncontracts = ib.qualifyContracts(lower_call, middle_call, upper_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='BUY', exchange='SMART'),\n    ComboLeg(conId=contracts[1].conId, ratio=2, action='SELL', exchange='SMART'),  # 2x middle\n    ComboLeg(conId=contracts[2].conId, ratio=1, action='BUY', exchange='SMART'),\n]\n\norder = LimitOrder('BUY', 10, 1.50)\ntrade = ib.placeOrder(combo, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Sell near-term, buy far-term (same strike)\nnear_call = Option('SPY', '20240315', 450, 'C', 'SMART')\nfar_call = Option('SPY', '20240615', 450, 'C', 'SMART')\n\ncontracts = ib.qualifyContracts(near_call, far_call)\n\ncombo = Contract()\ncombo.symbol = 'SPY'\ncombo.secType = 'BAG'\ncombo.currency = 'USD'\ncombo.exchange = 'SMART'\n\ncombo.comboLegs = [\n    ComboLeg(conId=contracts[0].conId, ratio=1, action='SELL', exchange='SMART'),\n    ComboLeg(conId=contracts[1].conId, ratio=1, action='BUY', exchange='SMART'),\n]\n\norder = LimitOrder('BUY', 10, 0.75)\ntrade = ib.placeOrder(combo, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Dynamic delta hedging for options position\ndef calculate_position_delta(portfolio):\n    \"\"\"Calculate total portfolio delta\"\"\"\n    total_delta = 0.0\n    \n    for item in portfolio:\n        if item.contract.secType == 'OPT':\n            # Request option computations\n            ticker = ib.reqMktData(item.contract, '', False, False)\n            ib.sleep(1)\n            \n            if ticker.modelGreeks:\n                delta = ticker.modelGreeks.delta\n                total_delta += delta * item.position\n            \n            ib.cancelMktData(item.contract)\n    \n    return total_delta\n\ndef hedge_delta(underlying_contract, target_delta=0.0):\n    \"\"\"Adjust underlying position to achieve target delta\"\"\"\n    portfolio = ib.portfolio()\n    current_delta = calculate_position_delta(portfolio)\n    \n    delta_to_hedge = current_delta - target_delta\n    \n    if abs(delta_to_hedge) > 0.1:  # Threshold\n        # Delta of stock is 1.0\n        shares_to_trade = int(delta_to_hedge * 100)  # Per contract\n        \n        if shares_to_trade > 0:\n            order = MarketOrder('SELL', abs(shares_to_trade))\n        else:\n            order = MarketOrder('BUY', abs(shares_to_trade))\n        \n        trade = ib.placeOrder(underlying_contract, order)\n        print(f\"Hedging {shares_to_trade} shares | Current delta: {current_delta:.2f}\")\n        \n        return trade\n    else:\n        print(f\"Delta within tolerance: {current_delta:.2f}\")\n        return None\n\n# Run periodically\nunderlying = Stock('SPY', 'SMART', 'USD')\nunderlying = ib.qualifyContracts(underlying)[0]\n\nwhile True:\n    hedge_delta(underlying, target_delta=0.0)\n    ib.sleep(300)  # Every 5 minutes",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def validate_order(ib, contract, order):\n    \"\"\"Validate order before placing\"\"\"\n    errors = []\n    \n    # 1. Check contract is qualified\n    if contract.conId == 0:\n        errors.append(\"Contract not qualified\")\n    \n    # 2. Check buying power\n    account_values = {v.tag: float(v.value) for v in ib.accountValues() if v.tag in ['BuyingPower', 'NetLiquidation']}\n    \n    if order.action == 'BUY':\n        # Estimate cost\n        ticker = ib.reqMktData(contract, '', True, False)  # Snapshot\n        ib.sleep(1)\n        \n        if ticker.ask and ticker.ask == ticker.ask:  # Not NaN\n            estimated_cost = ticker.ask * order.totalQuantity\n            if estimated_cost > account_values.get('BuyingPower', 0):\n                errors.append(f\"Insufficient buying power: need ${estimated_cost:.2f}, have ${account_values.get('BuyingPower', 0):.2f}\")\n        \n        ib.cancelMktData(contract)\n    \n    # 3. What-if order check\n    try:\n        order_copy = Order(**{k: v for k, v in order.__dict__.items()})\n        order_copy.whatIf = True\n        \n        orderState = ib.whatIfOrder(contract, order_copy)\n        \n        if orderState.commission and orderState.commission > 0:\n            # Valid response\n            if float(orderState.initMarginAfter) > account_values.get('NetLiquidation', 0):\n                errors.append(\"Insufficient margin\")\n        else:\n            errors.append(\"What-if order returned invalid state\")\n            \n    except Exception as e:\n        errors.append(f\"What-if validation failed: {e}\")\n    \n    # 4. Check trading hours\n    details = ib.reqContractDetails(contract)\n    if details:\n        # Parse trading hours (simplified)\n        # Would need full implementation\n        pass\n    \n    return errors\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\norder = LimitOrder('BUY', 1000, 175.0)\n\nvalidation_errors = validate_order(ib, contract, order)\nif validation_errors:\n    print(\"Order validation failed:\")\n    for error in validation_errors:\n        print(f\"  - {error}\")\nelse:\n    trade = ib.placeOrder(contract, order)\n    print(\"Order placed successfully\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "import time\nfrom functools import wraps\n\ndef retry_with_backoff(max_retries=3, base_delay=1.0, max_delay=60.0):\n    \"\"\"Decorator for retrying failed operations\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            retries = 0\n            delay = base_delay\n            \n            while retries < max_retries:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    retries += 1\n                    if retries >= max_retries:\n                        logging.error(f\"{func.__name__} failed after {max_retries} retries: {e}\")\n                        raise\n                    \n                    logging.warning(f\"{func.__name__} failed (attempt {retries}/{max_retries}): {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n                    delay = min(delay * 2, max_delay)  # Exponential backoff\n            \n        return wrapper\n    return decorator\n\n# Usage\n@retry_with_backoff(max_retries=3, base_delay=2.0)\ndef place_order_with_retry(ib, contract, order):\n    \"\"\"Place order with automatic retry\"\"\"\n    trade = ib.placeOrder(contract, order)\n    \n    # Wait for submission\n    timeout = 10\n    start = time.time()\n    while trade.orderStatus.status in ['PendingSubmit', '']:\n        if time.time() - start > timeout:\n            raise TimeoutError(\"Order submission timeout\")\n        ib.sleep(0.1)\n    \n    if trade.orderStatus.status in ['Cancelled', 'ApiCancelled']:\n        raise Exception(f\"Order cancelled: {trade.orderStatus.status}\")\n    \n    return trade\n\n# Usage\ntry:\n    trade = place_order_with_retry(ib, contract, order)\n    print(f\"Order placed: {trade.order.orderId}\")\nexcept Exception as e:\n    print(f\"Order failed: {e}\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "class PositionManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.expected_positions = {}  # conId -> quantity\n        \n    def record_trade(self, trade):\n        \"\"\"Record expected position change\"\"\"\n        if trade.orderStatus.status == 'Filled':\n            conId = trade.contract.conId\n            qty = trade.filled() if trade.order.action == 'BUY' else -trade.filled()\n            \n            if conId in self.expected_positions:\n                self.expected_positions[conId] += qty\n            else:\n                self.expected_positions[conId] = qty\n    \n    def reconcile(self):\n        \"\"\"Check actual vs expected positions\"\"\"\n        actual_positions = {p.contract.conId: p.position for p in self.ib.positions()}\n        \n        discrepancies = []\n        \n        # Check expected positions\n        for conId, expected_qty in self.expected_positions.items():\n            actual_qty = actual_positions.get(conId, 0)\n            if abs(actual_qty - expected_qty) > 0.01:  # Allow for rounding\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': expected_qty,\n                    'actual': actual_qty,\n                    'diff': actual_qty - expected_qty\n                })\n        \n        # Check for unexpected positions\n        for conId, actual_qty in actual_positions.items():\n            if conId not in self.expected_positions and abs(actual_qty) > 0.01:\n                discrepancies.append({\n                    'conId': conId,\n                    'expected': 0,\n                    'actual': actual_qty,\n                    'diff': actual_qty\n                })\n        \n        if discrepancies:\n            logging.warning(f\"Position discrepancies found: {discrepancies}\")\n        \n        return discrepancies\n    \n    def reset_tracking(self):\n        \"\"\"Reset to current positions\"\"\"\n        self.expected_positions = {\n            p.contract.conId: p.position \n            for p in self.ib.positions()\n        }\n\n# Usage\npm = PositionManager(ib)\npm.reset_tracking()\n\n# Track trades\nib.execDetailsEvent += lambda trade, fill: pm.record_trade(trade)\n\n# Periodic reconciliation\nwhile True:\n    discrepancies = pm.reconcile()\n    if discrepancies:\n        # Alert or take action\n        pass\n    ib.sleep(60)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def close_all_positions(ib, exclude_symbols=None):\n    \"\"\"Emergency position closer\"\"\"\n    exclude_symbols = exclude_symbols or []\n    \n    positions = ib.positions()\n    trades = []\n    \n    for position in positions:\n        symbol = position.contract.symbol\n        \n        if symbol in exclude_symbols:\n            continue\n        \n        qty = abs(position.position)\n        action = 'SELL' if position.position > 0 else 'BUY'\n        \n        order = MarketOrder(action, qty)\n        trade = ib.placeOrder(position.contract, order)\n        trades.append(trade)\n        \n        print(f\"Closing {action} {qty} {symbol}\")\n    \n    # Wait for all to fill\n    timeout = 30\n    start = time.time()\n    \n    while any(not t.isDone() for t in trades):\n        if time.time() - start > timeout:\n            logging.error(\"Timeout waiting for position closures\")\n            break\n        ib.sleep(0.5)\n    \n    return trades\n\n# Usage - emergency exit\nif emergency_condition:\n    close_all_positions(ib)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def calculate_position_size(\n    ib,\n    contract,\n    risk_per_trade_pct=0.02,  # 2% risk\n    stop_loss_pct=0.05         # 5% stop\n):\n    \"\"\"Calculate position size based on risk\"\"\"\n    \n    # Get account value\n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    # Calculate dollar risk\n    dollar_risk = net_liq * risk_per_trade_pct\n    \n    # Get current price\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if not ticker.last or ticker.last != ticker.last:  # NaN check\n        logging.error(\"Unable to get price for position sizing\")\n        return 0\n    \n    price = ticker.last\n    ib.cancelMktData(contract)\n    \n    # Calculate shares\n    # dollar_risk = shares * price * stop_loss_pct\n    shares = dollar_risk / (price * stop_loss_pct)\n    \n    # Round to nearest tradeable lot\n    if contract.secType == 'OPT':\n        shares = int(shares / 100) * 100  # Options in contracts (100 shares)\n    else:\n        shares = int(shares)\n    \n    print(f\"Position size for {contract.symbol}: {shares} shares\")\n    print(f\"At ${price:.2f}, risking ${dollar_risk:.2f} ({risk_per_trade_pct*100}% of ${net_liq:.2f})\")\n    \n    return shares\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nshares = calculate_position_size(ib, contract, risk_per_trade_pct=0.01, stop_loss_pct=0.03)\n\nif shares > 0:\n    order = LimitOrder('BUY', shares, 175.0)\n    trade = ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "class DailyLossLimiter:\n    def __init__(self, ib, max_daily_loss_pct=0.05):\n        self.ib = ib\n        self.max_daily_loss_pct = max_daily_loss_pct\n        self.start_equity = None\n        self.breached = False\n        \n    def initialize(self):\n        \"\"\"Set starting equity for the day\"\"\"\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        self.start_equity = account_values.get('NetLiquidation', 0)\n        self.breached = False\n        print(f\"Daily loss limiter initialized. Start equity: ${self.start_equity:.2f}\")\n    \n    def check_limit(self):\n        \"\"\"Check if daily loss limit breached\"\"\"\n        if self.breached:\n            return True\n        \n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        current_equity = account_values.get('NetLiquidation', 0)\n        \n        loss = self.start_equity - current_equity\n        loss_pct = loss / self.start_equity if self.start_equity > 0 else 0\n        \n        if loss_pct >= self.max_daily_loss_pct:\n            self.breached = True\n            logging.critical(f\"DAILY LOSS LIMIT BREACHED! Loss: ${loss:.2f} ({loss_pct*100:.2f}%)\")\n            return True\n        \n        return False\n    \n    def enforce(self):\n        \"\"\"Close all positions and cancel all orders\"\"\"\n        if not self.breached:\n            return\n        \n        print(\"Enforcing daily loss limit...\")\n        \n        # Cancel all orders\n        self.ib.reqGlobalCancel()\n        \n        # Close all positions\n        close_all_positions(self.ib)\n        \n        print(\"All positions closed. Trading halted for the day.\")\n\n# Usage\nlimiter = DailyLossLimiter(ib, max_daily_loss_pct=0.03)  # 3% daily loss limit\nlimiter.initialize()\n\n# Check periodically\nwhile True:\n    if limiter.check_limit():\n        limiter.enforce()\n        break\n    ib.sleep(60)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def check_position_concentration(ib, max_position_pct=0.20):\n    \"\"\"Ensure no single position exceeds % of portfolio\"\"\"\n    \n    account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n    net_liq = account_values.get('NetLiquidation', 0)\n    \n    violations = []\n    \n    for item in ib.portfolio():\n        position_pct = abs(item.marketValue) / net_liq if net_liq > 0 else 0\n        \n        if position_pct > max_position_pct:\n            violations.append({\n                'symbol': item.contract.symbol,\n                'value': item.marketValue,\n                'pct': position_pct,\n                'limit': max_position_pct\n            })\n    \n    if violations:\n        logging.warning(f\"Position concentration violations: {violations}\")\n    \n    return violations\n\n# Check before placing order\ndef place_order_with_concentration_check(ib, contract, order, max_pct=0.20):\n    \"\"\"Place order only if it doesn't violate concentration\"\"\"\n    \n    # Estimate new position value\n    ticker = ib.reqMktData(contract, '', True, False)\n    ib.sleep(1)\n    \n    if ticker.ask:\n        estimated_value = ticker.ask * order.totalQuantity\n        \n        account_values = {v.tag: float(v.value) for v in ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        # Get current position\n        current_position = next(\n            (p.marketValue for p in ib.portfolio() if p.contract.conId == contract.conId),\n            0\n        )\n        \n        new_position_value = abs(current_position + estimated_value)\n        new_pct = new_position_value / net_liq if net_liq > 0 else 0\n        \n        if new_pct > max_pct:\n            logging.error(f\"Order would violate concentration limit: {new_pct*100:.1f}% > {max_pct*100:.1f}%\")\n            ib.cancelMktData(contract)\n            return None\n    \n    ib.cancelMktData(contract)\n    return ib.placeOrder(contract, order)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "class PortfolioRebalancer:\n    def __init__(self, ib):\n        self.ib = ib\n        \n    def rebalance_to_target(self, target_allocations, tolerance=0.05):\n        \"\"\"\n        Rebalance portfolio to target allocations\n        \n        Args:\n            target_allocations: Dict[symbol: str, target_pct: float]\n                                Example: {'AAPL': 0.25, 'GOOGL': 0.25, 'MSFT': 0.50}\n            tolerance: Rebalance threshold (0.05 = 5%)\n        \"\"\"\n        \n        # Validate target allocations\n        total = sum(target_allocations.values())\n        if abs(total - 1.0) > 0.01:\n            raise ValueError(f\"Target allocations must sum to 1.0, got {total}\")\n        \n        # Get current portfolio\n        account_values = {v.tag: float(v.value) for v in self.ib.accountValues()}\n        net_liq = account_values.get('NetLiquidation', 0)\n        \n        portfolio = {item.contract.symbol: item for item in self.ib.portfolio()}\n        \n        # Calculate current allocations\n        current_allocations = {\n            symbol: (item.marketValue / net_liq if net_liq > 0 else 0)\n            for symbol, item in portfolio.items()\n        }\n        \n        # Determine needed trades\n        trades_needed = []\n        \n        for symbol, target_pct in target_allocations.items():\n            current_pct = current_allocations.get(symbol, 0)\n            diff = target_pct - current_pct\n            \n            if abs(diff) > tolerance:\n                target_value = net_liq * target_pct\n                current_value = portfolio[symbol].marketValue if symbol in portfolio else 0\n                value_change = target_value - current_value\n                \n                # Get current price\n                contract = Stock(symbol, 'SMART', 'USD')\n                contract = self.ib.qualifyContracts(contract)[0]\n                \n                ticker = self.ib.reqMktData(contract, '', True, False)\n                self.ib.sleep(1)\n                \n                if ticker.last and ticker.last == ticker.last:\n                    price = ticker.last\n                    shares_change = int(value_change / price)\n                    \n                    if shares_change != 0:\n                        trades_needed.append({\n                            'symbol': symbol,\n                            'contract': contract,\n                            'current_pct': current_pct,\n                            'target_pct': target_pct,\n                            'shares': shares_change,\n                            'action': 'BUY' if shares_change > 0 else 'SELL'\n                        })\n                \n                self.ib.cancelMktData(contract)\n        \n        # Execute trades\n        if not trades_needed:\n            logging.info(\"Portfolio within tolerance. No rebalancing needed.\")\n            return []\n        \n        logging.info(f\"Rebalancing {len(trades_needed)} positions...\")\n        placed_trades = []\n        \n        for trade_info in trades_needed:\n            logging.info(f\"{trade_info['action']} {abs(trade_info['shares'])} {trade_info['symbol']} \"\n                        f\"({trade_info['current_pct']*100:.1f}% -> {trade_info['target_pct']*100:.1f}%)\")\n            \n            order = MarketOrder(trade_info['action'], abs(trade_info['shares']))\n            trade = self.ib.placeOrder(trade_info['contract'], order)\n            placed_trades.append(trade)\n        \n        return placed_trades\n\n# Usage\ntarget = {\n    'AAPL': 0.30,\n    'GOOGL': 0.30,\n    'MSFT': 0.40\n}\n\nrebalancer = PortfolioRebalancer(ib)\ntrades = rebalancer.rebalance_to_target(target, tolerance=0.03)\n\n# Monitor fills\nfor trade in trades:\n    while not trade.isDone():\n        ib.sleep(1)\n    print(f\"{trade.contract.symbol}: {trade.orderStatus.status}\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "class DCAScheduler:\n    def __init__(self, ib):\n        self.ib = ib\n        self.schedules = []\n        \n    def add_schedule(self, symbol, amount_per_period, frequency_days):\n        \"\"\"\n        Add DCA schedule\n        \n        Args:\n            symbol: Stock symbol\n            amount_per_period: Dollar amount to invest\n            frequency_days: Days between purchases\n        \"\"\"\n        self.schedules.append({\n            'symbol': symbol,\n            'amount': amount_per_period,\n            'frequency': frequency_days,\n            'last_purchase': None\n        })\n    \n    def check_and_execute(self):\n        \"\"\"Check if any DCA purchases are due\"\"\"\n        from datetime import datetime, timedelta\n        \n        now = datetime.now()\n        \n        for schedule in self.schedules:\n            last = schedule['last_purchase']\n            \n            # Check if purchase is due\n            if last is None or (now - last).days >= schedule['frequency']:\n                self.execute_dca(schedule)\n                schedule['last_purchase'] = now\n    \n    def execute_dca(self, schedule):\n        \"\"\"Execute DCA purchase\"\"\"\n        symbol = schedule['symbol']\n        amount = schedule['amount']\n        \n        # Create contract\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = self.ib.qualifyContracts(contract)[0]\n        \n        # Get current price\n        ticker = self.ib.reqMktData(contract, '', True, False)\n        self.ib.sleep(1)\n        \n        if ticker.last and ticker.last == ticker.last:\n            price = ticker.last\n            shares = int(amount / price)\n            \n            if shares > 0:\n                logging.info(f\"DCA: Buying {shares} {symbol} @ ${price:.2f} (${amount:.2f})\")\n                order = MarketOrder('BUY', shares)\n                trade = self.ib.placeOrder(contract, order)\n                return trade\n        \n        self.ib.cancelMktData(contract)\n        return None\n\n# Usage\ndca = DCAScheduler(ib)\ndca.add_schedule('SPY', 1000, 7)   # $1000 every 7 days\ndca.add_schedule('VTI', 500, 14)   # $500 every 14 days\n\n# Run daily check\nwhile True:\n    dca.check_and_execute()\n    ib.sleep(86400)  # Check daily",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Synchronous event handler\ndef onOrderStatus(trade):\n    print(f\"Order {trade.order.orderId}: {trade.orderStatus.status}\")\n    if trade.isDone():\n        print(f\"Filled at: {trade.orderStatus.avgFillPrice}\")\n\nib.orderStatusEvent += onOrderStatus\n\n# Asynchronous event handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        print(f\"New bar: {bars[-1]}\")\n        # Can use await inside async handlers\n        await ib.qualifyContractsAsync(contract)\n\nbars.updateEvent += onBarUpdate",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Trade object is automatically updated\norder = LimitOrder('BUY', 100, 150.0)\ntrade = ib.placeOrder(contract, order)\n\n# trade.orderStatus updates automatically in background\ndef check_order_status():\n    if trade.orderStatus.status == 'Filled':\n        print(\"Order filled!\")\n    elif trade.isDone():\n        print(\"Order completed\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Get all open orders\nopen_orders = ib.orders()\n\n# Get all trades (open and completed from this session)\nall_trades = ib.trades()\n\n# Get all fills from this session\nfills = ib.fills()\n\n# Request all open orders including from other clients\nib.reqAllOpenOrders()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def order_status_callback(trade):\n    if trade.orderStatus.status == 'Filled':\n        fill = trade.fills[-1]\n        print(f'{fill.time} - {fill.execution.side} {fill.contract.symbol} '\n              f'{fill.execution.shares} @ {fill.execution.avgPrice}')\n\ntrade.filledEvent += order_status_callback",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Basic limit order\nlimit_order = LimitOrder('BUY', 100, 150.00)\ntrade = ib.placeOrder(contract, limit_order)\n\n# Limit order with time-in-force\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.tif = 'GTD'  # Good Till Date\nlimit_order.goodTillDate = '20240331 23:59:59'\ntrade = ib.placeOrder(contract, limit_order)\n\n# Allow outside regular trading hours\nlimit_order = LimitOrder('BUY', 100, 150.00)\nlimit_order.outsideRth = True\ntrade = ib.placeOrder(contract, limit_order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Trailing stop with fixed dollar amount\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.auxPrice = 2.0  # Trail by $2\ntrailing_order.trailStopPrice = 150.0  # Initial trigger price\n\ntrade = ib.placeOrder(contract, trailing_order)\n\n# Trailing stop with percentage\ntrailing_order = Order()\ntrailing_order.action = 'SELL'\ntrailing_order.orderType = 'TRAIL'\ntrailing_order.totalQuantity = 100\ntrailing_order.trailingPercent = 5.0  # Trail by 5%\n\ntrade = ib.placeOrder(contract, trailing_order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "trail_limit_order = Order()\ntrail_limit_order.orderType = 'TRAIL LIMIT'\ntrail_limit_order.totalQuantity = 100\ntrail_limit_order.action = 'SELL'\ntrail_limit_order.lmtPriceOffset = 0.5  # Limit price offset from stop\ntrail_limit_order.auxPrice = 2.0  # Trail amount\ntrail_limit_order.trailStopPrice = 150.0\n\ntrade = ib.placeOrder(contract, trail_limit_order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Using the helper method (recommended)\norders = [\n    LimitOrder('BUY', 100, 150.00),\n    LimitOrder('BUY', 100, 149.00),\n    LimitOrder('BUY', 100, 148.00)\n]\n\noca_orders = ib.oneCancelsAll(orders, 'TestOCA_123', 2)\n\nfor order in oca_orders:\n    ib.placeOrder(contract, order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "oca_group_name = 'MyOCAGroup_123'\n\norder1 = LimitOrder('BUY', 100, 150.00)\norder1.ocaGroup = oca_group_name\norder1.ocaType = 2  # Proportional reduction with block\norder1.transmit = False\n\norder2 = LimitOrder('BUY', 100, 149.00)\norder2.ocaGroup = oca_group_name\norder2.ocaType = 2\norder2.transmit = False\n\norder3 = LimitOrder('BUY', 100, 148.00)\norder3.ocaGroup = oca_group_name\norder3.ocaType = 2\norder3.transmit = True  # Last order triggers transmission\n\nib.placeOrder(contract, order1)\nib.placeOrder(contract, order2)\nib.placeOrder(contract, order3)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Using the helper function (recommended)\nbracket = ib.bracketOrder(\n    'BUY',\n    quantity=100,\n    limitPrice=150.00,\n    takeProfitPrice=155.00,\n    stopLossPrice=145.00\n)\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "bracket = ib.bracketOrder('BUY', 100, 150.00, 155.00, 145.00)\nbracket[0].orderType = 'MKT'\nbracket[0].lmtPrice = 0\n\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "parent = Order()\nparent.orderId = ib.client.getReqId()\nparent.action = 'BUY'\nparent.orderType = 'LMT'\nparent.totalQuantity = 100\nparent.lmtPrice = 150.00\nparent.transmit = False\n\ntakeProfit = Order()\ntakeProfit.orderId = parent.orderId + 1\ntakeProfit.action = 'SELL'\ntakeProfit.orderType = 'LMT'\ntakeProfit.totalQuantity = 100\ntakeProfit.lmtPrice = 155.00\ntakeProfit.parentId = parent.orderId\ntakeProfit.transmit = False\n\nstopLoss = Order()\nstopLoss.orderId = parent.orderId + 2\nstopLoss.action = 'SELL'\nstopLoss.orderType = 'STP'\nstopLoss.auxPrice = 145.00\nstopLoss.totalQuantity = 100\nstopLoss.parentId = parent.orderId\nstopLoss.transmit = True  # Last order triggers all\n\nib.placeOrder(contract, parent)\nib.placeOrder(contract, takeProfit)\nib.placeOrder(contract, stopLoss)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "from typing import NamedTuple\n\nclass BracketOrderTwoTargets(NamedTuple):\n    parent: Order\n    takeProfit1: Order\n    takeProfit2: Order\n    stopLoss: Order\n\ndef bracket_two_targets(action, quantity, limit_price, \n                       tp_price1, tp_price2, sl_price, ib):\n    \"\"\"Create bracket with two take-profit targets\"\"\"\n    \n    parent = LimitOrder(action, quantity, limit_price)\n    parent.orderId = ib.client.getReqId()\n    parent.transmit = False\n    \n    # First take profit (half position)\n    takeProfit1 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price1\n    )\n    takeProfit1.orderId = parent.orderId + 1\n    takeProfit1.parentId = parent.orderId\n    takeProfit1.transmit = False\n    \n    # Second take profit (remaining half)\n    takeProfit2 = LimitOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity // 2,\n        tp_price2\n    )\n    takeProfit2.orderId = parent.orderId + 2\n    takeProfit2.parentId = parent.orderId\n    takeProfit2.transmit = False\n    \n    # Stop loss for full position\n    stopLoss = StopOrder(\n        'SELL' if action == 'BUY' else 'BUY',\n        quantity,\n        sl_price\n    )\n    stopLoss.orderId = parent.orderId + 3\n    stopLoss.parentId = parent.orderId\n    stopLoss.transmit = True\n    \n    return BracketOrderTwoTargets(parent, takeProfit1, takeProfit2, stopLoss)\n\n# Usage\nbracket = bracket_two_targets('BUY', 200, 150.00, 155.00, 160.00, 145.00, ib)\nfor order in bracket:\n    ib.placeOrder(contract, order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "contract = Forex('GBPUSD')\nib.qualifyContracts(contract)\n\n# Place entry order\nparent_order = MarketOrder('BUY', 25000)\ntrade = ib.placeOrder(contract, parent_order)\n\n# Wait for fill\nib.sleep(1)\nwhile trade.orderStatus.status != 'Filled':\n    ib.waitOnUpdate()\n\n# Calculate levels based on actual fill price\nfill_price = trade.orderStatus.avgFillPrice\nstop_loss_price = fill_price - 0.0015\ntake_profit_price = fill_price + 0.0020\n\n# Place child orders\nstop_loss_order = StopOrder('SELL', 25000, stop_loss_price)\ntake_profit_order = LimitOrder('SELL', 25000, take_profit_price)\n\nib.placeOrder(contract, stop_loss_order)\nib.placeOrder(contract, take_profit_order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "# Trade object attributes\ntrade.order          # The original order\ntrade.orderStatus    # Current status object\ntrade.fills          # List of fills\ntrade.log            # Log of status changes\ntrade.isActive()     # Is order still active\ntrade.isDone()       # Is order complete\n\n# Order status values\n# PendingSubmit, PendingCancel, PreSubmitted, Submitted, \n# Filled, Cancelled, Inactive, ApiPending\n\n# Event callbacks for monitoring\ndef on_fill(trade, fill):\n    print(f'Filled {fill.execution.shares} @ {fill.execution.price}')\n\ntrade.fillEvent += on_fill\n\ndef on_filled(trade):\n    total = sum(f.execution.shares for f in trade.fills)\n    avg_price = trade.orderStatus.avgFillPrice\n    print(f'Complete: {total} shares @ avg {avg_price}')\n\ntrade.filledEvent += on_filled\n\ndef on_status(trade):\n    print(f'Status: {trade.orderStatus.status}')\n\ntrade.statusEvent += on_status",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "def validate_futures_contract(ib, contract):\n    \"\"\"Validate and qualify a futures contract\"\"\"\n    try:\n        qualified = ib.qualifyContracts(contract)\n        if not qualified:\n            print(f\"ERROR: Contract could not be qualified\")\n            return None\n        \n        contract = qualified[0]\n        print(f\"\u2713 Qualified: {contract.localSymbol}\")\n        print(f\"  ConId: {contract.conId}\")\n        print(f\"  Expiry: {contract.lastTradeDateOrContractMonth}\")\n        return contract\n    except Exception as e:\n        print(f\"ERROR: {e}\")\n        return None\n\n# Usage\ncontract = Future('ES', '202506', 'CME')\nvalidated = validate_futures_contract(ib, contract)\nif validated:\n    order = MarketOrder('BUY', 1)\n    trade = ib.placeOrder(validated, order)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "placeOrder",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "placeorder",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "placeOrder example",
      "data": "contract = Forex('EURUSD')\n\nticker = ib.reqMktDepth(contract)\nib.sleep(2)\n\n# Access order book\nprint(\"Bids:\", [(d.price, d.size) for d in ticker.domBids[:5]])\nprint(\"Asks:\", [(d.price, d.size) for d in ticker.domAsks[:5]])",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "Future(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nFuture('ES', '20240920', 'GLOBEX')  # E-mini S&P\nFuture('CL', '202412', 'NYMEX')     # Crude Oil",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "Option(\n    symbol: str = '',\n    lastTradeDateOrContractMonth: str = '',\n    strike: float = 0.0,\n    right: str = '',            # 'C' or 'P'\n    exchange: str = '',\n    multiplier: str = '',\n    currency: str = ''\n)\n\n# Examples\nOption('SPY', '20240920', 450, 'C', 'SMART')  # Call\nOption('AAPL', '20240315', 180, 'P', 'SMART') # Put",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "Contract(conId=270639)  # Direct lookup by IB contract ID",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# Resolve ambiguous contracts\ncontracts = ib.qualifyContracts(contract)\n# Returns list of fully qualified contracts\n\n# Example\nstock = Stock('AAPL', 'SMART', 'USD')\nqualified = ib.qualifyContracts(stock)[0]\nprint(qualified.conId)  # IB contract ID",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "descriptions = ib.reqMatchingSymbols('app')\n# Returns List[ContractDescription]\n# Fuzzy search for symbols",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ticker = ib.reqMktData(\n    contract: Contract,\n    genericTickList: str = '',\n    snapshot: bool = False,\n    regulatorySnapshot: bool = False,\n    mktDataOptions: List = None\n) -> Ticker\n\n# Ticker auto-updates in real-time",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract, genericTickList='233,236')\nib.sleep(2)\nprint(f\"Last: {ticker.last}\")\nprint(f\"Bid: {ticker.bid}\")\nprint(f\"Ask: {ticker.ask}\")\nprint(f\"Volume: {ticker.volume}\")",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ib.cancelMktData(contract: Contract) -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "@dataclass\nclass Ticker:\n    contract: Contract = None\n    time: datetime = None\n    \n    # Bid/Ask\n    bid: float = nan\n    bidSize: float = nan\n    bidExchange: str = ''\n    ask: float = nan\n    askSize: float = nan\n    askExchange: str = ''\n    \n    # Last trade\n    last: float = nan\n    lastSize: float = nan\n    lastExchange: str = ''\n    \n    # Volume\n    volume: float = nan\n    volumeRate: float = nan\n    \n    # Prices\n    open: float = nan\n    high: float = nan\n    low: float = nan\n    close: float = nan\n    vwap: float = nan\n    \n    # Options\n    putVolume: float = nan\n    callVolume: float = nan\n    putOpenInterest: float = nan\n    callOpenInterest: float = nan\n    avOptionVolume: float = nan\n    impliedVolatility: float = nan\n    histVolatility: float = nan\n    \n    # Greeks (options)\n    delta: float = nan\n    gamma: float = nan\n    theta: float = nan\n    vega: float = nan\n    \n    # Market depth\n    domBids: List = []\n    domAsks: List = []\n    domTicks: List = []\n    \n    # Ticks\n    ticks: List = []\n    tickByTicks: List = []\n    \n    # Halted\n    halted: float = nan\n    \n    # Real-time\n    rtVolume: float = nan\n    rtTime: datetime = None\n    rtHistVolativity: float = nan\n    rtTradeVolume: float = nan\n    \n    # Methods\n    def marketPrice(self) -> float\n    def hasBidAsk(self) -> bool\n    def midpoint(self) -> float",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ticker = ib.reqMktDepth(\n    contract: Contract,\n    numRows: int = 5,\n    isSmartDepth: bool = False,\n    mktDepthOptions: List = None\n) -> Ticker\n\n# Ticker.domBids and Ticker.domAsks auto-update",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ib.cancelMktDepth(contract: Contract) -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ticker = ib.reqTickByTickData(\n    contract: Contract,\n    tickType: str,  # 'Last', 'BidAsk', 'AllLast', 'MidPoint'\n    numberOfTicks: int = 0,\n    ignoreSize: bool = False\n) -> Ticker\n\n# Ticker.tickByTicks auto-updates",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "headTimestamp = ib.reqHeadTimeStamp(\n    contract: Contract,\n    whatToShow: str = 'TRADES',\n    useRTH: bool = True,\n    formatDate: int = 1\n) -> str\n\n# Earliest available data timestamp",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "bars = ib.reqRealTimeBars(\n    contract: Contract,\n    barSize: int = 5,           # Only 5 supported\n    whatToShow: str = 'TRADES', # TRADES, MIDPOINT, BID, ASK\n    useRTH: bool = False,\n    realTimeBarsOptions: List = None\n) -> RealTimeBarList\n\n# Returns RealTimeBarList (auto-updating)\n# bars.updateEvent fires on new bar",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "portfolio = ib.portfolio(account: str = '') -> List[PortfolioItem]\n\n# PortfolioItem fields:\n# .contract\n# .position        - Quantity\n# .marketPrice     - Current price\n# .marketValue     - Position value\n# .averageCost     - Avg cost basis\n# .unrealizedPNL   - Unrealized P&L\n# .realizedPNL     - Realized P&L\n# .account",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "positions = ib.positions(account: str = '') -> List[Position]\n\n# Position fields:\n# .account\n# .contract\n# .position       - Quantity\n# .avgCost        - Average cost",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# For tick data\nticker = ib.reqMktData(contract, '233')  # Last, volume, vwap\nticker.updateEvent += lambda ticker: process_tick(ticker)\n\n# For bar data\nbars = ib.reqRealTimeBars(contract, 5, 'TRADES', False)\nbars.updateEvent += lambda bars, hasNewBar: process_bar(bars, hasNewBar)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\nticker = ib.reqMktData(contract)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def on_error(reqId, errorCode, errorString, contract):\n    if errorCode == 200:\n        print(f\"Contract not found: {contract}\")\n    elif errorCode == 321:\n        print(f\"Validation error: {errorString}\")\n    # Handle other errors...\n\nib.errorEvent += on_error",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# ib-insync handles throttling automatically\nfor contract in large_list:\n    ib.reqMktData(contract)\n# No manual delays needed",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# Cancel unused tickers\nfor contract in old_contracts:\n    ib.cancelMktData(contract)\n\n# Clear refs\ndel ticker",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "class TickFilter:\n    def __init__(self, ib, contract, min_size=100):\n        self.ib = ib\n        self.contract = contract\n        self.min_size = min_size\n        self.large_trades = []\n        \n    def start(self):\n        \"\"\"Start tick-by-tick subscription with filtering\"\"\"\n        self.ticker = self.ib.reqTickByTickData(\n            self.contract,\n            'AllLast',  # All trades\n            0,\n            False\n        )\n        self.ticker.updateEvent += self.on_tick\n    \n    def on_tick(self, ticker):\n        \"\"\"Filter and process ticks\"\"\"\n        if not ticker.tickByTicks:\n            return\n        \n        latest_tick = ticker.tickByTicks[-1]\n        \n        # Filter by size\n        if latest_tick.size >= self.min_size:\n            self.large_trades.append({\n                'time': latest_tick.time,\n                'price': latest_tick.price,\n                'size': latest_tick.size\n            })\n            \n            logging.info(f\"Large trade: {latest_tick.size} @ ${latest_tick.price:.2f}\")\n    \n    def stop(self):\n        \"\"\"Stop subscription\"\"\"\n        self.ib.cancelTickByTickData(self.contract)\n    \n    def get_stats(self):\n        \"\"\"Get statistics on large trades\"\"\"\n        if not self.large_trades:\n            return None\n        \n        total_volume = sum(t['size'] for t in self.large_trades)\n        avg_price = sum(t['price'] * t['size'] for t in self.large_trades) / total_volume\n        \n        return {\n            'num_trades': len(self.large_trades),\n            'total_volume': total_volume,\n            'vwap': avg_price\n        }\n\n# Usage\ncontract = Stock('AAPL', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nfilter = TickFilter(ib, contract, min_size=1000)\nfilter.start()\n\n# Run for period\nib.sleep(3600)  # 1 hour\n\nfilter.stop()\nstats = filter.get_stats()\nprint(f\"Large trades: {stats}\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def qualify_contracts_batch(ib, contracts, batch_size=50):\n    \"\"\"Qualify contracts in batches to avoid rate limits\"\"\"\n    qualified = []\n    \n    for i in range(0, len(contracts), batch_size):\n        batch = contracts[i:i+batch_size]\n        \n        try:\n            qualified_batch = ib.qualifyContracts(*batch)\n            qualified.extend(qualified_batch)\n        except Exception as e:\n            logging.error(f\"Batch qualification failed: {e}\")\n        \n        # Respect rate limits\n        ib.sleep(1)\n    \n    return qualified",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "from collections import deque\nimport threading\n\nclass RequestQueue:\n    def __init__(self, ib, max_per_second=40):\n        self.ib = ib\n        self.queue = deque()\n        self.max_per_second = max_per_second\n        self.running = False\n        \n    def add(self, func, *args, **kwargs):\n        \"\"\"Add request to queue\"\"\"\n        self.queue.append((func, args, kwargs))\n    \n    def start(self):\n        \"\"\"Start processing queue\"\"\"\n        self.running = True\n        thread = threading.Thread(target=self._process)\n        thread.daemon = True\n        thread.start()\n    \n    def _process(self):\n        \"\"\"Process queue with rate limiting\"\"\"\n        delay = 1.0 / self.max_per_second\n        \n        while self.running:\n            if self.queue:\n                func, args, kwargs = self.queue.popleft()\n                \n                try:\n                    func(*args, **kwargs)\n                except Exception as e:\n                    logging.error(f\"Request failed: {e}\")\n                \n                time.sleep(delay)\n            else:\n                time.sleep(0.1)\n    \n    def stop(self):\n        \"\"\"Stop processing\"\"\"\n        self.running = False\n\n# Usage\nqueue = RequestQueue(ib, max_per_second=40)\nqueue.start()\n\n# Queue many requests\nfor contract in large_contract_list:\n    queue.add(ib.reqMktData, contract, '', False, False)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# WRONG - freezes everything\nimport time\nticker = ib.reqMktData(contract)\ntime.sleep(5)  # Event loop frozen, no updates processed\nprint(ticker.last)  # May be empty\n\n# CORRECT - allows message processing\nticker = ib.reqMktData(contract)\nib.sleep(5)  # Framework processes updates in background\nprint(ticker.last)  # Contains current data",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Forex('EURUSD')\nticker = ib.reqMktData(contract)\n\nasync def onTickerUpdate(ticker):\n    print(f\"EUR/USD: Bid {ticker.bid}, Ask {ticker.ask}\")\n    \nticker.updateEvent += onTickerUpdate",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# WRONG - blocks event loop in callback\ndef onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        ib.qualifyContracts(contract)  # Blocking!\n\n# CORRECT - use async handler\nasync def onBarUpdate(bars, hasNewBar):\n    if hasNewBar:\n        await ib.qualifyContractsAsync(contract)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# CORRECT - access live state\ndef check_positions():\n    positions = ib.positions()\n    for pos in positions:\n        print(f\"{pos.contract.symbol}: {pos.position}\")\n\n# WRONG - storing stale copies\ncached_positions = ib.positions()  # Snapshot becomes stale\n# Later...\nprint(cached_positions)  # Likely outdated",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def onPositionUpdate(position):\n    print(f\"Position: {position.contract.symbol}: {position.position}\")\n\nib.positionEvent += onPositionUpdate\n\ndef onPortfolioUpdate(item):\n    print(f\"P&L: {item.contract.symbol}, Unrealized: {item.unrealizedPNL}\")\n\nib.updatePortfolioEvent += onPortfolioUpdate",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# All portfolio items across accounts\nall_portfolio = ib.portfolio()\n\n# Portfolio for specific account\naccount_portfolio = ib.portfolio(account='U1234567')\n\n# All positions\nall_positions = ib.positions()\n\n# Positions for specific account\naccount_positions = ib.positions(account='U1234567')\n\n# Iterate through positions\nfor position in ib.positions():\n    symbol = position.contract.symbol\n    qty = position.position\n    avg_cost = position.avgCost\n    print(f\"{symbol}: {qty} @ ${avg_cost}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# WRONG - threading with asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nexecutor = ThreadPoolExecutor(max_workers=2)\nexecutor.submit(ib.positions)  # Will fail!\n\n# CORRECT - use asyncio tasks\nasync def fetch_multiple_contracts():\n    tasks = [\n        ib.qualifyContractsAsync(contract1),\n        ib.qualifyContractsAsync(contract2),\n        ib.qualifyContractsAsync(contract3)\n    ]\n    results = await asyncio.gather(*tasks)\n    return results",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Contract()\ncontract.secType = 'FUT'\ncontract.symbol = 'MNQ'\ncontract.exchange = 'CME'\ncontract.currency = 'USD'\ncontract.localSymbol = 'MNQZ5'",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Contract(conId=495512516)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# Single contract\ncontract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\n# Multiple contracts concurrently\ncontracts = [\n    Future('ES', '202506', 'CME'),\n    Future('NQ', '202506', 'CME'),\n    Future('CL', '202506', 'NYMEX')\n]\nqualified = ib.qualifyContracts(*contracts)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Future('ES', '202506', 'CME')\nqualified = ib.qualifyContracts(contract)\n\nif qualified:\n    contract = qualified[0]\n    print(f\"ConId: {contract.conId}\")\n    print(f\"Local Symbol: {contract.localSymbol}\")\n    print(f\"Expiry: {contract.lastTradeDateOrContractMonth}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# Too vague - multiple matches\ncontract = Future('ES', exchange='CME')\nib.qualifyContracts(contract)\n# Warning: Ambiguous contract, possibles are [Future('ES', '202506'), ...]\n\n# Specific - unambiguous\ncontract = Future('ES', '202506', 'CME')\nib.qualifyContracts(contract)  # Success\n\n# Or use localSymbol\ncontract = Future('ES', exchange='CME', localSymbol='ESM6')\nib.qualifyContracts(contract)  # Success\n\n# Or use conId (most precise)\ncontract = Contract(conId=495512516)\nib.qualifyContracts(contract)  # Always unambiguous",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Future('ES', '202506', 'CME')\ndetails_list = ib.reqContractDetails(contract)\n\nfor details in details_list:\n    print(f\"ConId: {details.contract.conId}\")\n    print(f\"Local Symbol: {details.contract.localSymbol}\")\n    print(f\"Expiry: {details.contract.lastTradeDateOrContractMonth}\")\n    print(f\"Multiplier: {details.contract.multiplier}\")\n    print(f\"Min Tick: {details.minTick}\")\n    print(f\"Market Name: {details.marketName}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "from datetime import datetime\n\ndef get_front_month_contract(ib, symbol, exchange):\n    \"\"\"Get the front month futures contract\"\"\"\n    contract = Future(symbol, exchange=exchange)\n    contract_details = ib.reqContractDetails(contract)\n    \n    if not contract_details:\n        return None\n    \n    now = datetime.now()\n    active_contracts = []\n    \n    for details in contract_details:\n        expiry_str = details.contract.lastTradeDateOrContractMonth\n        if len(expiry_str) == 8:\n            expiry = datetime.strptime(expiry_str, '%Y%m%d')\n        else:\n            expiry = datetime.strptime(expiry_str, '%Y%m')\n        \n        if expiry > now:\n            active_contracts.append((expiry, details.contract))\n    \n    if not active_contracts:\n        return None\n    \n    # Sort and return front month\n    active_contracts.sort(key=lambda x: x[0])\n    front_month = active_contracts[0][1]\n    \n    qualified = ib.qualifyContracts(front_month)\n    return qualified[0] if qualified else None\n\n# Usage\nes_front = get_front_month_contract(ib, 'ES', 'CME')\nprint(f\"Front month: {es_front.localSymbol}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def check_rollover_needed(contract, days_before=5):\n    \"\"\"Check if rollover needed\"\"\"\n    expiry_str = contract.lastTradeDateOrContractMonth\n    if len(expiry_str) == 8:\n        expiry = datetime.strptime(expiry_str, '%Y%m%d')\n    else:\n        expiry = datetime.strptime(expiry_str + '01', '%Y%m%d')\n    \n    days_to_expiry = (expiry - datetime.now()).days\n    return days_to_expiry <= days_before",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# Request time & sales data\nticker = ib.reqMktData(contract, '233', False, False)\nib.sleep(2)\nprint(f\"VWAP: {ticker.vwap}, Volume: {ticker.rtVolume}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Forex('EURUSD')\n\n# Request 5-second bars\nbars = ib.reqRealTimeBars(\n    contract,\n    5,              # Bar size (only 5 seconds supported)\n    'MIDPOINT',     # Can be TRADES, MIDPOINT, BID, or ASK\n    False           # useRTH\n)\n\n# Access bars list\nprint(bars[-1])  # Most recent bar",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contract = Forex('EURUSD')\n\nticker = ib.reqTickByTickData(\n    contract,\n    'BidAsk',  # Can be Last, AllLast, BidAsk, or MidPoint\n    0,         # numberOfTicks (0 = unlimited)\n    False      # ignoreSize\n)\n\n# Access tick-by-tick data\nprint(ticker.tickByTicks)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def onTickerUpdate(ticker):\n    print(f\"{ticker.contract.symbol}: Last {ticker.last}\")\n\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nticker.updateEvent += onTickerUpdate\n\nib.run()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "contracts = [\n    Stock('AAPL', 'SMART', 'USD'),\n    Stock('GOOGL', 'SMART', 'USD'),\n    Stock('MSFT', 'SMART', 'USD')\n]\n\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\ndef onPendingTickers(tickers):\n    \"\"\"Called when any subscribed ticker has new data\"\"\"\n    for ticker in tickers:\n        print(f\"{ticker.contract.symbol}: {ticker.last}\")\n\nib.pendingTickersEvent += onPendingTickers\nib.run()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "def onBarUpdate(bars, hasNewBar):\n    \"\"\"\n    bars: BarDataList containing all bars\n    hasNewBar: Boolean indicating if a new bar was added\n    \"\"\"\n    if hasNewBar:\n        latest = bars[-1]\n        print(f\"New bar: O={latest.open}, H={latest.high}, \"\n              f\"L={latest.low}, C={latest.close}\")\n\nbars = ib.reqRealTimeBars(contract, 5, 'MIDPOINT', False)\nbars.updateEvent += onBarUpdate\nib.run()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "import pandas as pd\n\ncontracts = [Forex(pair) for pair in ('EURUSD', 'GBPUSD', 'USDJPY')]\nib.qualifyContracts(*contracts)\ntickers = [ib.reqMktData(c) for c in contracts]\n\n# Create DataFrame\ndf = pd.DataFrame(\n    index=[c.pair() for c in contracts],\n    columns=['bidSize', 'bid', 'ask', 'askSize', 'high', 'low', 'close']\n)\n\ndef onPendingTickers(tickers):\n    for t in tickers:\n        df.loc[t.contract.pair()] = (\n            t.bidSize, t.bid, t.ask, t.askSize, \n            t.high, t.low, t.close\n        )\n    print(df)\n\nib.pendingTickersEvent += onPendingTickers\nib.sleep(30)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "for contract in large_contract_list:\n    ticker = ib.reqMktData(contract)\n    ib.sleep(0.02)  # Small delay between requests",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "active_subscriptions = set()\nMAX_SUBSCRIPTIONS = 95  # Leave margin\n\ndef subscribe_with_limit(contract):\n    if len(active_subscriptions) >= MAX_SUBSCRIPTIONS:\n        # Unsubscribe oldest\n        oldest = active_subscriptions.pop()\n        ib.cancelMktData(oldest)\n    \n    ticker = ib.reqMktData(contract)\n    active_subscriptions.add(contract)\n    return ticker",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "class TickerManager:\n    def __init__(self, ib):\n        self.ib = ib\n        self.tickers = {}\n        self.contracts = {}\n        \n    def subscribe(self, symbol, exchange='SMART', currency='USD'):\n        contract = Stock(symbol, exchange, currency)\n        self.ib.qualifyContracts(contract)\n        \n        ticker = self.ib.reqMktData(contract)\n        ticker.updateEvent += self.onUpdate\n        \n        self.tickers[symbol] = ticker\n        self.contracts[symbol] = contract\n        return ticker\n    \n    def unsubscribe(self, symbol):\n        if symbol in self.tickers:\n            self.ib.cancelMktData(self.contracts[symbol])\n            del self.tickers[symbol]\n            del self.contracts[symbol]\n    \n    def onUpdate(self, ticker):\n        symbol = ticker.contract.symbol\n        print(f\"{symbol}: {ticker.last}\")\n\n# Usage\nmanager = TickerManager(ib)\nmanager.subscribe('AAPL')\nmanager.subscribe('GOOGL')",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# WRONG\ncontract1 = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract1)\n\ncontract2 = Stock('AAPL', 'SMART', 'USD')  # Different object!\nib.cancelMktData(contract2)  # Won't work\n\n# CORRECT\ncontract = Stock('AAPL', 'SMART', 'USD')\nticker = ib.reqMktData(contract)\nib.cancelMktData(contract)  # Use same object",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "ticker.updateEvent += handler\n# Later...\nticker.updateEvent -= handler\nib.cancelMktData(contract)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "contract_creation",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "contract_creation",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "contract_creation example",
      "data": "# WRONG - ticks cleared before checking\nticker = ib.reqMktData(contract)\nib.sleep(5)\nprint(ticker.ticks)  # Likely empty\n\n# CORRECT - process in event\ndef onUpdate(ticker):\n    for tick in ticker.ticks:\n        process_tick(tick)\n\nticker.updateEvent += onUpdate",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "bars = ib.reqHistoricalData(\n    contract: Contract,\n    endDateTime: str = '',      # '' = now, or 'YYYYMMDD HH:MM:SS'\n    durationStr: str = '1 D',   # '60 S', '30 D', '13 W', '6 M', '1 Y'\n    barSizeSetting: str = '1 hour',\n    whatToShow: str = 'TRADES', # See below\n    useRTH: bool = True,        # Regular trading hours only\n    formatDate: int = 1,        # 1=yyyyMMdd HH:mm:ss, 2=epoch\n    keepUpToDate: bool = False, # Auto-update\n    chartOptions: List = None,\n    timeout: float = 60\n) -> BarDataList\n\n# Returns BarDataList (auto-synced if keepUpToDate=True)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "contract = Forex('EURUSD')\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='30 D',\n    barSizeSetting='1 hour',\n    whatToShow='MIDPOINT',\n    useRTH=True\n)\n\n# Convert to pandas\nimport pandas as pd\ndf = util.df(bars)\nprint(df.head())",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "ticks = ib.reqHistoricalTicks(\n    contract: Contract,\n    startDateTime: str,\n    endDateTime: str,\n    numberOfTicks: int = 1000,\n    whatToShow: str = 'TRADES',  # 'TRADES', 'BID_ASK', 'MIDPOINT'\n    useRth: bool = True,\n    ignoreSize: bool = False,\n    miscOptions: List = None\n) -> List\n\n# Returns list of HistoricalTick objects",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "schedule = ib.reqHistoricalSchedule(\n    contract: Contract,\n    numDays: int = 1,\n    endDateTime: str = '',\n    useRTH: bool = True\n) -> List[HistoricalSchedule]\n\n# Trading schedule for contract",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "bars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    keepUpToDate=True  # \u2190 Keep updating\n)\n\n# bars.updateEvent fires on changes",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "while True:\n    bars = ib.reqHistoricalData(...)\n    time.sleep(5)  # Also wrong - blocks event loop!",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "# Common causes:\n# 1. Requesting too much data\n# 2. Invalid date range\n# 3. Contract not found\n# 4. No data available for period\n\n# Solution: Break into chunks\ndt = ''\nall_bars = []\nwhile True:\n    bars = ib.reqHistoricalData(\n        contract,\n        endDateTime=dt,\n        durationStr='30 D',\n        barSizeSetting='1 hour',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    if not bars:\n        break\n    all_bars.extend(bars)\n    dt = bars[0].date\n    ib.sleep(1)  # Respect rate limits",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "import numpy as np\nimport pandas as pd\n\ndef calculate_portfolio_correlation_risk(ib, lookback_days=30):\n    \"\"\"Calculate portfolio correlation matrix\"\"\"\n    \n    portfolio = ib.portfolio()\n    symbols = [p.contract.symbol for p in portfolio if p.contract.secType == 'STK']\n    \n    # Get historical data for all positions\n    price_data = {}\n    \n    for symbol in symbols:\n        contract = Stock(symbol, 'SMART', 'USD')\n        contract = ib.qualifyContracts(contract)[0]\n        \n        bars = ib.reqHistoricalData(\n            contract,\n            endDateTime='',\n            durationStr=f'{lookback_days} D',\n            barSizeSetting='1 day',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if bars:\n            price_data[symbol] = [bar.close for bar in bars]\n    \n    # Create DataFrame\n    df = pd.DataFrame(price_data)\n    \n    # Calculate returns\n    returns = df.pct_change().dropna()\n    \n    # Correlation matrix\n    corr_matrix = returns.corr()\n    \n    # Identify highly correlated pairs\n    high_corr_threshold = 0.7\n    high_corr_pairs = []\n    \n    for i in range(len(corr_matrix.columns)):\n        for j in range(i+1, len(corr_matrix.columns)):\n            corr = corr_matrix.iloc[i, j]\n            if abs(corr) > high_corr_threshold:\n                high_corr_pairs.append({\n                    'symbol1': corr_matrix.columns[i],\n                    'symbol2': corr_matrix.columns[j],\n                    'correlation': corr\n                })\n    \n    if high_corr_pairs:\n        logging.warning(f\"High correlation detected: {high_corr_pairs}\")\n    \n    return corr_matrix, high_corr_pairs\n\n# Usage\ncorr_matrix, high_corr = calculate_portfolio_correlation_risk(ib)\nprint(\"Portfolio Correlation Matrix:\")\nprint(corr_matrix)",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "class VolumeProfile:\n    def __init__(self, ib, contract, num_bins=20):\n        self.ib = ib\n        self.contract = contract\n        self.num_bins = num_bins\n        self.profile = {}\n        \n    def build_from_historical(self, days=1):\n        \"\"\"Build volume profile from historical data\"\"\"\n        bars = self.ib.reqHistoricalData(\n            self.contract,\n            endDateTime='',\n            durationStr=f'{days} D',\n            barSizeSetting='5 mins',\n            whatToShow='TRADES',\n            useRTH=True\n        )\n        \n        if not bars:\n            return None\n        \n        # Get price range\n        prices = [bar.close for bar in bars]\n        min_price = min(prices)\n        max_price = max(prices)\n        \n        # Create bins\n        bin_size = (max_price - min_price) / self.num_bins\n        \n        # Accumulate volume in bins\n        for bar in bars:\n            bin_idx = int((bar.close - min_price) / bin_size)\n            bin_idx = min(bin_idx, self.num_bins - 1)  # Cap at max\n            \n            bin_price = min_price + (bin_idx * bin_size)\n            \n            if bin_price not in self.profile:\n                self.profile[bin_price] = 0\n            \n            self.profile[bin_price] += bar.volume\n        \n        return self.profile\n    \n    def get_poc(self):\n        \"\"\"Get Point of Control (price with highest volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        return max(self.profile.items(), key=lambda x: x[1])\n    \n    def get_value_area(self, percent=0.70):\n        \"\"\"Get value area (prices containing X% of volume)\"\"\"\n        if not self.profile:\n            return None\n        \n        total_volume = sum(self.profile.values())\n        target_volume = total_volume * percent\n        \n        # Sort by volume\n        sorted_profile = sorted(self.profile.items(), key=lambda x: x[1], reverse=True)\n        \n        accumulated_volume = 0\n        value_area_prices = []\n        \n        for price, volume in sorted_profile:\n            accumulated_volume += volume\n            value_area_prices.append(price)\n            \n            if accumulated_volume >= target_volume:\n                break\n        \n        return min(value_area_prices), max(value_area_prices)\n\n# Usage\ncontract = Stock('SPY', 'SMART', 'USD')\ncontract = ib.qualifyContracts(contract)[0]\n\nvp = VolumeProfile(ib, contract, num_bins=30)\nprofile = vp.build_from_historical(days=5)\n\npoc_price, poc_volume = vp.get_poc()\nprint(f\"Point of Control: ${poc_price:.2f} with {poc_volume:,.0f} volume\")\n\nva_low, va_high = vp.get_value_area(percent=0.70)\nprint(f\"Value Area: ${va_low:.2f} - ${va_high:.2f}\")",
      "examples": [
        "ib_advanced_patterns.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_advanced_patterns.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "# Request data for expired contract\ncontract = Future('ES', '202012', 'CME')\ncontract.includeExpired = True\n\nqualified = ib.qualifyContracts(contract)\nif qualified:\n    bars = ib.reqHistoricalData(\n        qualified[0],\n        endDateTime='',\n        durationStr='1 Y',\n        barSizeSetting='1 day',\n        whatToShow='TRADES',\n        useRTH=True\n    )\n    print(f\"Retrieved {len(bars)} bars\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "# Continuous futures (historical data only)\ncont_future = ContFuture('ES', 'CME')\nib.qualifyContracts(cont_future)\n\nbars = ib.reqHistoricalData(\n    cont_future,\n    endDateTime='',\n    durationStr='2 Y',\n    barSizeSetting='1 day',\n    whatToShow='TRADES',\n    useRTH=True\n)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "contract = Stock('TSLA', 'SMART', 'USD')\n\nbars = ib.reqHistoricalData(\n    contract,\n    endDateTime='',\n    durationStr='1 D',\n    barSizeSetting='1 min',\n    whatToShow='TRADES',\n    useRTH=True,\n    formatDate=1,\n    keepUpToDate=True  # Enables live updates\n)\n\n# Bars continue updating automatically",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "reqHistoricalData",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "reqhistoricaldata",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "reqHistoricalData example",
      "data": "ib.cancelMktData(contract)\nib.cancelRealTimeBars(bars)\nib.cancelHistoricalData(bars)\nib.cancelTickByTickData(contract, 'BidAsk')\nib.cancelMktDepth(contract)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "bars_request",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "bars_request",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "bars_request example",
      "data": "ib.cancelRealTimeBars(bars: RealTimeBarList) -> None",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "bars_request",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "bars_request",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "bars_request example",
      "data": "import pandas as pd\n\n# Bars to DataFrame\ndf = util.df(bars)\n\n# List of objects to DataFrame\ndf = util.df(ib.positions())\ndf = util.df(ib.accountValues())",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "bars_request",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "bars_request",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "bars_request example",
      "data": "# Solutions:\n# 1. Reduce simultaneous requests\n# 2. Use batch requests where possible\n# 3. Increase TWS memory allocation\n# 4. Use keepUpToDate for live bars instead of repeated requests\n\n# Increase TWS memory:\n# Configuration -> Settings -> Memory Allocation -> 4096 MB",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "bars_request",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "bars_request",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "bars_request example",
      "data": "def onBarUpdate(bars, hasNewBar):\n    if len(bars) > 1000:\n        # Keep only last 1000 bars\n        del bars[:len(bars)-1000]",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "positions",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "positions",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "positions example",
      "data": "pnlSingle = ib.reqPnLSingle(\n    account: str,\n    modelCode: str,\n    conId: int\n) -> PnLSingle\n\n# PnLSingle fields (live-updated):\n# .account\n# .modelCode\n# .conId\n# .dailyPnL\n# .unrealizedPnL\n# .realizedPnL\n# .position\n# .value\n\n# Cancel\nib.cancelPnLSingle(account, modelCode, conId)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "positions",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "positions",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "positions example",
      "data": "# Portfolio updates\nib.updatePortfolioEvent += lambda item: print(f'Portfolio: {item}')\n\n# Position changes\nib.positionEvent += lambda position: print(f'Position: {position}')\n\n# Account value updates\nib.accountValueEvent += lambda value: print(f'{value.tag}: {value.value}')\n\n# PnL updates\nib.pnlEvent += lambda pnl: print(f'PnL: {pnl.dailyPnL}')",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "positions",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "positions",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "positions example",
      "data": "def onUpdate():\n    positions = ib.positions()\n    print(f\"Current positions: {len(positions)}\")\n\nib.updateEvent += onUpdate",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "positions",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "positions",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "positions example",
      "data": "def long_calculation():\n    for i in range(1000):\n        result = expensive_operation()\n        \n        # Periodically yield to allow state updates\n        if i % 100 == 0:\n            ib.sleep(0)\n        \n        # State may have changed during sleep\n        current_positions = ib.positions()",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "positions",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "positions",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "positions example",
      "data": "class TradingBot:\n    def __init__(self, ib):\n        self.ib = ib\n        self._positions_cache = None\n        self._cache_time = None\n        \n    def get_positions(self, max_age=1.0):\n        \"\"\"Get positions with short-term caching\"\"\"\n        now = time.time()\n        if (self._positions_cache is None or \n            self._cache_time is None or \n            now - self._cache_time > max_age):\n            self._positions_cache = self.ib.positions()\n            self._cache_time = now\n        return self._positions_cache",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# Ticker updates\nib.pendingTickersEvent += lambda tickers: handle_tickers(tickers)\n\n# Bar updates\nib.barUpdateEvent += lambda bars, hasNewBar: handle_bars(bars, hasNewBar)\n\n# Scanner data\nib.scannerDataEvent += lambda scanData: print(scanData)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "while True:\n    if ticker.last > 150:\n        break\n    ib.sleep(0.1)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "def on_price_update(ticker):\n    if ticker.last > 150:\n        take_action()\n\nticker.updateEvent += on_price_update",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# Don't use waitOnUpdate() loop for ticks - data loss!\n\n# \u274c BAD\nwhile True:\n    ib.waitOnUpdate()\n    # Some ticks lost!\n\n# \u2705 GOOD - Use events\nticker.updateEvent += lambda t: process(t)",
      "examples": [
        "ib_complete_reference.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_complete_reference.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# Unsubscribe\nticker.updateEvent -= onTickerUpdate\n\n# One-time handler\n@ticker.updateEvent.once\ndef onFirstUpdate(ticker):\n    print(f\"First update received: {ticker.last}\")",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# WRONG - misses rapid ticks\nwhile True:\n    ib.waitOnUpdate()\n    print(ticker.last)\n\n# CORRECT - captures all updates\ndef onTicker(ticker):\n    print(ticker.last)\n    \nticker.updateEvent += onTicker",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# Internal architecture (conceptual)\nIB Instance\n    \u2514\u2500\u2500 Wrapper Instance (single source of truth)\n        \u251c\u2500\u2500 accountValues (dict)\n        \u251c\u2500\u2500 acctSummary (dict)\n        \u251c\u2500\u2500 portfolio (defaultdict)\n        \u251c\u2500\u2500 positions (defaultdict)\n        \u251c\u2500\u2500 trades (dict)\n        \u251c\u2500\u2500 tickers (dict)\n        \u2514\u2500\u2500 [other state collections]\n    \u2514\u2500\u2500 Client Instance (network communication)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "# WRONG - blocks everything\nimport time\n\ndef onTickerUpdate(ticker):\n    time.sleep(5)  # Frozen!\n    process(ticker)\n\n# CORRECT - yields control\ndef onTickerUpdate(ticker):\n    ib.sleep(0)  # Yields to allow message processing\n    process(ticker)",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  },
  {
    "topic": "ticker_subscription",
    "tier": "a3",
    "confidence": 0.75,
    "tags": [
      "ticker_subscription",
      "ib_insync",
      "python"
    ],
    "content": {
      "title": "ticker_subscription example",
      "data": "def onTickerUpdate(ticker):\n    for i in range(1000):\n        process_chunk(i)\n        if i % 100 == 0:\n            ib.sleep(0)  # Yield every 100 iterations",
      "examples": [
        "ib_insync_complete_guide.md"
      ],
      "related": []
    },
    "stats": {
      "mentions": 1,
      "sources": [
        "ib_insync_complete_guide.md"
      ]
    }
  }
]